[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "HuMicA",
    "section": "",
    "text": "The Human Microglia Atlas (HuMicA) is an integrated single-cell (sc) and single nucleus (sn)RNA-seq object encompassing immune cells from nineteen brain tissue datasets across multiple neurodegenerative conditions, including patients diagnosed with Alzheimer´s Disease, Autism Spectrum Disorder, epilepsy, COVID-19, Lewy Body Diseases, Multiple Sclerosis, and individuals without known neuropathology. It encompasses 90,716 nuclei/cells and nine transcriptomically distinct populations.\nA ShinyCell interactive web app is available at https://in7yqx-ricardo-ferreira.shinyapps.io/shinyapp/.\nThis website supplies all the main scripts used for the analyses."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "09. Differential composition.html",
    "href": "09. Differential composition.html",
    "title": "Differential composition",
    "section": "",
    "text": "This script depicts the evaluation of the expansion or depletion of each HuMicA cluster in each pathology in comparison to healthy controls, related to Figure 4.\n\n\n\nlibs &lt;- c(\"sccomp\",\"Seurat\",\"tidyverse\",\"ggpubr\")\nsuppressMessages(\nsuppressWarnings(sapply(libs, require, character.only =TRUE))\n)\n\n   sccomp    Seurat tidyverse    ggpubr \n     TRUE      TRUE      TRUE      TRUE \n\n\n\n\n\nThe sccomp tool tests differences in cell type proportions in single-cell data. For more details check https://github.com/MangiolaLaboratory/sccomp or https://www.bioconductor.org/packages/release/bioc/html/sccomp.html. Important note: the new 1.8.0 version of sccomp has discontinued some of the functions used in this script as the pipeline suffered considerable changes.\n\n# sccomp with contrast (each group vs healthy controls)\n\n## rename some categories to remove blank spaces\nHumica@meta.data &lt;- Humica@meta.data %&gt;% mutate(Group = str_replace(Group, \"No Neuropathology\", \"xHealthy\"))\nHumica@meta.data &lt;- Humica@meta.data %&gt;% mutate(Group = str_replace(Group, \"COVID-19\", \"COVID19\"))\n\n## calculate differential composition\nres = Humica |&gt;\n  sccomp_glm( \n    formula_composition = ~ 0+Group, \n    contrasts =  c(\"GroupAD - GroupxHealthy\",\"GroupASD - GroupxHealthy\",\"GroupCOVID19 - GroupxHealthy\",\n                   \"GroupEpilepsy - GroupxHealthy\",\"GroupLBD - GroupxHealthy\",\"GroupMS - GroupxHealthy\"),\n    .sample =Sample_ID,\n    .cell_group = integrated_snn_res.0.2 , \n   bimodal_mean_variability_association = TRUE,\n    cores = 5\n  )\n\n\n# Boxplot of the group proportion, faceted by cluster. The blue boxplots represent the posterior check and the outliers are coloured in red.\nplots = plot_summary(res)\nplots$boxplot\n\n\n## Plot the estimates of differential composition\n### define if each comparison is significant or not\nres$sig&lt;-  ifelse(res$c_FDR&lt;0.05, \"yes\", \"no\")\n\nggplot(res, aes(x = factor(integrated_snn_res.0.2, levels= levels(Idents(Humica))),\n                y = res$c_effect, color=sig)) +\n  geom_point(stat = \"identity\", shape = 15) +\n  scale_color_manual(values = c(\"grey\",\"#A21F16\"))+\n  geom_hline(yintercept = c(-0.2,0.2), linetype = \"dashed\", color = \"grey\") +\n  geom_errorbar(aes(ymin = c_lower, ymax = c_upper), width = 0.4) +\n  facet_wrap(~parameter,scales=\"free\",ncol = 6)+\n  ylab(\"Credible interval of the slope\")+\n  xlab(\"Cluster\")+\n  coord_flip()+\n  theme_pubr()+\n  border()\n\nWarning: Use of `res$c_effect` is discouraged.\nℹ Use `c_effect` instead.\nUse of `res$c_effect` is discouraged.\nℹ Use `c_effect` instead."
  },
  {
    "objectID": "09. Differential composition.html#differential-composition",
    "href": "09. Differential composition.html#differential-composition",
    "title": "Differential composition",
    "section": "",
    "text": "This script depicts the evaluation of the expansion or depletion of each HuMicA cluster in each pathology in comparison to healthy controls, related to Figure 4.\n\n\n\nlibs &lt;- c(\"sccomp\",\"Seurat\",\"tidyverse\",\"ggpubr\")\nsuppressMessages(\nsuppressWarnings(sapply(libs, require, character.only =TRUE))\n)\n\n   sccomp    Seurat tidyverse    ggpubr \n     TRUE      TRUE      TRUE      TRUE \n\n\n\n\n\nThe sccomp tool tests differences in cell type proportions in single-cell data. For more details check https://github.com/MangiolaLaboratory/sccomp or https://www.bioconductor.org/packages/release/bioc/html/sccomp.html. Important note: the new 1.8.0 version of sccomp has discontinued some of the functions used in this script as the pipeline suffered considerable changes.\n\n# sccomp with contrast (each group vs healthy controls)\n\n## rename some categories to remove blank spaces\nHumica@meta.data &lt;- Humica@meta.data %&gt;% mutate(Group = str_replace(Group, \"No Neuropathology\", \"xHealthy\"))\nHumica@meta.data &lt;- Humica@meta.data %&gt;% mutate(Group = str_replace(Group, \"COVID-19\", \"COVID19\"))\n\n## calculate differential composition\nres = Humica |&gt;\n  sccomp_glm( \n    formula_composition = ~ 0+Group, \n    contrasts =  c(\"GroupAD - GroupxHealthy\",\"GroupASD - GroupxHealthy\",\"GroupCOVID19 - GroupxHealthy\",\n                   \"GroupEpilepsy - GroupxHealthy\",\"GroupLBD - GroupxHealthy\",\"GroupMS - GroupxHealthy\"),\n    .sample =Sample_ID,\n    .cell_group = integrated_snn_res.0.2 , \n   bimodal_mean_variability_association = TRUE,\n    cores = 5\n  )\n\n\n# Boxplot of the group proportion, faceted by cluster. The blue boxplots represent the posterior check and the outliers are coloured in red.\nplots = plot_summary(res)\nplots$boxplot\n\n\n## Plot the estimates of differential composition\n### define if each comparison is significant or not\nres$sig&lt;-  ifelse(res$c_FDR&lt;0.05, \"yes\", \"no\")\n\nggplot(res, aes(x = factor(integrated_snn_res.0.2, levels= levels(Idents(Humica))),\n                y = res$c_effect, color=sig)) +\n  geom_point(stat = \"identity\", shape = 15) +\n  scale_color_manual(values = c(\"grey\",\"#A21F16\"))+\n  geom_hline(yintercept = c(-0.2,0.2), linetype = \"dashed\", color = \"grey\") +\n  geom_errorbar(aes(ymin = c_lower, ymax = c_upper), width = 0.4) +\n  facet_wrap(~parameter,scales=\"free\",ncol = 6)+\n  ylab(\"Credible interval of the slope\")+\n  xlab(\"Cluster\")+\n  coord_flip()+\n  theme_pubr()+\n  border()\n\nWarning: Use of `res$c_effect` is discouraged.\nℹ Use `c_effect` instead.\nUse of `res$c_effect` is discouraged.\nℹ Use `c_effect` instead."
  },
  {
    "objectID": "07. Homeostatic clusters.html",
    "href": "07. Homeostatic clusters.html",
    "title": "Homeostatic clusters",
    "section": "",
    "text": "This script depicts the specific and in-depth characterization of the homeostatic clusters, including gene markers, gene ontology and transcription factor enrichment, related to Figure 2.\n\n\n\nlibs &lt;- c(\"Seurat\", \"tidyverse\", \"clusterProfiler\",\"viper\",\"dorothea\",\"org.Hs.eg.db\",\"ggrepel\",\"gridExtra\",\"ggpubr\",\"data.table\")\nsuppressMessages(\nsuppressWarnings(sapply(libs, require, character.only =TRUE))\n)\n\n         Seurat       tidyverse clusterProfiler           viper        dorothea \n           TRUE            TRUE            TRUE            TRUE            TRUE \n   org.Hs.eg.db         ggrepel       gridExtra          ggpubr      data.table \n           TRUE            TRUE            TRUE            TRUE            TRUE \n\n\n\n\n\nDendrogram accounting for the averaged gene expression of the cluster markers (from Figure 1F) per cluster. The “RNA” assay was used. The calculation of the significant cluster markers is depicted at the “Characterization of the HuMicA” script from this repository.\n\ngenes &lt;- sig_markers$gene\nmat &lt;- AverageExpression(Humica)$RNA %&gt;% data.frame()\nmat &lt;- mat[genes,] %&gt;% as.matrix() \n\nseeds_df_sc &lt;- as.data.frame(scale(mat))\nsummary(seeds_df_sc)\n\n\nhc &lt;-hclust(as.dist(1-cor(seeds_df_sc, method=\"spearman\")), method=\"ward.D\") \nsampleTree = as.dendrogram(hc)\n\nplot(sampleTree)\n\n\n\n\n\n\n\n\n\n\n\nThe representation of the HuMicA object was edited to depict only the four homeostatic populations, namely clusters 0 (Homeos1), 4 (Homeos2) and 8 (Homeos3).\n\ncolor_clusters &lt;-c(\"#fdc835ff\", \"white\", \"white\" ,\"white\", \"#D43921\" ,\"white\", \"white\" ,\"white\", \"#5B7B7A\")\nDimPlot(Humica, reduction = \"umap\",cols = color_clusters, repel = TRUE, pt.size = 0.01, label = F)+NoLegend()\n\n\n\n\n\n\n\n\n\n\n\nThe top 10 signigicant markers for clusters 0, 4 and 8 were represented.\n\n\n\nhomeos_markers &lt;- sig_markers[sig_markers$cluster %in% c(\"0\",\"4\",\"8\"),]\nhomeos_markers$avg_log2FC&lt;- as.numeric(homeos_markers$avg_log2FC)\n\nhomeos_markers %&gt;%\n  group_by(cluster) %&gt;% arrange(-avg_log2FC) %&gt;% arrange(cluster) %&gt;% \n  top_n(n = 10, wt = avg_log2FC)-&gt; top10_up \n\nDefaultAssay(Humica) &lt;- \"RNA\"\nHumica&lt;- NormalizeData(Humica)\n\nDotPlot(Humica, features = factor(rev(top10_up$gene %&gt;% unique), levels = rev(top10_up$gene %&gt;% unique)) , dot.scale = 10) +\n  scale_colour_gradient2(low = \"darkblue\", mid = \"white\", high = \"darkred\")+\n  theme(axis.text.x = element_text(angle=90, hjust = 0))+coord_flip()\n\n\n\n\n\n\n\n\n\n\n\nThe most prominent markers of each cluster were represented separately in Feature plots: P2RY12 and KBTBD12 for Homeos1; GRID2 for Homeos2; SERPINE1 for Homeos3 (related to Supplementary Figure 6A).\n\nHumica &lt;- SetIdent(Humica, value = Humica@meta.data$integrated_snn_res.0.2)\nDefaultAssay(Humica)&lt;-\"RNA\"\nHumica &lt;- NormalizeData(Humica)\n\nFeaturePlot(Humica, features = c(\"P2RY12\",\"KBTBD12\",\"GRID2\",\"SERPINE1\"), ncol=4,label = F, repel = TRUE,pt.size = 0.5) & scale_colour_gradientn(colours = c(\"#FCFCFF\",\"#FCFCFF\",\"#DCF2CE\",\"#FFCB77\",\"#BD6B73\",\"#A30B37\"))\n\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n\n\n\n\n\n\n\n\n\n\n\n\n\nGene ontology (GO) was calculated with the enrichGO function from clusterProfiler.\n\n\nGO enrichment was calculated for the list of markers of each homeostatic cluster. The simplify function was used to remove redundancy to the obtained results. The cnetplots were set to represent only the top 3 categories.\n\ni=0\n\np &lt;- list()\nfor(comparison in levels(factor(homeos_markers$cluster))){\n  i = i+1\n  print(paste(comparison))\n  \n  ego &lt;- enrichGO(gene              = homeos_markers[homeos_markers$cluster == comparison,]$gene,\n                  OrgDb             = org.Hs.eg.db,\n                  ont               = \"ALL\",\n                  keyType           = \"SYMBOL\",\n                  pAdjustMethod     = \"BH\",\n                  pvalueCutoff      = 1,\n                  qvalueCutoff      = 0.05,\n                  readable          = T )\n  ego &lt;- simplify(ego, cutoff=0.7, by=\"p.adjust\", select_fun=min)\n  \n  geneList &lt;- homeos_markers[homeos_markers$cluster==comparison,]$avg_log2FC\n  names(geneList)&lt;-homeos_markers[homeos_markers$cluster==comparison,]$gene\n  \n  p[[i]]&lt;- cnetplot(ego, cex_label_category=1,colorEdge = F,shadowtext=\"none\",showCategory = 3,categorySize=\"pvalue\", foldChange =geneList, color_category=\"#339989\") + ggtitle(comparison) &\n    scale_colour_gradient2(high = \"#8B0000\", low=\"#371E97\", midpoint = 0)\n}\n\np[1]\n\n\n\n\n\n\n\np[2]\n\n\n\n\n\n\n\np[3]\n\n\n\n\n\n\n\n\n\n\n\nThe top 10 significant GO terms for each of the homeostatic clusters were represented in barplots to provide a broader insight on the GO enrichment (related to Supplementary Figure 6B). GO was recalculated and edited to obtain the Fold Change of enrichment.\n\ni = 0\nresults &lt;- list()\ngo_all_simplify &lt;- data.frame()\nfor(comparison in levels(factor(homeos_markers$cluster))){\n  i = i+1\n  print(paste(comparison))\n  ego &lt;- enrichGO(gene              = homeos_markers[homeos_markers$cluster == comparison,]$gene,\n                  OrgDb             = org.Hs.eg.db,\n                  ont               = \"ALL\",\n                  keyType           = \"SYMBOL\",\n                  pAdjustMethod     = \"BH\",\n                  pvalueCutoff      = 1,\n                  qvalueCutoff      = 0.05,\n                  readable          = T )\n  ego &lt;- simplify(ego, cutoff=0.7, by=\"p.adjust\", select_fun=min)\n  \n  results[[comparison]] &lt;- ego@result %&gt;%\n    separate(GeneRatio, into = c(\"gene_pos\", \"gene_total\"), sep = \"/\") %&gt;%\n    separate(BgRatio, into = c(\"bg_pos\", \"bg_total\"), sep = \"/\") %&gt;%\n    mutate(FC = (as.numeric(gene_pos)/as.numeric(gene_total)) /\n             (as.numeric(bg_pos)/as.numeric(bg_total)),\n           cluster = comparison) %&gt;%\n    arrange(.$p.adjust)\n  go_all_simplify &lt;- rbind(go_all_simplify, results[[comparison]])\n}\n\n[1] \"0\"\n[1] \"4\"\n[1] \"8\"\n\n\n\nclusterlist &lt;- c(\"0\",\"4\",\"8\")\np&lt;-list()\nfor (i in 1:length(clusterlist)) {\n  data &lt;-go_all_simplify[go_all_simplify$cluster==clusterlist[i],]\n  data$logpadj &lt;- -log10(data$p.adjust)\n  data$logFC&lt;- log10(data$FC)\n  top10 &lt;- data %&gt;%top_n(n = 10, wt = logpadj)\n  top10 &lt;- top10[1:10,]\n  \n  \n  p[[i]]&lt;- ggplot(top10,\n                  aes(fill=logFC,\n                      x=factor(ID, level = rev(ID)),\n                      y=logpadj,\n                      color=\"black\")) +\n    geom_col(color=\"black\", size=0.2) +\n    geom_text(aes(label = Description), hjust=0,position = position_fill(vjust = 0), size = 4, color=\"black\")+\n    theme_bw() +\n    scale_fill_gradientn(colours = c(\"#B9CFD4\",\"#AFAAB9\",\"#B48291\",\"#8C5465\"))+\n    #scale_fill_viridis(option = \"plasma\")+\n    coord_flip()\n}\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\ndo.call(grid.arrange,p)\n\n\n\n\n\n\n\n\n\n\n\n\nThe collection of transcription factors (TFs) and their target genes was obtained from the DoRothEA regulon A. The enrichment analysis was performed using the viper package. The regulon object downloaded from https://github.com/deeenes/DoRothEA/tree/master/data/TFregulons/Robjects_VIPERformat/consensus, already in the appropriate format to be used in the viper pipeline. The Humica.markers file correspond to the broad spectrum differential expression output, mentioned in the “Characterization of the HuMicA” script of this repository. The following represents the loop for the calculation of TF enrichment in all nine clusters.\n\nregulon_A&lt;- viper_regulon\nnames(regulon_A)=sapply(strsplit(names(regulon_A),split=\" - \"),head, 1)\n\nlist &lt;- unique(Humica_markers$cluster)\nTF_activities_all &lt;- data.frame()\n\nfor (i in 1:length(list)) {\n\ndata &lt;- Humica_markers[Humica_markers$cluster==list[i],]\n\n#Exclude probes with unknown or duplicated gene symbol\nDEsignature = subset(data, gene != \"\" )\n\nDEsignature = subset(DEsignature, ! duplicated(gene))\n\n# Estimatez-score values for the GES. Cheeck VIPER manual for details\n\nmyStatistics = matrix(DEsignature$avg_log2FC, dimnames = list(DEsignature$gene,\n                                                              \n                                                              'avg_log2FC') )\n\nmyPvalue = matrix(DEsignature$p_val_adj, dimnames = list(DEsignature$gene, 'padj') )\n\nmySignature = (qnorm(myPvalue/2, lower.tail = FALSE) * sign(myStatistics))[, 1]\n\nmySignature = mySignature[order(mySignature, decreasing = T)]\n\n# Estimate TF activities\n\nmrs = msviper(ges = mySignature, regulon = regulon_A,minsize = 25, ges.filter = F)\n\nTF_activities = data.frame(Regulon = names(mrs$es$nes),\n                           \n                           Size = mrs$es$size[ names(mrs$es$nes) ],\n                           \n                           NES = mrs$es$nes,\n                           \n                           p.value = mrs$es$p.value,\n                           \n                           FDR = p.adjust(mrs$es$p.value, method = 'fdr'))\n\nTF_activities = TF_activities[ order(TF_activities$p.value), ]\nTF_activities$cluster &lt;- list[i]\nTF_activities_all&lt;- rbind(TF_activities_all, TF_activities)\n}\n\n\n\nThe plot depicts the enrichment for all clusters in the HuMicA but only considers the significant TFs for the three homeostatic clusters is considered for representation. The statistically significant TFs were considered for an adj p value (FDR) &lt; 0.05.\n\nTF_activities_homeos &lt;- TF_activities_all[TF_activities_all$cluster %in% c(\"0\",\"4\",\"8\"),]\n\nTF_activities_homeos_sig &lt;- TF_activities_homeos[TF_activities_homeos$FDR &lt; 0.05,]\n\n#Plot TF enrichment results\nTF_activities_all &lt;- TF_activities_all%&gt;% \n  mutate(logFDR = -log(FDR))\n\ncommon_features &lt;- TF_activities_homeos_sig$Regulon %&gt;% unique()\n\nggplot(TF_activities_all %&gt;% dplyr::filter(Regulon %in% common_features), aes(as.factor(cluster), y= factor(Regulon, levels = common_features),color=NES,size =logFDR)) +\n  geom_point() +\n  scale_color_gradient2(low=\"#47663D\",mid = \"white\",high=\"#B86B00\")+\n  theme_pubr(border = 1)+ \n  coord_flip()+\n  theme(axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5))"
  },
  {
    "objectID": "07. Homeostatic clusters.html#homeostatic-clusters",
    "href": "07. Homeostatic clusters.html#homeostatic-clusters",
    "title": "Homeostatic clusters",
    "section": "",
    "text": "This script depicts the specific and in-depth characterization of the homeostatic clusters, including gene markers, gene ontology and transcription factor enrichment, related to Figure 2.\n\n\n\nlibs &lt;- c(\"Seurat\", \"tidyverse\", \"clusterProfiler\",\"viper\",\"dorothea\",\"org.Hs.eg.db\",\"ggrepel\",\"gridExtra\",\"ggpubr\",\"data.table\")\nsuppressMessages(\nsuppressWarnings(sapply(libs, require, character.only =TRUE))\n)\n\n         Seurat       tidyverse clusterProfiler           viper        dorothea \n           TRUE            TRUE            TRUE            TRUE            TRUE \n   org.Hs.eg.db         ggrepel       gridExtra          ggpubr      data.table \n           TRUE            TRUE            TRUE            TRUE            TRUE \n\n\n\n\n\nDendrogram accounting for the averaged gene expression of the cluster markers (from Figure 1F) per cluster. The “RNA” assay was used. The calculation of the significant cluster markers is depicted at the “Characterization of the HuMicA” script from this repository.\n\ngenes &lt;- sig_markers$gene\nmat &lt;- AverageExpression(Humica)$RNA %&gt;% data.frame()\nmat &lt;- mat[genes,] %&gt;% as.matrix() \n\nseeds_df_sc &lt;- as.data.frame(scale(mat))\nsummary(seeds_df_sc)\n\n\nhc &lt;-hclust(as.dist(1-cor(seeds_df_sc, method=\"spearman\")), method=\"ward.D\") \nsampleTree = as.dendrogram(hc)\n\nplot(sampleTree)\n\n\n\n\n\n\n\n\n\n\n\nThe representation of the HuMicA object was edited to depict only the four homeostatic populations, namely clusters 0 (Homeos1), 4 (Homeos2) and 8 (Homeos3).\n\ncolor_clusters &lt;-c(\"#fdc835ff\", \"white\", \"white\" ,\"white\", \"#D43921\" ,\"white\", \"white\" ,\"white\", \"#5B7B7A\")\nDimPlot(Humica, reduction = \"umap\",cols = color_clusters, repel = TRUE, pt.size = 0.01, label = F)+NoLegend()\n\n\n\n\n\n\n\n\n\n\n\nThe top 10 signigicant markers for clusters 0, 4 and 8 were represented.\n\n\n\nhomeos_markers &lt;- sig_markers[sig_markers$cluster %in% c(\"0\",\"4\",\"8\"),]\nhomeos_markers$avg_log2FC&lt;- as.numeric(homeos_markers$avg_log2FC)\n\nhomeos_markers %&gt;%\n  group_by(cluster) %&gt;% arrange(-avg_log2FC) %&gt;% arrange(cluster) %&gt;% \n  top_n(n = 10, wt = avg_log2FC)-&gt; top10_up \n\nDefaultAssay(Humica) &lt;- \"RNA\"\nHumica&lt;- NormalizeData(Humica)\n\nDotPlot(Humica, features = factor(rev(top10_up$gene %&gt;% unique), levels = rev(top10_up$gene %&gt;% unique)) , dot.scale = 10) +\n  scale_colour_gradient2(low = \"darkblue\", mid = \"white\", high = \"darkred\")+\n  theme(axis.text.x = element_text(angle=90, hjust = 0))+coord_flip()\n\n\n\n\n\n\n\n\n\n\n\nThe most prominent markers of each cluster were represented separately in Feature plots: P2RY12 and KBTBD12 for Homeos1; GRID2 for Homeos2; SERPINE1 for Homeos3 (related to Supplementary Figure 6A).\n\nHumica &lt;- SetIdent(Humica, value = Humica@meta.data$integrated_snn_res.0.2)\nDefaultAssay(Humica)&lt;-\"RNA\"\nHumica &lt;- NormalizeData(Humica)\n\nFeaturePlot(Humica, features = c(\"P2RY12\",\"KBTBD12\",\"GRID2\",\"SERPINE1\"), ncol=4,label = F, repel = TRUE,pt.size = 0.5) & scale_colour_gradientn(colours = c(\"#FCFCFF\",\"#FCFCFF\",\"#DCF2CE\",\"#FFCB77\",\"#BD6B73\",\"#A30B37\"))\n\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n\n\n\n\n\n\n\n\n\n\n\n\n\nGene ontology (GO) was calculated with the enrichGO function from clusterProfiler.\n\n\nGO enrichment was calculated for the list of markers of each homeostatic cluster. The simplify function was used to remove redundancy to the obtained results. The cnetplots were set to represent only the top 3 categories.\n\ni=0\n\np &lt;- list()\nfor(comparison in levels(factor(homeos_markers$cluster))){\n  i = i+1\n  print(paste(comparison))\n  \n  ego &lt;- enrichGO(gene              = homeos_markers[homeos_markers$cluster == comparison,]$gene,\n                  OrgDb             = org.Hs.eg.db,\n                  ont               = \"ALL\",\n                  keyType           = \"SYMBOL\",\n                  pAdjustMethod     = \"BH\",\n                  pvalueCutoff      = 1,\n                  qvalueCutoff      = 0.05,\n                  readable          = T )\n  ego &lt;- simplify(ego, cutoff=0.7, by=\"p.adjust\", select_fun=min)\n  \n  geneList &lt;- homeos_markers[homeos_markers$cluster==comparison,]$avg_log2FC\n  names(geneList)&lt;-homeos_markers[homeos_markers$cluster==comparison,]$gene\n  \n  p[[i]]&lt;- cnetplot(ego, cex_label_category=1,colorEdge = F,shadowtext=\"none\",showCategory = 3,categorySize=\"pvalue\", foldChange =geneList, color_category=\"#339989\") + ggtitle(comparison) &\n    scale_colour_gradient2(high = \"#8B0000\", low=\"#371E97\", midpoint = 0)\n}\n\np[1]\n\n\n\n\n\n\n\np[2]\n\n\n\n\n\n\n\np[3]\n\n\n\n\n\n\n\n\n\n\n\nThe top 10 significant GO terms for each of the homeostatic clusters were represented in barplots to provide a broader insight on the GO enrichment (related to Supplementary Figure 6B). GO was recalculated and edited to obtain the Fold Change of enrichment.\n\ni = 0\nresults &lt;- list()\ngo_all_simplify &lt;- data.frame()\nfor(comparison in levels(factor(homeos_markers$cluster))){\n  i = i+1\n  print(paste(comparison))\n  ego &lt;- enrichGO(gene              = homeos_markers[homeos_markers$cluster == comparison,]$gene,\n                  OrgDb             = org.Hs.eg.db,\n                  ont               = \"ALL\",\n                  keyType           = \"SYMBOL\",\n                  pAdjustMethod     = \"BH\",\n                  pvalueCutoff      = 1,\n                  qvalueCutoff      = 0.05,\n                  readable          = T )\n  ego &lt;- simplify(ego, cutoff=0.7, by=\"p.adjust\", select_fun=min)\n  \n  results[[comparison]] &lt;- ego@result %&gt;%\n    separate(GeneRatio, into = c(\"gene_pos\", \"gene_total\"), sep = \"/\") %&gt;%\n    separate(BgRatio, into = c(\"bg_pos\", \"bg_total\"), sep = \"/\") %&gt;%\n    mutate(FC = (as.numeric(gene_pos)/as.numeric(gene_total)) /\n             (as.numeric(bg_pos)/as.numeric(bg_total)),\n           cluster = comparison) %&gt;%\n    arrange(.$p.adjust)\n  go_all_simplify &lt;- rbind(go_all_simplify, results[[comparison]])\n}\n\n[1] \"0\"\n[1] \"4\"\n[1] \"8\"\n\n\n\nclusterlist &lt;- c(\"0\",\"4\",\"8\")\np&lt;-list()\nfor (i in 1:length(clusterlist)) {\n  data &lt;-go_all_simplify[go_all_simplify$cluster==clusterlist[i],]\n  data$logpadj &lt;- -log10(data$p.adjust)\n  data$logFC&lt;- log10(data$FC)\n  top10 &lt;- data %&gt;%top_n(n = 10, wt = logpadj)\n  top10 &lt;- top10[1:10,]\n  \n  \n  p[[i]]&lt;- ggplot(top10,\n                  aes(fill=logFC,\n                      x=factor(ID, level = rev(ID)),\n                      y=logpadj,\n                      color=\"black\")) +\n    geom_col(color=\"black\", size=0.2) +\n    geom_text(aes(label = Description), hjust=0,position = position_fill(vjust = 0), size = 4, color=\"black\")+\n    theme_bw() +\n    scale_fill_gradientn(colours = c(\"#B9CFD4\",\"#AFAAB9\",\"#B48291\",\"#8C5465\"))+\n    #scale_fill_viridis(option = \"plasma\")+\n    coord_flip()\n}\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\ndo.call(grid.arrange,p)\n\n\n\n\n\n\n\n\n\n\n\n\nThe collection of transcription factors (TFs) and their target genes was obtained from the DoRothEA regulon A. The enrichment analysis was performed using the viper package. The regulon object downloaded from https://github.com/deeenes/DoRothEA/tree/master/data/TFregulons/Robjects_VIPERformat/consensus, already in the appropriate format to be used in the viper pipeline. The Humica.markers file correspond to the broad spectrum differential expression output, mentioned in the “Characterization of the HuMicA” script of this repository. The following represents the loop for the calculation of TF enrichment in all nine clusters.\n\nregulon_A&lt;- viper_regulon\nnames(regulon_A)=sapply(strsplit(names(regulon_A),split=\" - \"),head, 1)\n\nlist &lt;- unique(Humica_markers$cluster)\nTF_activities_all &lt;- data.frame()\n\nfor (i in 1:length(list)) {\n\ndata &lt;- Humica_markers[Humica_markers$cluster==list[i],]\n\n#Exclude probes with unknown or duplicated gene symbol\nDEsignature = subset(data, gene != \"\" )\n\nDEsignature = subset(DEsignature, ! duplicated(gene))\n\n# Estimatez-score values for the GES. Cheeck VIPER manual for details\n\nmyStatistics = matrix(DEsignature$avg_log2FC, dimnames = list(DEsignature$gene,\n                                                              \n                                                              'avg_log2FC') )\n\nmyPvalue = matrix(DEsignature$p_val_adj, dimnames = list(DEsignature$gene, 'padj') )\n\nmySignature = (qnorm(myPvalue/2, lower.tail = FALSE) * sign(myStatistics))[, 1]\n\nmySignature = mySignature[order(mySignature, decreasing = T)]\n\n# Estimate TF activities\n\nmrs = msviper(ges = mySignature, regulon = regulon_A,minsize = 25, ges.filter = F)\n\nTF_activities = data.frame(Regulon = names(mrs$es$nes),\n                           \n                           Size = mrs$es$size[ names(mrs$es$nes) ],\n                           \n                           NES = mrs$es$nes,\n                           \n                           p.value = mrs$es$p.value,\n                           \n                           FDR = p.adjust(mrs$es$p.value, method = 'fdr'))\n\nTF_activities = TF_activities[ order(TF_activities$p.value), ]\nTF_activities$cluster &lt;- list[i]\nTF_activities_all&lt;- rbind(TF_activities_all, TF_activities)\n}\n\n\n\nThe plot depicts the enrichment for all clusters in the HuMicA but only considers the significant TFs for the three homeostatic clusters is considered for representation. The statistically significant TFs were considered for an adj p value (FDR) &lt; 0.05.\n\nTF_activities_homeos &lt;- TF_activities_all[TF_activities_all$cluster %in% c(\"0\",\"4\",\"8\"),]\n\nTF_activities_homeos_sig &lt;- TF_activities_homeos[TF_activities_homeos$FDR &lt; 0.05,]\n\n#Plot TF enrichment results\nTF_activities_all &lt;- TF_activities_all%&gt;% \n  mutate(logFDR = -log(FDR))\n\ncommon_features &lt;- TF_activities_homeos_sig$Regulon %&gt;% unique()\n\nggplot(TF_activities_all %&gt;% dplyr::filter(Regulon %in% common_features), aes(as.factor(cluster), y= factor(Regulon, levels = common_features),color=NES,size =logFDR)) +\n  geom_point() +\n  scale_color_gradient2(low=\"#47663D\",mid = \"white\",high=\"#B86B00\")+\n  theme_pubr(border = 1)+ \n  coord_flip()+\n  theme(axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5))"
  },
  {
    "objectID": "06. Characterization of the HuMicA.html",
    "href": "06. Characterization of the HuMicA.html",
    "title": "Characterization of the HuMicA",
    "section": "",
    "text": "The following script depicts the identification and characterization of the nine populations within the HuMicA, and relates to the results represented in Figure 1 of the paper.\n\n\n\nlibs &lt;- c(\"Seurat\", \"tidyverse\", \"gplots\", \"ComplexHeatmap\",\"circlize\",\"readxl\", \"fgsea\",\"ggpubr\")\nsuppressMessages(\nsuppressWarnings(sapply(libs, require, character.only =TRUE))\n)\n\n        Seurat      tidyverse         gplots ComplexHeatmap       circlize \n          TRUE           TRUE           TRUE           TRUE           TRUE \n        readxl          fgsea         ggpubr \n          TRUE           TRUE           TRUE \n\n\n\n\n\n\ncolor_clusters &lt;-c(\"#fdc835ff\", \"#FC8D62\", \"#7570B3\" ,\"#679436\", \"#D43921\" ,\"#344D67\", \"#874C62\" ,\"#937666\", \"#5B7B7A\" )\nDefaultAssay(Humica)&lt;-\"integrated\"\nDimPlot(Humica, reduction = \"umap\", order = rev(levels(Idents(Humica))),\n        cols = color_clusters, \n        group.by = \"integrated_snn_res.0.2\", raster = FALSE,pt.size =0.001)\n\n\n\n\n\n\n\n\n\n\n\nThe number of cells/nucleis and the mean number of genes per cell/nucleus were calculated for each cluster and represented in a barplot.\n\ncluster0&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"0\"]\ncluster1&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"1\"]\ncluster2&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"2\"]\ncluster3&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"3\"]\ncluster4&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"4\"]\ncluster5&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"5\"]\ncluster6&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"6\"]\ncluster7&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"7\"]\ncluster8&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"8\"]\n\n#\nmain.list &lt;- list(cluster0, cluster1, cluster2,cluster3, cluster4, cluster5,\n                  cluster6, cluster7, cluster8)\n\nmy.files &lt;-c(\"cluster0\", \"cluster1\", \"cluster2\",\"cluster3\", \"cluster4\", \"cluster5\",\n             \"cluster6\", \"cluster7\",\"cluster8\")\n\ndf &lt;- data.frame(Sample=my.files, Nuclei=\"\", Genes=\"\")\nnumber_nuclei= numeric(length(my.files))\nnumber_genes = numeric(length(my.files))\n\nfor (i in 1:length(main.list)) {\n  \n  number_nuclei[i]&lt;- nrow(main.list[[i]]@meta.data)\n  number_genes[i] &lt;- mean(main.list[[i]]@meta.data$nFeature_RNA)\n}\n\ndf$Nuclei = number_nuclei\ndf$Genes = number_genes\ndf$Genes = format(round(df$Genes, 0))\n\ndf$Label &lt;- paste0(df$Nuclei,\"(\",df$Genes,\")\")\ndf &lt;- df[order(df$Nuclei),]\ndf\n\n    Sample Nuclei Genes       Label\n9 cluster8   1563  1305  1563(1305)\n8 cluster7   2425  1281  2425(1281)\n7 cluster6   2616  1468  2616(1468)\n6 cluster5   3195  1303  3195(1303)\n5 cluster4   8559  1344  8559(1344)\n4 cluster3   8635  1069  8635(1069)\n3 cluster2  16186  1371 16186(1371)\n2 cluster1  21974  1281 21974(1281)\n1 cluster0  25563  1281 25563(1281)\n\nggplot(df, aes(x= factor(df$Sample, levels = df$Sample), y=Nuclei, fill=factor(Sample,levels =rev(Sample) ))) +\n  geom_bar(stat=\"identity\",position = \"stack\")+\n  geom_text(aes(label = Label), hjust=0,position = position_fill(vjust = 0), size = 3,colour=\"black\")+\n  coord_flip()+\n  ylab(label = \"Nuclei (mean genes/nuclei)\")+\n  scale_fill_manual(values = color_clusters)+\n  theme_linedraw()+\n  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.text = element_text(colour=\"black\")) +NoLegend()\n\n\n\n\n\n\n\n\n\n\n\nThe prevalence of border-associated macrophages within the HuMicA was tested by checking the expression of canonical microglia (P2RY12, CX3CR1) and macrophage markers (MRC1, CD163). Based on this, we annotated cluster 7 as macrophages.\n\nDefaultAssay(Humica)&lt;-\"RNA\"\nHumica &lt;- NormalizeData(Humica) #gene expression is evaluated using the normalized \"RNA\" assay\n\n# Dotplot\nDotPlot(Humica, features = c(\"P2RY12\",\"CX3CR1\", \"MRC1\",\"CD163\"), dot.scale = 10, group.by =\"integrated_snn_res.0.2\") +\n  scale_colour_gradient2(low = \"darkblue\", mid = \"white\", high = \"darkred\")+\n  #scale_color_viridis_c() +\n  theme(axis.text.x = element_text(angle=90, hjust = 0))+coord_flip()\n\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n\n\n\n\n\n\n\n\n# Feature plot of the Module Score of macrophage markers\nMac_genes &lt;- c(\"MRC1\",\"CD163\")\nHumica &lt;- AddModuleScore(Humica,\n                         features =list(Mac_genes),\n                         name='Mac_genes')\nFeaturePlot(Humica, features = 'Mac_genes1', label = F, repel = TRUE,pt.size = 0.5) & scale_colour_gradientn(colours = c(\"#FCFCFF\",\"#FCFCFF\",\"#DCF2CE\",\"#FFCB77\",\"#BD6B73\",\"#A30B37\"))\n\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n\n\n\n\n\n\n\n\n\n\n\n\nThe markers for each cluster were calculated using FindAllMarkers with the MAST test, min.pct=0.25 and logfc.theshold=0.25. Significant markers were considered for an adj p value (FDR) &lt; 0.05.\n\nHumica.markers &lt;- FindAllMarkers(Humica,assay = \"RNA\", only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25, test.use = \"MAST\") \nsig_markers &lt;- Humica.markers[Humica.markers$p_val_adj&lt;0.05,]\n\n\n\nThe heatmap represents the average gene expression per cluster, which consists of the average expression of all cells/nuclei annotated to each cluster. The heatmap.2 function from gplots is initially used to obtain the z-scores. Then the matrix with the z-scores is represented by the Heatmap function of ComplexHeatmap. In addition, the matching between the genes in the heatmap and microglia-related gene signatures collected from the literature is represented on the left panel. Each black lines represents the presence of one of the markers within each geneset/signature. The “Genesets_literature.xlsx” file has bee added to this repository (“Support data”).\n\nHumica@active.ident &lt;- factor(x = Humica@active.ident, levels = c(\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\"))\nav.exp_cluster &lt;- AverageExpression(Humica)$RNA %&gt;% data.frame()\n\ngenes &lt;- sig_markers$gene\n  \nmat &lt;- as.matrix(av.exp_cluster[genes,])\n\nheatmap &lt;- heatmap.2(mat,Colv = F, Rowv = F, scale=\"row\")\n\n\n\n\n\n\n\nmat_scale &lt;- t(heatmap$carpet)\n\ncol_fun = colorRamp2(c(-4,-2,0,2, 4), c(\"#071E22\",\"#15616D\", \"white\",\"#AA5042\",\"#78290F\"))\n\n\ngenesets$genesets &lt;- paste0(genesets$Population, \"_\",genesets$Study)\ndata &lt;- genes %&gt;% as.data.frame(); colnames(data) &lt;- \"Gene\"\n\ngeneset_list &lt;- c(\"Human_microglia_signature_Gosselin\",\"Microglia_signature_Galatro\",\"up_aging_Galatro\",\n                  \"down_DAM_Keren_shaul_Thrupp\",\"up_DAM_Keren_shaul_Thrupp\",\n                  \"Human_Adult_DAMs_Silvin\", \"Human_Adult_YAMs_Silvin\",\"Human_Adult_DIMs_Silvin\", \n                  \"Mic0_Mathys\",\"Mic1_Mathys\",\"Mic2_Mathys\",\"Mic3_Mathys\",\n                  \"MG1_Olah\",\"MG2_Olah\",\"MG3_Olah\",\"MG4_Olah\",\"MG5_Olah\",\"MG6_Olah\",\"MG7_Olah\",\"MG8_Olah\",\"MG9_Olah\",\n                  \"Micro0_Zhou\",\"Micro1_Zhou\",\n                  \"a_Schirmer\",\"b_Schirmer\",\"c_Schirmer\",\"d_Schirmer\",\"e_Schirmer\",\"f_Schirmer\",\n                  \"0_Gerritis\",\"1_Gerritis\",\"2_Gerritis\",\"3_Gerritis\",\"4_Gerritis\",\"5_Gerritis\",\"6_Gerritis\",\"7_Gerritis\",\"8_Gerritis\",\"9_Gerritis\",\n                  \"10_Gerritis\",\"11_Gerritis\",\"12_Gerritis\",\n                  \"MG0_Sun\",\"MG1_Sun\",\"MG2_Sun\",\"MG3_Sun\",\"MG4_Sun\",\"MG5_Sun\",\"MG6_Sun\",\"MG7_Sun\",\"MG8_Sun\",\"MG10_Sun\",\"MG11_Sun\",\"MG12_Sun\")\n\nhits &lt;- data.frame(Gene=data$Gene)\nfor (i in 1:length(geneset_list)) {\n  \ndf &lt;- data %&gt;% mutate(hit=ifelse(data$Gene %in% genesets[genesets$genesets==geneset_list[i],]$Gene, y=\"1\",no = \"0\"))\ndf&lt;-df[,2] %&gt;% as.data.frame()\ncolnames(df)&lt;- geneset_list[i]\n\nhits&lt;- cbind(hits, df) \n}\n  \n  \n\nrow_ha &lt;- rowAnnotation(Gosselin = hits$Human_microglia_signature_Gosselin, \n                        Galatro = hits$Microglia_signature_Galatro, \n                        aging_Galatro = hits$up_aging_Galatro,\n                        down_DAM = hits$down_DAM_Keren_shaul_Thrupp,\n                        up_DAM = hits$up_DAM_Keren_shaul_Thrupp,\n                        DAMs_Silvin=hits$Human_Adult_DAMs_Silvin,\n                        YAMs_Silvin=hits$Human_Adult_YAMs_Silvin,\n                        DIMs_Silvin=hits$Human_Adult_DIMs_Silvin,\n                        Mic0_Mathys=hits$Mic0_Mathys,\n                        Mic1_Mathys=hits$Mic1_Mathys,\n                        Mic2_Mathys=hits$Mic2_Mathys,\n                        Mic3_Mathys=hits$Mic3_Mathys,\n                        MG1_Olah=hits$MG1_Olah,\n                        MG2_Olah=hits$MG2_Olah,\n                        MG3_Olah=hits$MG3_Olah,\n                        MG4_Olah=hits$MG4_Olah,\n                        MG5_Olah=hits$MG5_Olah,\n                        MG6_Olah=hits$MG6_Olah,\n                        MG7_Olah=hits$MG7_Olah,\n                        MG8_Olah=hits$MG8_Olah,\n                        MG9_Olah=hits$MG9_Olah,\n                        Micro0_Zhou=hits$Micro0_Zhou,\n                        Micro1_Zhou=hits$Micro1_Zhou,\n                        a_Schirmer=hits$a_Schirmer,\n                        b_Schirmer=hits$b_Schirmer,\n                        c_Schirmer=hits$c_Schirmer,\n                        d_Schirmer=hits$d_Schirmer,\n                        e_Schirmer=hits$e_Schirmer,\n                        f_Schirmer=hits$f_Schirmer,\n                        Gerritis_0=hits$`0_Gerritis`,\n                        Gerritis_1=hits$`1_Gerritis`,\n                        Gerritis_2=hits$`2_Gerritis`,\n                        Gerritis_3=hits$`3_Gerritis`,\n                        Gerritis_4=hits$`4_Gerritis`,\n                        Gerritis_5=hits$`5_Gerritis`,\n                        Gerritis_6=hits$`6_Gerritis`,\n                        Gerritis_7=hits$`7_Gerritis`,\n                        Gerritis_8=hits$`8_Gerritis`,\n                        Gerritis_9=hits$`9_Gerritis`,\n                        Gerritis_10=hits$`10_Gerritis`,\n                        Gerritis_11=hits$`11_Gerritis`,\n                        Gerritis_12=hits$`12_Gerritis`,\n                        MG0_Sun=hits$MG0_Sun,\n                        MG1_Sun=hits$MG1_Sun,\n                        MG2_Sun=hits$MG2_Sun,\n                        MG3_Sun=hits$MG3_Sun,\n                        MG4_Sun=hits$MG4_Sun,\n                        MG5_Sun=hits$MG5_Sun,\n                        MG6_Sun=hits$MG6_Sun,\n                        MG7_Sun=hits$MG7_Sun,\n                        MG8_Sun=hits$MG8_Sun,\n                        MG10_Sun=hits$MG10_Sun,\n                        MG11_Sun=hits$MG11_Sun,\n                        MG12_Sun=hits$MG12_Sun,\n          \n                        \n                                  col = list(Gosselin = c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Galatro = c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   aging_Galatro = c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   down_DAM=c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   up_DAM=c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   DAMs_Silvin=c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   YAMs_Silvin=c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   DIMs_Silvin=c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Mic0_Mathys =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Mic1_Mathys =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Mic2_Mathys =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Mic3_Mathys =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG1_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG2_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG3_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG4_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG5_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG6_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG7_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG8_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG9_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Micro0_Zhou =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Micro1_Zhou =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   a_Schirmer =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   b_Schirmer =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   c_Schirmer =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   d_Schirmer =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   e_Schirmer =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   f_Schirmer =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_0 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_1 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_2 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_3 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_4 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_5 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_6 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_7 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_8 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_9 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_10 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_11 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_12 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG0_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG1_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG2_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG3_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG4_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG5_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG6_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG7_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG8_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG10_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG11_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG12_Sun =c(\"1\" =\"black\", \"0\"=\"white\")\n                        ))\n\nHeatmap(mat_scale,row_order = hits$Gene,cluster_rows = F, cluster_columns = F, col = col_fun,border = T,show_row_names = F,right_annotation =  row_ha,\n        row_names_gp = grid::gpar(fontsize = 3))\n\n\n\n\n\n\n\n\n\n\n\n\nGSEA was calculated using the fgsea package. The results from FindAllMarkers with a less significant cutoff were used as cutoff. This intends to account for the broad spectrum of differential expression and not only the significant differentially expressed markers (only.pos = F, min.pct = 0.1, logfc.threshold = 0.0, test.use = “MAST”). Of note, both up and downregulated markers were considered. The avg_log2FC and the p_val_adj were used for ranking.\n\nHumica.markers &lt;- FindAllMarkers(Humica,assay = \"RNA\", only.pos = F, min.pct = 0.1, logfc.threshold = 0.0, test.use = \"MAST\") \n\n\ngenesets &lt;- split(x=genesets$Gene, f=genesets$genesets)\n\nclusterlist &lt;- c(\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\")\np &lt;- list()\nresults &lt;- data.frame()\nfor (i in 1:length(clusterlist)) {\n  print(clusterlist[i])\n  genes &lt;- Humica.markers[Humica.markers$cluster==clusterlist[i],]\n  genes&lt;- structure(genes$avg_log2FC, names=genes$gene)\n  genes &lt;- fgsea(pathways =genesets, \n                 stats    = genes,\n                 scoreType =\"pos\",\n                 minSize  = 0,\n                 maxSize = Inf)\n  genes &lt;- as.data.frame(apply(genes, 2, as.character))\n  genes&lt;- as.data.frame(genes) %&gt;% mutate(cluster = clusterlist[i])\n  \n  results &lt;- rbind(results,genes)\n}\n\n\n\nThe normalized enrichmant score (NES) and the negative of the logarithm of the p value were used as significance metrics.\n\nresults$padj&lt;- as.numeric(results$padj)\nresults$LOG &lt;- -log10(results$padj)\nresults$NES &lt;- as.numeric(results$NES)\n\nrow_order &lt;- c(\"Human_microglia_signature_Gosselin\",\"Microglia_signature_Galatro\",\"up_aging_Galatro\",\n               \"down_DAM_Keren_shaul_Thrupp\",\"up_DAM_Keren_shaul_Thrupp\",\n               \"Human_Adult_DAMs_Silvin\", \"Human_Adult_YAMs_Silvin\",\"Human_Adult_DIMs_Silvin\", \n               \"Mic0_Mathys\",\"Mic1_Mathys\",\"Mic2_Mathys\",\"Mic3_Mathys\",\n               \"MG1_Olah\",\"MG2_Olah\",\"MG3_Olah\",\"MG4_Olah\",\"MG5_Olah\",\"MG6_Olah\",\"MG7_Olah\",\"MG8_Olah\",\"MG9_Olah\",\n               \"Micro0_Zhou\",\"Micro1_Zhou\",\n               \"a_Schirmer\",\"b_Schirmer\",\"c_Schirmer\",\"d_Schirmer\",\"e_Schirmer\",\"f_Schirmer\",\n               \"0_Gerritis\",\"1_Gerritis\",\"2_Gerritis\",\"3_Gerritis\",\"4_Gerritis\",\"5_Gerritis\",\"6_Gerritis\",\"7_Gerritis\",\"8_Gerritis\",\"9_Gerritis\",\n               \"10_Gerritis\",\"11_Gerritis\",\"12_Gerritis\",\n               \"MG0_Sun\",\"MG1_Sun\",\"MG2_Sun\",\"MG3_Sun\",\"MG4_Sun\",\"MG5_Sun\",\"MG6_Sun\",\"MG7_Sun\",\"MG8_Sun\",\"MG10_Sun\",\"MG11_Sun\",\"MG12_Sun\")\n\nggplot(results, aes(factor(pathway, levels=row_order), factor(cluster, \n                                                              levels = c(\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\",\"0\")),\n                                                              colour = LOG)) +\n  geom_point(aes(size = NES)) +\n  theme_pubr() + \n  scale_size_continuous(range = c(1, 8))+\n  scale_color_gradient(low = \"white\",high = \"darkred\")+\n  scale_shape_manual(values = c(significant = 16, \"non-significant\" = NA)) +\n    border() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1),panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.text = element_text(colour=\"black\"),\n      axis.title.y = element_blank())"
  },
  {
    "objectID": "06. Characterization of the HuMicA.html#characterization-of-the-humica-integrated-object",
    "href": "06. Characterization of the HuMicA.html#characterization-of-the-humica-integrated-object",
    "title": "Characterization of the HuMicA",
    "section": "",
    "text": "The following script depicts the identification and characterization of the nine populations within the HuMicA, and relates to the results represented in Figure 1 of the paper.\n\n\n\nlibs &lt;- c(\"Seurat\", \"tidyverse\", \"gplots\", \"ComplexHeatmap\",\"circlize\",\"readxl\", \"fgsea\",\"ggpubr\")\nsuppressMessages(\nsuppressWarnings(sapply(libs, require, character.only =TRUE))\n)\n\n        Seurat      tidyverse         gplots ComplexHeatmap       circlize \n          TRUE           TRUE           TRUE           TRUE           TRUE \n        readxl          fgsea         ggpubr \n          TRUE           TRUE           TRUE \n\n\n\n\n\n\ncolor_clusters &lt;-c(\"#fdc835ff\", \"#FC8D62\", \"#7570B3\" ,\"#679436\", \"#D43921\" ,\"#344D67\", \"#874C62\" ,\"#937666\", \"#5B7B7A\" )\nDefaultAssay(Humica)&lt;-\"integrated\"\nDimPlot(Humica, reduction = \"umap\", order = rev(levels(Idents(Humica))),\n        cols = color_clusters, \n        group.by = \"integrated_snn_res.0.2\", raster = FALSE,pt.size =0.001)\n\n\n\n\n\n\n\n\n\n\n\nThe number of cells/nucleis and the mean number of genes per cell/nucleus were calculated for each cluster and represented in a barplot.\n\ncluster0&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"0\"]\ncluster1&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"1\"]\ncluster2&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"2\"]\ncluster3&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"3\"]\ncluster4&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"4\"]\ncluster5&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"5\"]\ncluster6&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"6\"]\ncluster7&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"7\"]\ncluster8&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"8\"]\n\n#\nmain.list &lt;- list(cluster0, cluster1, cluster2,cluster3, cluster4, cluster5,\n                  cluster6, cluster7, cluster8)\n\nmy.files &lt;-c(\"cluster0\", \"cluster1\", \"cluster2\",\"cluster3\", \"cluster4\", \"cluster5\",\n             \"cluster6\", \"cluster7\",\"cluster8\")\n\ndf &lt;- data.frame(Sample=my.files, Nuclei=\"\", Genes=\"\")\nnumber_nuclei= numeric(length(my.files))\nnumber_genes = numeric(length(my.files))\n\nfor (i in 1:length(main.list)) {\n  \n  number_nuclei[i]&lt;- nrow(main.list[[i]]@meta.data)\n  number_genes[i] &lt;- mean(main.list[[i]]@meta.data$nFeature_RNA)\n}\n\ndf$Nuclei = number_nuclei\ndf$Genes = number_genes\ndf$Genes = format(round(df$Genes, 0))\n\ndf$Label &lt;- paste0(df$Nuclei,\"(\",df$Genes,\")\")\ndf &lt;- df[order(df$Nuclei),]\ndf\n\n    Sample Nuclei Genes       Label\n9 cluster8   1563  1305  1563(1305)\n8 cluster7   2425  1281  2425(1281)\n7 cluster6   2616  1468  2616(1468)\n6 cluster5   3195  1303  3195(1303)\n5 cluster4   8559  1344  8559(1344)\n4 cluster3   8635  1069  8635(1069)\n3 cluster2  16186  1371 16186(1371)\n2 cluster1  21974  1281 21974(1281)\n1 cluster0  25563  1281 25563(1281)\n\nggplot(df, aes(x= factor(df$Sample, levels = df$Sample), y=Nuclei, fill=factor(Sample,levels =rev(Sample) ))) +\n  geom_bar(stat=\"identity\",position = \"stack\")+\n  geom_text(aes(label = Label), hjust=0,position = position_fill(vjust = 0), size = 3,colour=\"black\")+\n  coord_flip()+\n  ylab(label = \"Nuclei (mean genes/nuclei)\")+\n  scale_fill_manual(values = color_clusters)+\n  theme_linedraw()+\n  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.text = element_text(colour=\"black\")) +NoLegend()\n\n\n\n\n\n\n\n\n\n\n\nThe prevalence of border-associated macrophages within the HuMicA was tested by checking the expression of canonical microglia (P2RY12, CX3CR1) and macrophage markers (MRC1, CD163). Based on this, we annotated cluster 7 as macrophages.\n\nDefaultAssay(Humica)&lt;-\"RNA\"\nHumica &lt;- NormalizeData(Humica) #gene expression is evaluated using the normalized \"RNA\" assay\n\n# Dotplot\nDotPlot(Humica, features = c(\"P2RY12\",\"CX3CR1\", \"MRC1\",\"CD163\"), dot.scale = 10, group.by =\"integrated_snn_res.0.2\") +\n  scale_colour_gradient2(low = \"darkblue\", mid = \"white\", high = \"darkred\")+\n  #scale_color_viridis_c() +\n  theme(axis.text.x = element_text(angle=90, hjust = 0))+coord_flip()\n\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n\n\n\n\n\n\n\n\n# Feature plot of the Module Score of macrophage markers\nMac_genes &lt;- c(\"MRC1\",\"CD163\")\nHumica &lt;- AddModuleScore(Humica,\n                         features =list(Mac_genes),\n                         name='Mac_genes')\nFeaturePlot(Humica, features = 'Mac_genes1', label = F, repel = TRUE,pt.size = 0.5) & scale_colour_gradientn(colours = c(\"#FCFCFF\",\"#FCFCFF\",\"#DCF2CE\",\"#FFCB77\",\"#BD6B73\",\"#A30B37\"))\n\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n\n\n\n\n\n\n\n\n\n\n\n\nThe markers for each cluster were calculated using FindAllMarkers with the MAST test, min.pct=0.25 and logfc.theshold=0.25. Significant markers were considered for an adj p value (FDR) &lt; 0.05.\n\nHumica.markers &lt;- FindAllMarkers(Humica,assay = \"RNA\", only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25, test.use = \"MAST\") \nsig_markers &lt;- Humica.markers[Humica.markers$p_val_adj&lt;0.05,]\n\n\n\nThe heatmap represents the average gene expression per cluster, which consists of the average expression of all cells/nuclei annotated to each cluster. The heatmap.2 function from gplots is initially used to obtain the z-scores. Then the matrix with the z-scores is represented by the Heatmap function of ComplexHeatmap. In addition, the matching between the genes in the heatmap and microglia-related gene signatures collected from the literature is represented on the left panel. Each black lines represents the presence of one of the markers within each geneset/signature. The “Genesets_literature.xlsx” file has bee added to this repository (“Support data”).\n\nHumica@active.ident &lt;- factor(x = Humica@active.ident, levels = c(\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\"))\nav.exp_cluster &lt;- AverageExpression(Humica)$RNA %&gt;% data.frame()\n\ngenes &lt;- sig_markers$gene\n  \nmat &lt;- as.matrix(av.exp_cluster[genes,])\n\nheatmap &lt;- heatmap.2(mat,Colv = F, Rowv = F, scale=\"row\")\n\n\n\n\n\n\n\nmat_scale &lt;- t(heatmap$carpet)\n\ncol_fun = colorRamp2(c(-4,-2,0,2, 4), c(\"#071E22\",\"#15616D\", \"white\",\"#AA5042\",\"#78290F\"))\n\n\ngenesets$genesets &lt;- paste0(genesets$Population, \"_\",genesets$Study)\ndata &lt;- genes %&gt;% as.data.frame(); colnames(data) &lt;- \"Gene\"\n\ngeneset_list &lt;- c(\"Human_microglia_signature_Gosselin\",\"Microglia_signature_Galatro\",\"up_aging_Galatro\",\n                  \"down_DAM_Keren_shaul_Thrupp\",\"up_DAM_Keren_shaul_Thrupp\",\n                  \"Human_Adult_DAMs_Silvin\", \"Human_Adult_YAMs_Silvin\",\"Human_Adult_DIMs_Silvin\", \n                  \"Mic0_Mathys\",\"Mic1_Mathys\",\"Mic2_Mathys\",\"Mic3_Mathys\",\n                  \"MG1_Olah\",\"MG2_Olah\",\"MG3_Olah\",\"MG4_Olah\",\"MG5_Olah\",\"MG6_Olah\",\"MG7_Olah\",\"MG8_Olah\",\"MG9_Olah\",\n                  \"Micro0_Zhou\",\"Micro1_Zhou\",\n                  \"a_Schirmer\",\"b_Schirmer\",\"c_Schirmer\",\"d_Schirmer\",\"e_Schirmer\",\"f_Schirmer\",\n                  \"0_Gerritis\",\"1_Gerritis\",\"2_Gerritis\",\"3_Gerritis\",\"4_Gerritis\",\"5_Gerritis\",\"6_Gerritis\",\"7_Gerritis\",\"8_Gerritis\",\"9_Gerritis\",\n                  \"10_Gerritis\",\"11_Gerritis\",\"12_Gerritis\",\n                  \"MG0_Sun\",\"MG1_Sun\",\"MG2_Sun\",\"MG3_Sun\",\"MG4_Sun\",\"MG5_Sun\",\"MG6_Sun\",\"MG7_Sun\",\"MG8_Sun\",\"MG10_Sun\",\"MG11_Sun\",\"MG12_Sun\")\n\nhits &lt;- data.frame(Gene=data$Gene)\nfor (i in 1:length(geneset_list)) {\n  \ndf &lt;- data %&gt;% mutate(hit=ifelse(data$Gene %in% genesets[genesets$genesets==geneset_list[i],]$Gene, y=\"1\",no = \"0\"))\ndf&lt;-df[,2] %&gt;% as.data.frame()\ncolnames(df)&lt;- geneset_list[i]\n\nhits&lt;- cbind(hits, df) \n}\n  \n  \n\nrow_ha &lt;- rowAnnotation(Gosselin = hits$Human_microglia_signature_Gosselin, \n                        Galatro = hits$Microglia_signature_Galatro, \n                        aging_Galatro = hits$up_aging_Galatro,\n                        down_DAM = hits$down_DAM_Keren_shaul_Thrupp,\n                        up_DAM = hits$up_DAM_Keren_shaul_Thrupp,\n                        DAMs_Silvin=hits$Human_Adult_DAMs_Silvin,\n                        YAMs_Silvin=hits$Human_Adult_YAMs_Silvin,\n                        DIMs_Silvin=hits$Human_Adult_DIMs_Silvin,\n                        Mic0_Mathys=hits$Mic0_Mathys,\n                        Mic1_Mathys=hits$Mic1_Mathys,\n                        Mic2_Mathys=hits$Mic2_Mathys,\n                        Mic3_Mathys=hits$Mic3_Mathys,\n                        MG1_Olah=hits$MG1_Olah,\n                        MG2_Olah=hits$MG2_Olah,\n                        MG3_Olah=hits$MG3_Olah,\n                        MG4_Olah=hits$MG4_Olah,\n                        MG5_Olah=hits$MG5_Olah,\n                        MG6_Olah=hits$MG6_Olah,\n                        MG7_Olah=hits$MG7_Olah,\n                        MG8_Olah=hits$MG8_Olah,\n                        MG9_Olah=hits$MG9_Olah,\n                        Micro0_Zhou=hits$Micro0_Zhou,\n                        Micro1_Zhou=hits$Micro1_Zhou,\n                        a_Schirmer=hits$a_Schirmer,\n                        b_Schirmer=hits$b_Schirmer,\n                        c_Schirmer=hits$c_Schirmer,\n                        d_Schirmer=hits$d_Schirmer,\n                        e_Schirmer=hits$e_Schirmer,\n                        f_Schirmer=hits$f_Schirmer,\n                        Gerritis_0=hits$`0_Gerritis`,\n                        Gerritis_1=hits$`1_Gerritis`,\n                        Gerritis_2=hits$`2_Gerritis`,\n                        Gerritis_3=hits$`3_Gerritis`,\n                        Gerritis_4=hits$`4_Gerritis`,\n                        Gerritis_5=hits$`5_Gerritis`,\n                        Gerritis_6=hits$`6_Gerritis`,\n                        Gerritis_7=hits$`7_Gerritis`,\n                        Gerritis_8=hits$`8_Gerritis`,\n                        Gerritis_9=hits$`9_Gerritis`,\n                        Gerritis_10=hits$`10_Gerritis`,\n                        Gerritis_11=hits$`11_Gerritis`,\n                        Gerritis_12=hits$`12_Gerritis`,\n                        MG0_Sun=hits$MG0_Sun,\n                        MG1_Sun=hits$MG1_Sun,\n                        MG2_Sun=hits$MG2_Sun,\n                        MG3_Sun=hits$MG3_Sun,\n                        MG4_Sun=hits$MG4_Sun,\n                        MG5_Sun=hits$MG5_Sun,\n                        MG6_Sun=hits$MG6_Sun,\n                        MG7_Sun=hits$MG7_Sun,\n                        MG8_Sun=hits$MG8_Sun,\n                        MG10_Sun=hits$MG10_Sun,\n                        MG11_Sun=hits$MG11_Sun,\n                        MG12_Sun=hits$MG12_Sun,\n          \n                        \n                                  col = list(Gosselin = c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Galatro = c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   aging_Galatro = c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   down_DAM=c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   up_DAM=c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   DAMs_Silvin=c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   YAMs_Silvin=c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   DIMs_Silvin=c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Mic0_Mathys =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Mic1_Mathys =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Mic2_Mathys =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Mic3_Mathys =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG1_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG2_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG3_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG4_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG5_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG6_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG7_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG8_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG9_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Micro0_Zhou =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Micro1_Zhou =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   a_Schirmer =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   b_Schirmer =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   c_Schirmer =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   d_Schirmer =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   e_Schirmer =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   f_Schirmer =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_0 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_1 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_2 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_3 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_4 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_5 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_6 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_7 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_8 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_9 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_10 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_11 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_12 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG0_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG1_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG2_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG3_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG4_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG5_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG6_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG7_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG8_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG10_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG11_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG12_Sun =c(\"1\" =\"black\", \"0\"=\"white\")\n                        ))\n\nHeatmap(mat_scale,row_order = hits$Gene,cluster_rows = F, cluster_columns = F, col = col_fun,border = T,show_row_names = F,right_annotation =  row_ha,\n        row_names_gp = grid::gpar(fontsize = 3))\n\n\n\n\n\n\n\n\n\n\n\n\nGSEA was calculated using the fgsea package. The results from FindAllMarkers with a less significant cutoff were used as cutoff. This intends to account for the broad spectrum of differential expression and not only the significant differentially expressed markers (only.pos = F, min.pct = 0.1, logfc.threshold = 0.0, test.use = “MAST”). Of note, both up and downregulated markers were considered. The avg_log2FC and the p_val_adj were used for ranking.\n\nHumica.markers &lt;- FindAllMarkers(Humica,assay = \"RNA\", only.pos = F, min.pct = 0.1, logfc.threshold = 0.0, test.use = \"MAST\") \n\n\ngenesets &lt;- split(x=genesets$Gene, f=genesets$genesets)\n\nclusterlist &lt;- c(\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\")\np &lt;- list()\nresults &lt;- data.frame()\nfor (i in 1:length(clusterlist)) {\n  print(clusterlist[i])\n  genes &lt;- Humica.markers[Humica.markers$cluster==clusterlist[i],]\n  genes&lt;- structure(genes$avg_log2FC, names=genes$gene)\n  genes &lt;- fgsea(pathways =genesets, \n                 stats    = genes,\n                 scoreType =\"pos\",\n                 minSize  = 0,\n                 maxSize = Inf)\n  genes &lt;- as.data.frame(apply(genes, 2, as.character))\n  genes&lt;- as.data.frame(genes) %&gt;% mutate(cluster = clusterlist[i])\n  \n  results &lt;- rbind(results,genes)\n}\n\n\n\nThe normalized enrichmant score (NES) and the negative of the logarithm of the p value were used as significance metrics.\n\nresults$padj&lt;- as.numeric(results$padj)\nresults$LOG &lt;- -log10(results$padj)\nresults$NES &lt;- as.numeric(results$NES)\n\nrow_order &lt;- c(\"Human_microglia_signature_Gosselin\",\"Microglia_signature_Galatro\",\"up_aging_Galatro\",\n               \"down_DAM_Keren_shaul_Thrupp\",\"up_DAM_Keren_shaul_Thrupp\",\n               \"Human_Adult_DAMs_Silvin\", \"Human_Adult_YAMs_Silvin\",\"Human_Adult_DIMs_Silvin\", \n               \"Mic0_Mathys\",\"Mic1_Mathys\",\"Mic2_Mathys\",\"Mic3_Mathys\",\n               \"MG1_Olah\",\"MG2_Olah\",\"MG3_Olah\",\"MG4_Olah\",\"MG5_Olah\",\"MG6_Olah\",\"MG7_Olah\",\"MG8_Olah\",\"MG9_Olah\",\n               \"Micro0_Zhou\",\"Micro1_Zhou\",\n               \"a_Schirmer\",\"b_Schirmer\",\"c_Schirmer\",\"d_Schirmer\",\"e_Schirmer\",\"f_Schirmer\",\n               \"0_Gerritis\",\"1_Gerritis\",\"2_Gerritis\",\"3_Gerritis\",\"4_Gerritis\",\"5_Gerritis\",\"6_Gerritis\",\"7_Gerritis\",\"8_Gerritis\",\"9_Gerritis\",\n               \"10_Gerritis\",\"11_Gerritis\",\"12_Gerritis\",\n               \"MG0_Sun\",\"MG1_Sun\",\"MG2_Sun\",\"MG3_Sun\",\"MG4_Sun\",\"MG5_Sun\",\"MG6_Sun\",\"MG7_Sun\",\"MG8_Sun\",\"MG10_Sun\",\"MG11_Sun\",\"MG12_Sun\")\n\nggplot(results, aes(factor(pathway, levels=row_order), factor(cluster, \n                                                              levels = c(\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\",\"0\")),\n                                                              colour = LOG)) +\n  geom_point(aes(size = NES)) +\n  theme_pubr() + \n  scale_size_continuous(range = c(1, 8))+\n  scale_color_gradient(low = \"white\",high = \"darkred\")+\n  scale_shape_manual(values = c(significant = 16, \"non-significant\" = NA)) +\n    border() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1),panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.text = element_text(colour=\"black\"),\n      axis.title.y = element_blank())"
  },
  {
    "objectID": "08. DAM-related clusters.html",
    "href": "08. DAM-related clusters.html",
    "title": "DAM-related clusters",
    "section": "",
    "text": "This script depicts the specific and in-depth characterization of the clusters related to the disease-associated microglia (DAM) signature, including gene markers, gene ontology, gene set enrichment anaysis, and transcription factor enrichment, related to Figure 3.\n\n\n\nlibs &lt;- c(\"Seurat\", \"tidyverse\", \"clusterProfiler\",\"viper\",\"dorothea\",\"org.Hs.eg.db\",\"ggrepel\",\"gridExtra\",\"ggpubr\",\"readxl\",\"msigdbr\",\"fgsea\",\"data.table\")\nsuppressMessages(\nsuppressWarnings(sapply(libs, require, character.only =TRUE))\n)\n\n         Seurat       tidyverse clusterProfiler           viper        dorothea \n           TRUE            TRUE            TRUE            TRUE            TRUE \n   org.Hs.eg.db         ggrepel       gridExtra          ggpubr          readxl \n           TRUE            TRUE            TRUE            TRUE            TRUE \n        msigdbr           fgsea      data.table \n           TRUE            TRUE            TRUE \n\n\n\n\n\nBased on the Module Score expression of the original DAM signature from Keren-Shaul et al (2017) and the more recent DAM, DIM (disease-inflammatory macrophage) and YAM (youth-associated microglia) from Silvin et al (2022), we determined clusters 1, 2, 3, 5 and 6 as DAM-related. In addition to the mentioned Module Scores, we represented the expression of the top 10 significant markers for each cluster. The used sigantures are included at the “Genesets_literature” file in this repository (“Support data”).\n\n\n\n# define gene signatures\ngenesets$genesets &lt;- paste0(genesets$Population, \"_\",genesets$Study)\n\nAll_DAM &lt;- genesets$Gene[genesets$genesets==\"up_DAM_Keren_shaul_Thrupp\"]\nHuman_DAM_signature &lt;- genesets$Gene[genesets$genesets==\"Human_Adult_DAMs_Silvin\"]\nHuman_DIM_signature &lt;- genesets$Gene[genesets$genesets==\"Human_Adult_DIMs_Silvin\"]\nHuman_YAM_signature &lt;- genesets$Gene[genesets$genesets==\"Human_Adult_YAMs_Silvin\"]\n\n# Add Module Scores\nHumica &lt;- SetIdent(Humica, value = Humica@meta.data$integrated_snn_res.0.2)\nDefaultAssay(Humica)&lt;-\"RNA\"\nHumica &lt;- NormalizeData(Humica)\n\nHumica &lt;- AddModuleScore(Humica,\n                         features =list(All_DAM),\n                         name='DAM.ALL')\n\nHumica &lt;- AddModuleScore(Humica,\n                         features =list(Human_DAM_signature),\n                         name='Human_DAM_Silvin')\n\nHumica &lt;- AddModuleScore(Humica,\n                         features =list(Human_YAM_signature),\n                         name='Human_YAM_Silvin')\n\nHumica &lt;- AddModuleScore(Humica,\n                         features =list(Human_DIM_signature),\n                         name='Human_DIM_Silvin')\n\n# define top 10 markers per DAM-related cluster\nDAM_markers &lt;- sig_markers[sig_markers$cluster %in% c(\"1\",\"2\",\"3\",\"5\",\"6\"),]\nDAM_markers$avg_log2FC&lt;- as.numeric(DAM_markers$avg_log2FC)\n\nDAM_markers %&gt;%\n  group_by(cluster) %&gt;% arrange(-avg_log2FC) %&gt;% arrange(cluster) %&gt;% \n  top_n(n = 10, wt = avg_log2FC)-&gt; top10_up \n\n# DotPlot\nfeatures &lt;- c(\"DAM.ALL1\",\"Human_DAM_Silvin1\",\"Human_YAM_Silvin1\",\"Human_DIM_Silvin1\",top10_up$gene %&gt;% unique)\n\nDotPlot(Humica, features =factor(features, levels = features), \n        dot.scale = 10) +\n  scale_colour_gradient2(low = \"darkblue\", mid = \"white\", high = \"darkred\")+\n  #scale_color_virgeneis_c() +\n  theme(axis.text.x = element_text(angle=90, hjust = 0))\n\n\n\n\n\n\n\n\n\n\n\n\nThe representation of the HuMicA object was edited to depict only the five populations enriched for the DAM signature, namely clusters 1 (Inflam.DAM), 2 (DIMs), 3 (Ribo.DAM1), 5 (Ribo.DAM2) and 6 (Lipo.DAM). Of note, cluster 7 (Border-Associated Macrophages) ara also represented, to support the potential macrophagic nature of the DIMs, based on the proximity of both populations in the UMAP. This annotation was based on the previous enrichment presented in Figure 1F, the above DotPlot and the enrichment analysis that will be presented bellow.\n\ncolor_clusters &lt;-c(\"white\", \"#FC8D62\", \"#7570B3\" ,\"#679436\", \"white\" ,\"#344D67\", \"#874C62\" ,\"#937666\", \"white\")\nDimPlot(Humica, reduction = \"umap\",cols = color_clusters, repel = TRUE, pt.size = 0.01, label = F)+NoLegend()\n\n\n\n\n\n\n\n\n\n\nThe most prominent markers of each cluster were represented separately in Feature plots: TMEM163 for Inflam.DAM; SLC2A3 for DIMs; SYT1 for Ribo.DAM1; PLEKHA7 for Ribo.DAM2; and GPNMB for Lipo.DAM (related to Supplementary Figure 7A).\n\nHumica &lt;- SetIdent(Humica, value = Humica@meta.data$integrated_snn_res.0.2)\nDefaultAssay(Humica)&lt;-\"RNA\"\nHumica &lt;- NormalizeData(Humica)\n\nFeaturePlot(Humica, features = c(\"TMEM163\",\"SLC2A3\",\"SYT1\",\"PLEKHA7\",\"GPNMB\"), ncol=5,label = F, repel = TRUE,pt.size = 0.5) & scale_colour_gradientn(colours = c(\"#FCFCFF\",\"#FCFCFF\",\"#DCF2CE\",\"#FFCB77\",\"#BD6B73\",\"#A30B37\"))\n\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n\n\n\n\n\n\n\n\n\n\n\n\n\nGene ontology (GO) was calculated with the enrichGO function from clusterProfiler.\n\n\nThe top 10 significant GO terms for each of the homeostatic clusters were represented in barplots to provide a broader insight on the GO enrichment (related to Supplementary Figure 7B). GO was recalculated and edited to obtain the Fold Change of enrichment.\n\ni = 0\nresults &lt;- list()\ngo_all_simplify &lt;- data.frame()\nfor(comparison in levels(factor(DAM_markers$cluster))){\n  i = i+1\n  print(paste(comparison))\n  ego &lt;- enrichGO(gene              = DAM_markers[DAM_markers$cluster == comparison,]$gene,\n                  OrgDb             = org.Hs.eg.db,\n                  ont               = \"ALL\",\n                  keyType           = \"SYMBOL\",\n                  pAdjustMethod     = \"BH\",\n                  pvalueCutoff      = 1,\n                  qvalueCutoff      = 0.05,\n                  readable          = T )\n  ego &lt;- simplify(ego, cutoff=0.7, by=\"p.adjust\", select_fun=min)\n  \n  results[[comparison]] &lt;- ego@result %&gt;%\n    separate(GeneRatio, into = c(\"gene_pos\", \"gene_total\"), sep = \"/\") %&gt;%\n    separate(BgRatio, into = c(\"bg_pos\", \"bg_total\"), sep = \"/\") %&gt;%\n    mutate(FC = (as.numeric(gene_pos)/as.numeric(gene_total)) /\n             (as.numeric(bg_pos)/as.numeric(bg_total)),\n           cluster = comparison) %&gt;%\n    arrange(.$p.adjust)\n  go_all_simplify &lt;- rbind(go_all_simplify, results[[comparison]])\n}\n\n\nclusterlist &lt;- c(\"1\",\"2\",\"3\",\"5\",\"6\")\np&lt;-list()\nfor (i in 1:length(clusterlist)) {\n  data &lt;-go_all_simplify[go_all_simplify$cluster==clusterlist[i],]\n  data$logpadj &lt;- -log10(data$p.adjust)\n  data$logFC&lt;- log10(data$FC)\n  top10 &lt;- data %&gt;%top_n(n = 10, wt = logpadj)\n  top10 &lt;- top10[1:10,]\n  \n  \n  p[[i]]&lt;- ggplot(top10,\n                  aes(fill=logFC,\n                      x=factor(ID, level = rev(ID)),\n                      y=logpadj,\n                      color=\"black\")) +\n    geom_col(color=\"black\", size=0.2) +\n    geom_text(aes(label = Description), hjust=0,position = position_fill(vjust = 0), size = 4, color=\"black\")+\n    theme_bw() +\n    scale_fill_gradientn(colours = c(\"#B9CFD4\",\"#AFAAB9\",\"#B48291\",\"#8C5465\"))+\n    #scale_fill_viridis(option = \"plasma\")+\n    coord_flip()\n}\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\ndo.call(grid.arrange,p)\n\n\n\n\n\n\n\n\n\n\n\n\nGSEA analysis was performed using as reference all genesets from msigdbr for the “C2” category of “Homo sapiens”. The results from FindAllMarkers with a less significant cutoff were used as cutoff. This intends to account for the broad spectrum of differential expression and not only the significant differentially expressed markers (only.pos = F, min.pct = 0.1, logfc.threshold = 0.0, test.use = “MAST”). Of note, both up and downregulated markers were considered at “Humica.markers”. The avg_log2FC and the p_val_adj were used for ranking.\n\nall_gene_sets = msigdbr(species = \"Homo sapiens\",category = c(\"C2\"))\n\nmsigdbr_list = split(x = all_gene_sets$gene_symbol, f = all_gene_sets$gs_name)\n\nfgsea_ALL &lt;- data.frame()\nfor (i in 1:length(clusterlist)) {\ndata &lt;- Humica_markers[Humica_markers$cluster==clusterlist[i],]  \ndata2 &lt;- structure(data$avg_log2FC, names=data$gene)\ndf &lt;- fgsea(pathways =msigdbr_list, \n            stats    = data2,\n            scoreType =\"pos\",\n            minSize  = 1,\n            maxSize  = Inf)\n\n\ndf$cluster &lt;- clusterlist[i]\n\nfgsea_ALL &lt;- rbind(fgsea_ALL, df)\n}\n\n\n\nA list of terms of interested were selected from the results output. The results are presented as a function of the Normalized Enrichment Score (NES) and the negative of the log of the adjusted p value.\n\n## with - LOG adj p value\nfgsea_res$log &lt;- -log(fgsea_res$padj)\nfgsea_res &lt;- fgsea_res[order(fgsea_res$log),]\n\nfgsea_res$NES&lt;- fgsea_res$NES %&gt;% as.numeric()\n\nfgsea_res$pathway2 &lt;- paste0(fgsea_res$pathway,\"_\",fgsea_res$cluster)\n\nggplot(fgsea_res, aes(factor(pathway2, levels=pathway2), log, fill=NES))+\n  geom_bar(stat = \"identity\")+\n  geom_text(aes(label = pathway2),color=\"black\", hjust=0,position = position_fill(vjust = 0.2), size = 4)+\n  scale_fill_gradientn(colours = c(\"#F0FFCE\",\"#CCC9A1\",\"#CD543C\"))+\n  #scale_size_continuous(range = c(6, 14))+\n  coord_flip()+\n  facet_grid(cluster~., shrink = TRUE, scales = \"free\", space=\"free\")+\n  theme_bw()+\n  theme(axis.text.y  = element_blank())\n\n\n\n\n\n\n\n\n\n\n\n\nThe collection of transcription factors (TFs) and their target genes was obtained from the DoRothEA regulon A. The enrichment analysis was performed using the viper package. The regulon object downloaded from https://github.com/deeenes/DoRothEA/tree/master/data/TFregulons/Robjects_VIPERformat/consensus, already in the appropriate format to be used in the viper pipeline. The Humica.markers file correspond to the broad spectrum differential expression output, mentioned in the “Characterization of the HuMicA” script of this repository. The following represents the loop for the calculation of TF enrichment in all nine clusters.\n\nregulon_A&lt;- viper_regulon\nnames(regulon_A)=sapply(strsplit(names(regulon_A),split=\" - \"),head, 1)\n\nlist &lt;- unique(Humica_markers$cluster)\nTF_activities_all &lt;- data.frame()\n\nfor (i in 1:length(list)) {\n\ndata &lt;- Humica_markers[Humica_markers$cluster==list[i],]\n\n#Exclude probes with unknown or duplicated gene symbol\nDEsignature = subset(data, gene != \"\" )\n\nDEsignature = subset(DEsignature, ! duplicated(gene))\n\n# Estimatez-score values for the GES. Cheeck VIPER manual for details\n\nmyStatistics = matrix(DEsignature$avg_log2FC, dimnames = list(DEsignature$gene,\n                                                              \n                                                              'avg_log2FC') )\n\nmyPvalue = matrix(DEsignature$p_val_adj, dimnames = list(DEsignature$gene, 'padj') )\n\nmySignature = (qnorm(myPvalue/2, lower.tail = FALSE) * sign(myStatistics))[, 1]\n\nmySignature = mySignature[order(mySignature, decreasing = T)]\n\n# Estimate TF activities\n\nmrs = msviper(ges = mySignature, regulon = regulon_A,minsize = 25, ges.filter = F)\n\nTF_activities = data.frame(Regulon = names(mrs$es$nes),\n                           \n                           Size = mrs$es$size[ names(mrs$es$nes) ],\n                           \n                           NES = mrs$es$nes,\n                           \n                           p.value = mrs$es$p.value,\n                           \n                           FDR = p.adjust(mrs$es$p.value, method = 'fdr'))\n\nTF_activities = TF_activities[ order(TF_activities$p.value), ]\nTF_activities$cluster &lt;- list[i]\nTF_activities_all&lt;- rbind(TF_activities_all, TF_activities)\n}\n\n\n\nThe plot depicts the enrichment for all clusters in the HuMicA but only considers the significant TFs for the three homeostatic clusters is considered for representation. The statistically significant TFs were considered for an adj p value (FDR) &lt; 0.05.\n\nTF_activities_DAM &lt;- TF_activities_all[TF_activities_all$cluster %in% c(\"1\",\"2\",\"3\",\"5\",\"6\"),]\n\nTF_activities_DAM_sig &lt;- TF_activities_DAM[TF_activities_DAM$FDR &lt; 0.05,]\n\n#Plot TF enrichment results\nTF_activities_all &lt;- TF_activities_all%&gt;% \n  mutate(logFDR = -log(FDR))\n\ncommon_features &lt;- TF_activities_DAM_sig$Regulon %&gt;% unique()\n\nggplot(TF_activities_all %&gt;% dplyr::filter(Regulon %in% common_features), aes(as.factor(cluster), y= factor(Regulon, levels = common_features),color=NES,size =logFDR)) +\n  geom_point() +\n  scale_color_gradient2(low=\"#47663D\",mid = \"white\",high=\"#B86B00\")+\n  theme_pubr(border = 1)+ \n  coord_flip()+\n  theme(axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5))"
  },
  {
    "objectID": "08. DAM-related clusters.html#homeostatic-clusters",
    "href": "08. DAM-related clusters.html#homeostatic-clusters",
    "title": "DAM-related clusters",
    "section": "",
    "text": "This script depicts the specific and in-depth characterization of the clusters related to the disease-associated microglia (DAM) signature, including gene markers, gene ontology, gene set enrichment anaysis, and transcription factor enrichment, related to Figure 3.\n\n\n\nlibs &lt;- c(\"Seurat\", \"tidyverse\", \"clusterProfiler\",\"viper\",\"dorothea\",\"org.Hs.eg.db\",\"ggrepel\",\"gridExtra\",\"ggpubr\",\"readxl\",\"msigdbr\",\"fgsea\",\"data.table\")\nsuppressMessages(\nsuppressWarnings(sapply(libs, require, character.only =TRUE))\n)\n\n         Seurat       tidyverse clusterProfiler           viper        dorothea \n           TRUE            TRUE            TRUE            TRUE            TRUE \n   org.Hs.eg.db         ggrepel       gridExtra          ggpubr          readxl \n           TRUE            TRUE            TRUE            TRUE            TRUE \n        msigdbr           fgsea      data.table \n           TRUE            TRUE            TRUE \n\n\n\n\n\nBased on the Module Score expression of the original DAM signature from Keren-Shaul et al (2017) and the more recent DAM, DIM (disease-inflammatory macrophage) and YAM (youth-associated microglia) from Silvin et al (2022), we determined clusters 1, 2, 3, 5 and 6 as DAM-related. In addition to the mentioned Module Scores, we represented the expression of the top 10 significant markers for each cluster. The used sigantures are included at the “Genesets_literature” file in this repository (“Support data”).\n\n\n\n# define gene signatures\ngenesets$genesets &lt;- paste0(genesets$Population, \"_\",genesets$Study)\n\nAll_DAM &lt;- genesets$Gene[genesets$genesets==\"up_DAM_Keren_shaul_Thrupp\"]\nHuman_DAM_signature &lt;- genesets$Gene[genesets$genesets==\"Human_Adult_DAMs_Silvin\"]\nHuman_DIM_signature &lt;- genesets$Gene[genesets$genesets==\"Human_Adult_DIMs_Silvin\"]\nHuman_YAM_signature &lt;- genesets$Gene[genesets$genesets==\"Human_Adult_YAMs_Silvin\"]\n\n# Add Module Scores\nHumica &lt;- SetIdent(Humica, value = Humica@meta.data$integrated_snn_res.0.2)\nDefaultAssay(Humica)&lt;-\"RNA\"\nHumica &lt;- NormalizeData(Humica)\n\nHumica &lt;- AddModuleScore(Humica,\n                         features =list(All_DAM),\n                         name='DAM.ALL')\n\nHumica &lt;- AddModuleScore(Humica,\n                         features =list(Human_DAM_signature),\n                         name='Human_DAM_Silvin')\n\nHumica &lt;- AddModuleScore(Humica,\n                         features =list(Human_YAM_signature),\n                         name='Human_YAM_Silvin')\n\nHumica &lt;- AddModuleScore(Humica,\n                         features =list(Human_DIM_signature),\n                         name='Human_DIM_Silvin')\n\n# define top 10 markers per DAM-related cluster\nDAM_markers &lt;- sig_markers[sig_markers$cluster %in% c(\"1\",\"2\",\"3\",\"5\",\"6\"),]\nDAM_markers$avg_log2FC&lt;- as.numeric(DAM_markers$avg_log2FC)\n\nDAM_markers %&gt;%\n  group_by(cluster) %&gt;% arrange(-avg_log2FC) %&gt;% arrange(cluster) %&gt;% \n  top_n(n = 10, wt = avg_log2FC)-&gt; top10_up \n\n# DotPlot\nfeatures &lt;- c(\"DAM.ALL1\",\"Human_DAM_Silvin1\",\"Human_YAM_Silvin1\",\"Human_DIM_Silvin1\",top10_up$gene %&gt;% unique)\n\nDotPlot(Humica, features =factor(features, levels = features), \n        dot.scale = 10) +\n  scale_colour_gradient2(low = \"darkblue\", mid = \"white\", high = \"darkred\")+\n  #scale_color_virgeneis_c() +\n  theme(axis.text.x = element_text(angle=90, hjust = 0))\n\n\n\n\n\n\n\n\n\n\n\n\nThe representation of the HuMicA object was edited to depict only the five populations enriched for the DAM signature, namely clusters 1 (Inflam.DAM), 2 (DIMs), 3 (Ribo.DAM1), 5 (Ribo.DAM2) and 6 (Lipo.DAM). Of note, cluster 7 (Border-Associated Macrophages) ara also represented, to support the potential macrophagic nature of the DIMs, based on the proximity of both populations in the UMAP. This annotation was based on the previous enrichment presented in Figure 1F, the above DotPlot and the enrichment analysis that will be presented bellow.\n\ncolor_clusters &lt;-c(\"white\", \"#FC8D62\", \"#7570B3\" ,\"#679436\", \"white\" ,\"#344D67\", \"#874C62\" ,\"#937666\", \"white\")\nDimPlot(Humica, reduction = \"umap\",cols = color_clusters, repel = TRUE, pt.size = 0.01, label = F)+NoLegend()\n\n\n\n\n\n\n\n\n\n\nThe most prominent markers of each cluster were represented separately in Feature plots: TMEM163 for Inflam.DAM; SLC2A3 for DIMs; SYT1 for Ribo.DAM1; PLEKHA7 for Ribo.DAM2; and GPNMB for Lipo.DAM (related to Supplementary Figure 7A).\n\nHumica &lt;- SetIdent(Humica, value = Humica@meta.data$integrated_snn_res.0.2)\nDefaultAssay(Humica)&lt;-\"RNA\"\nHumica &lt;- NormalizeData(Humica)\n\nFeaturePlot(Humica, features = c(\"TMEM163\",\"SLC2A3\",\"SYT1\",\"PLEKHA7\",\"GPNMB\"), ncol=5,label = F, repel = TRUE,pt.size = 0.5) & scale_colour_gradientn(colours = c(\"#FCFCFF\",\"#FCFCFF\",\"#DCF2CE\",\"#FFCB77\",\"#BD6B73\",\"#A30B37\"))\n\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n\n\n\n\n\n\n\n\n\n\n\n\n\nGene ontology (GO) was calculated with the enrichGO function from clusterProfiler.\n\n\nThe top 10 significant GO terms for each of the homeostatic clusters were represented in barplots to provide a broader insight on the GO enrichment (related to Supplementary Figure 7B). GO was recalculated and edited to obtain the Fold Change of enrichment.\n\ni = 0\nresults &lt;- list()\ngo_all_simplify &lt;- data.frame()\nfor(comparison in levels(factor(DAM_markers$cluster))){\n  i = i+1\n  print(paste(comparison))\n  ego &lt;- enrichGO(gene              = DAM_markers[DAM_markers$cluster == comparison,]$gene,\n                  OrgDb             = org.Hs.eg.db,\n                  ont               = \"ALL\",\n                  keyType           = \"SYMBOL\",\n                  pAdjustMethod     = \"BH\",\n                  pvalueCutoff      = 1,\n                  qvalueCutoff      = 0.05,\n                  readable          = T )\n  ego &lt;- simplify(ego, cutoff=0.7, by=\"p.adjust\", select_fun=min)\n  \n  results[[comparison]] &lt;- ego@result %&gt;%\n    separate(GeneRatio, into = c(\"gene_pos\", \"gene_total\"), sep = \"/\") %&gt;%\n    separate(BgRatio, into = c(\"bg_pos\", \"bg_total\"), sep = \"/\") %&gt;%\n    mutate(FC = (as.numeric(gene_pos)/as.numeric(gene_total)) /\n             (as.numeric(bg_pos)/as.numeric(bg_total)),\n           cluster = comparison) %&gt;%\n    arrange(.$p.adjust)\n  go_all_simplify &lt;- rbind(go_all_simplify, results[[comparison]])\n}\n\n\nclusterlist &lt;- c(\"1\",\"2\",\"3\",\"5\",\"6\")\np&lt;-list()\nfor (i in 1:length(clusterlist)) {\n  data &lt;-go_all_simplify[go_all_simplify$cluster==clusterlist[i],]\n  data$logpadj &lt;- -log10(data$p.adjust)\n  data$logFC&lt;- log10(data$FC)\n  top10 &lt;- data %&gt;%top_n(n = 10, wt = logpadj)\n  top10 &lt;- top10[1:10,]\n  \n  \n  p[[i]]&lt;- ggplot(top10,\n                  aes(fill=logFC,\n                      x=factor(ID, level = rev(ID)),\n                      y=logpadj,\n                      color=\"black\")) +\n    geom_col(color=\"black\", size=0.2) +\n    geom_text(aes(label = Description), hjust=0,position = position_fill(vjust = 0), size = 4, color=\"black\")+\n    theme_bw() +\n    scale_fill_gradientn(colours = c(\"#B9CFD4\",\"#AFAAB9\",\"#B48291\",\"#8C5465\"))+\n    #scale_fill_viridis(option = \"plasma\")+\n    coord_flip()\n}\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\ndo.call(grid.arrange,p)\n\n\n\n\n\n\n\n\n\n\n\n\nGSEA analysis was performed using as reference all genesets from msigdbr for the “C2” category of “Homo sapiens”. The results from FindAllMarkers with a less significant cutoff were used as cutoff. This intends to account for the broad spectrum of differential expression and not only the significant differentially expressed markers (only.pos = F, min.pct = 0.1, logfc.threshold = 0.0, test.use = “MAST”). Of note, both up and downregulated markers were considered at “Humica.markers”. The avg_log2FC and the p_val_adj were used for ranking.\n\nall_gene_sets = msigdbr(species = \"Homo sapiens\",category = c(\"C2\"))\n\nmsigdbr_list = split(x = all_gene_sets$gene_symbol, f = all_gene_sets$gs_name)\n\nfgsea_ALL &lt;- data.frame()\nfor (i in 1:length(clusterlist)) {\ndata &lt;- Humica_markers[Humica_markers$cluster==clusterlist[i],]  \ndata2 &lt;- structure(data$avg_log2FC, names=data$gene)\ndf &lt;- fgsea(pathways =msigdbr_list, \n            stats    = data2,\n            scoreType =\"pos\",\n            minSize  = 1,\n            maxSize  = Inf)\n\n\ndf$cluster &lt;- clusterlist[i]\n\nfgsea_ALL &lt;- rbind(fgsea_ALL, df)\n}\n\n\n\nA list of terms of interested were selected from the results output. The results are presented as a function of the Normalized Enrichment Score (NES) and the negative of the log of the adjusted p value.\n\n## with - LOG adj p value\nfgsea_res$log &lt;- -log(fgsea_res$padj)\nfgsea_res &lt;- fgsea_res[order(fgsea_res$log),]\n\nfgsea_res$NES&lt;- fgsea_res$NES %&gt;% as.numeric()\n\nfgsea_res$pathway2 &lt;- paste0(fgsea_res$pathway,\"_\",fgsea_res$cluster)\n\nggplot(fgsea_res, aes(factor(pathway2, levels=pathway2), log, fill=NES))+\n  geom_bar(stat = \"identity\")+\n  geom_text(aes(label = pathway2),color=\"black\", hjust=0,position = position_fill(vjust = 0.2), size = 4)+\n  scale_fill_gradientn(colours = c(\"#F0FFCE\",\"#CCC9A1\",\"#CD543C\"))+\n  #scale_size_continuous(range = c(6, 14))+\n  coord_flip()+\n  facet_grid(cluster~., shrink = TRUE, scales = \"free\", space=\"free\")+\n  theme_bw()+\n  theme(axis.text.y  = element_blank())\n\n\n\n\n\n\n\n\n\n\n\n\nThe collection of transcription factors (TFs) and their target genes was obtained from the DoRothEA regulon A. The enrichment analysis was performed using the viper package. The regulon object downloaded from https://github.com/deeenes/DoRothEA/tree/master/data/TFregulons/Robjects_VIPERformat/consensus, already in the appropriate format to be used in the viper pipeline. The Humica.markers file correspond to the broad spectrum differential expression output, mentioned in the “Characterization of the HuMicA” script of this repository. The following represents the loop for the calculation of TF enrichment in all nine clusters.\n\nregulon_A&lt;- viper_regulon\nnames(regulon_A)=sapply(strsplit(names(regulon_A),split=\" - \"),head, 1)\n\nlist &lt;- unique(Humica_markers$cluster)\nTF_activities_all &lt;- data.frame()\n\nfor (i in 1:length(list)) {\n\ndata &lt;- Humica_markers[Humica_markers$cluster==list[i],]\n\n#Exclude probes with unknown or duplicated gene symbol\nDEsignature = subset(data, gene != \"\" )\n\nDEsignature = subset(DEsignature, ! duplicated(gene))\n\n# Estimatez-score values for the GES. Cheeck VIPER manual for details\n\nmyStatistics = matrix(DEsignature$avg_log2FC, dimnames = list(DEsignature$gene,\n                                                              \n                                                              'avg_log2FC') )\n\nmyPvalue = matrix(DEsignature$p_val_adj, dimnames = list(DEsignature$gene, 'padj') )\n\nmySignature = (qnorm(myPvalue/2, lower.tail = FALSE) * sign(myStatistics))[, 1]\n\nmySignature = mySignature[order(mySignature, decreasing = T)]\n\n# Estimate TF activities\n\nmrs = msviper(ges = mySignature, regulon = regulon_A,minsize = 25, ges.filter = F)\n\nTF_activities = data.frame(Regulon = names(mrs$es$nes),\n                           \n                           Size = mrs$es$size[ names(mrs$es$nes) ],\n                           \n                           NES = mrs$es$nes,\n                           \n                           p.value = mrs$es$p.value,\n                           \n                           FDR = p.adjust(mrs$es$p.value, method = 'fdr'))\n\nTF_activities = TF_activities[ order(TF_activities$p.value), ]\nTF_activities$cluster &lt;- list[i]\nTF_activities_all&lt;- rbind(TF_activities_all, TF_activities)\n}\n\n\n\nThe plot depicts the enrichment for all clusters in the HuMicA but only considers the significant TFs for the three homeostatic clusters is considered for representation. The statistically significant TFs were considered for an adj p value (FDR) &lt; 0.05.\n\nTF_activities_DAM &lt;- TF_activities_all[TF_activities_all$cluster %in% c(\"1\",\"2\",\"3\",\"5\",\"6\"),]\n\nTF_activities_DAM_sig &lt;- TF_activities_DAM[TF_activities_DAM$FDR &lt; 0.05,]\n\n#Plot TF enrichment results\nTF_activities_all &lt;- TF_activities_all%&gt;% \n  mutate(logFDR = -log(FDR))\n\ncommon_features &lt;- TF_activities_DAM_sig$Regulon %&gt;% unique()\n\nggplot(TF_activities_all %&gt;% dplyr::filter(Regulon %in% common_features), aes(as.factor(cluster), y= factor(Regulon, levels = common_features),color=NES,size =logFDR)) +\n  geom_point() +\n  scale_color_gradient2(low=\"#47663D\",mid = \"white\",high=\"#B86B00\")+\n  theme_pubr(border = 1)+ \n  coord_flip()+\n  theme(axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5))"
  },
  {
    "objectID": "10. Pseudobulk DEGs.html",
    "href": "10. Pseudobulk DEGs.html",
    "title": "Pseudobulk DEGs",
    "section": "",
    "text": "This script demonstrates the pipeline used for the calculation of pseudobulk DEGs between each pathology and the control population, related to Figure 5.\n\n\n\nlibs &lt;- c(\"Seurat\",\"tidyverse\", \"survminer\", \"GeneOverlap\", \"circlize\", \"ComplexHeatmap\",\"readxl\",\"sva\", \"DESeq2\")\nsuppressMessages(\nsuppressWarnings(sapply(libs, require, character.only =TRUE))\n)\n\n        Seurat      tidyverse      survminer    GeneOverlap       circlize \n          TRUE           TRUE           TRUE           TRUE           TRUE \nComplexHeatmap         readxl            sva         DESeq2 \n          TRUE           TRUE           TRUE           TRUE \n\n\n\n\n\nPseudobulk DEGs were calculated with the aggregated counts of all cells/nuclei in each study group/pathology. Of note, DEGs were calculates accounting for the full HuMicA object, homeostatic cells (clusters 0, 4, 8), DIMs (cluster 2), DAMs (clusters 1, 3, 5 and 6) and macrophages (cluster 7).\nThe pipeline was applied on a loop for the abovementioned data subsets. The main steps are as follows: 1) Subset the HuMicA object (or not for the analysis of the complete object) 2) Obtain pseudobulk counts with AggregateExpression per sample/subject and remove genes with low count number. Note: the annot.xlsl file has been deposited in the “Support data” folder of this repository and consists of the metadata of the 241 individual samples composing the HuMicA. 3) Remove batch effect of the “Methodology” variable (cells vs nuclei) using ComBat_seq (sva). 4) Calculate DEGs between each pathology and controls. Note: In the original analysis, the DEG results were saved as a txt file for each HuMicA subset and posteriorly uploaded for plot design. 5) Gene ontology (GO) enrichemnt (clusterProfiler) for the lists of significant upregulated and downregulated DEGs for each HuMicA subset for each comparison. *Note: In the original analysis, each GO results was saved as a txt file and posteriorly uploaded for plot design.\n\nclusterlist &lt;- list(c(\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\"),c(\"0\",\"4\",\"8\"),\n                    c(\"2\"),c(\"1\",\"3\",\"5\",\"6\"), c(\"7\"))\nclusterlist2 &lt;- c(\"Humica\",\"Homeos\",\"DIM\",\"DAM\",\"MAC\")\n  \nfor (i in 1:length(clusterlist)) {\n  \n# Subset object\nsubset_humica &lt;- subset(Humica, idents=clusterlist[[i]])\nsubset_humica &lt;- SetIdent(subset_humica, value = subset_humica@meta.data$Sample_ID)\n\n# Remove lowly expressed genes which have less than 10 cells without any counts\nkeep &lt;- subset_humica[[\"RNA\"]]@counts[rowSums(subset_humica@assays[[\"RNA\"]]@counts &gt; 1) &gt;= 10, ] %&gt;% rownames \n\n# obtain pseudobulk counts and remove genes with low counts\nbulk_counts &lt;- AggregateExpression(subset_humica,\n                                 group.by=c(\"Sample_ID\"), \n                                 assays=\"RNA\",\n                                 slots=\"counts\",\n                                 return.seurat=F)$RNA %&gt;% as.data.frame()\n\nbulk_counts &lt;- bulk_counts[keep,]\n\ncoldata &lt;- read_excel(\"~/d/Ricardo/HuMicA/annot.xlsx\")\ncoldata$Sample_ID2&lt;-gsub(\"_\", \".\", coldata$Sample_ID2)\ncoldata$Sample_ID2&lt;-gsub(\"-\", \".\", coldata$Sample_ID2)\nrownames(coldata)&lt;- coldata$Sample_ID2\n\ncolnames(bulk_counts)&lt;-gsub(\"_\", \".\", colnames(bulk_counts))\ncolnames(bulk_counts)&lt;-gsub(\"-\", \".\", colnames(bulk_counts))\n\ncoldata &lt;- coldata[colnames(bulk_counts),]\nrownames(coldata)&lt;- coldata$Sample_ID2\n\nall(colnames(bulk_counts)== rownames(coldata))\n#[1] TRUE\n\n# Adjust for batch effec\ncts&lt;- ComBat_seq(bulk_counts %&gt;% as.matrix(),batch = coldata$Methodology)\n\n# DESeq2\n## check if the order of the samples in cts (counts) and in coldata is equal\nrownames(coldata)&lt;- coldata$Sample_ID2\nall(rownames(coldata)==colnames(cts))\n\n## Make Deseq object\ncoldata$Group &lt;- as.factor(coldata$Group)\ndds &lt;- DESeqDataSetFromMatrix(countData = cts,\n                              colData = coldata,\n                              design= ~ Group)\n\ndds &lt;- estimateSizeFactors(dds)\n\n## fit model\ndds &lt;- DESeq(dds)\n\n## obtain table with results of all comparisons\ngroup_list &lt;- c(\"AD\",\"ASD\",\"COVID-19\",\"Epilepsy\",\"LBD\",\"MS\")\nres_ALL &lt;- data.frame()\nfor (z in 1:length(group_list)) {\n  \n  res &lt;- results(dds, contrast = c(\"Group\",group_list[z],\"No Neuropathology\"))\n  summary(res, alpha=0.05)\n  #res\n  res &lt;- data.frame(res)\n  res$gene = rownames(res)\n  \n  res$Group &lt;- group_list[z]\n  \n  \n  res_ALL &lt;- rbind(res_ALL, res)\n}\n\n# add column with the HuMicA subset being used\nres_ALL$cluster &lt;- clusterlist2[i]\n\n# Filter only significant DEGs\nres_sig &lt;- res_ALL[res_ALL$padj&lt;0.05 & abs(res_ALL$log2FoldChange)&gt;1,] %&gt;% drop_na(log2FoldChange)\n\n\n# Gene ontology\n## GO with upregulated\nf = 0\nresults &lt;- list()\ngo_all &lt;- data.frame()\nup_res_ALL &lt;- res_sig[res_sig$log2FoldChange&gt;0,]\nfor (comparison in levels(factor(res_ALL$Group))) {\n  f = f + 1\n  print(paste(comparison))\n  \n  # Use tryCatch to handle errors\n  tryCatch({\n    ego &lt;- enrichGO(gene              = up_res_ALL[up_res_ALL$Group == comparison,]$gene,\n                    OrgDb             = org.Hs.eg.db,\n                    universe = bg_genes,\n                    ont               = \"ALL\",\n                    keyType           = \"SYMBOL\",\n                    pAdjustMethod     = \"BH\",\n                    pvalueCutoff      = 1,\n                    qvalueCutoff      = 0.2,\n                    readable          = T )\n    ego &lt;- simplify(ego, cutoff=0.7, by=\"p.adjust\", select_fun=min) \n    results[[comparison]] &lt;- ego@result %&gt;%\n      separate(GeneRatio, into = c(\"gene_pos\", \"gene_total\"), sep = \"/\") %&gt;%\n      separate(BgRatio, into = c(\"bg_pos\", \"bg_total\"), sep = \"/\") %&gt;%\n      mutate(FC = (as.numeric(gene_pos)/as.numeric(gene_total)) /\n               (as.numeric(bg_pos)/as.numeric(bg_total)),\n             cluster = comparison) %&gt;%\n      arrange(.$p.adjust)\n    \n    results[[comparison]]$Group &lt;- comparison\n    go_all &lt;- rbind(go_all, results[[comparison]])\n    \n  }, error = function(e) {\n    # Print the error message (optional)\n    cat(\"Error occurred for\", comparison, \":\", conditionMessage(e), \"\\n\")\n    \n    # Continue with the next iteration\n    # ...\n  })\n}\n\n## GO with downregulated\nf = 0\nresults &lt;- list()\ngo_all &lt;- data.frame()\ndown_res_ALL &lt;- res_sig[res_sig$log2FoldChange &lt; 0,]\nfor (comparison in levels(factor(res_sig$Group))) {\n  f = f + 1\n  print(paste(comparison))\n  \n  # Use tryCatch to handle errors\n  tryCatch({\n    ego &lt;- enrichGO(gene              = down_res_ALL[down_res_ALL$Group == comparison,]$gene,\n                    OrgDb             = org.Hs.eg.db,\n                    ont               = \"ALL\",\n                    universe = bg_genes,\n                    keyType           = \"SYMBOL\",\n                    pAdjustMethod     = \"BH\",\n                    pvalueCutoff      = 1,\n                    qvalueCutoff      = 1,\n                    readable          = T )\n    ego &lt;- simplify(ego, cutoff=0.7, by=\"p.adjust\", select_fun=min)\n    \n    results[[comparison]] &lt;- ego@result %&gt;%\n      separate(GeneRatio, into = c(\"gene_pos\", \"gene_total\"), sep = \"/\") %&gt;%\n      separate(BgRatio, into = c(\"bg_pos\", \"bg_total\"), sep = \"/\") %&gt;%\n      mutate(FC = (as.numeric(gene_pos)/as.numeric(gene_total)) /\n               (as.numeric(bg_pos)/as.numeric(bg_total)),\n             cluster = comparison) %&gt;%\n      arrange(.$p.adjust)\n    \n    results[[comparison]]$Group &lt;- comparison\n    go_all &lt;- rbind(go_all, results[[comparison]])\n    \n  }, error = function(e) {\n    # Print the error message (optional)\n    cat(\"Error occurred for\", comparison, \":\", conditionMessage(e), \"\\n\")\n    \n    # Continue with the next iteration\n    # ...\n  })\n}\n}\n\n\n\nThe All_degs file consist of the joint data.table of the DESeq2::results() output obtained for each HuMicA subset and accounting only for the significant DEGs (padj &lt; 0.05 and log2FoldChange &gt; 1).\n\n# annoatate up and downregulated DEGs\nAll_degs$direction &lt;- ifelse(All_degs$log2FoldChange&gt;0, \"up\", \"down\")\n\nAll_degs$Group &lt;- as.factor(All_degs$Group)\nAll_degs$cluster &lt;- as.factor(All_degs$cluster)\n\n# Create a data.table for upregulated and downregulated DEGs\nup_degs &lt;- All_degs[All_degs$log2FoldChange&gt;1,]\ndown_degs &lt;- All_degs[All_degs$log2FoldChange&lt; -1,]\n\n\n# Barplot\n## Upregulated\nggplot(up_degs, aes(x = Group, fill = factor(cluster, levels = c(\"Humica\",\"Homeos\", \"DAM\", \"DIM\", \"MAC\")))) +\n  geom_bar(position = position_dodge2(width = 0.9, preserve = \"single\")) +\n  scale_fill_manual(values = c(\"#255C99\",\"#efdd8d\",\"#4c934c\",\"#7570b3\",\"#937666\"))+\n  labs(x = \"Group\", y = \"Number of upregulated Genes\") +\n  geom_text(\n    aes(label = ifelse(..count.. == 0, \"\", ..count..)),  # Display label only if count is not 0\n    stat = \"count\",\n    position = position_dodge(width = 0.9),\n    vjust = -0.5,\n    size = 3\n  ) +\n  theme_classic2() + theme(legend.position = \"none\")\n\nWarning: The dot-dot notation (`..count..`) was deprecated in ggplot2 3.4.0.\nℹ Please use `after_stat(count)` instead.\n\n\n\n\n\n\n\n\n# Downregulated\nggplot(down_degs, aes(x = Group, fill = factor(cluster, levels = c(\"Humica\",\"Homeos\", \"DAM\", \"DIM\", \"MAC\")))) +\n  geom_bar(position = position_dodge2(width = 0.9, preserve = \"single\")) +\n  scale_fill_manual(values = c(\"#255C99\",\"#efdd8d\",\"#4c934c\",\"#7570b3\",\"#937666\"))+\n  labs(x = \"Group\", y = \"Number of downregulated Genes\") +\n  geom_text(\n    aes(label = ifelse(..count.. == 0, \"\", ..count..)),  # Display label only if count is not 0\n    stat = \"count\",\n    position = position_dodge(width = 0.9),\n    vjust = -0.5,\n    size = 3\n  ) +\n  theme_classic2() + theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n\n\nThe GO_all_up_sig and GO_all_down_sig files consist of the joint data.table of the enrichGO output obtained for each HuMicA and accounting only for the significant terms (p.adjust &lt; 0.05). GO terms were selected fro representation based on significance and biological relevance.\n\n# GO of upreguated DEGs\n## Plot list of selected terms\nselected_terms &lt;- c(\"dynein light intermediate chain binding\",\n                   \"proton-transporting ATP synthase complex\", \n                   \"actin binding\", \"collagen-containing extracellular matrix\", \"minus-end-directed microtubule motor activity\",\n                   \"structural constituent of ribosome\",\"ribosome assembly\",\"ATPase complex\",\n                   \"myelination\", \"myelin sheath\",\n                   \"WASH complex\",\n                   \"immune receptor activity\", \"cytokine receptor activity\",\"leukocyte migration\",\n                   \"MHC protein complex\",\n                   \"triglyceride-rich plasma lipoprotein particle\")\n\nGO_all_up_sig&lt;- GO_all_up_sig %&gt;% \n  mutate(logFC = log(FC),\n         logFDR = -log(p.adjust))\n\norder_cluster2 &lt;- c(\"Humica_AD\",\"Humica_ASD\",\"Humica_COVID-19\",\"Humica_Epilepsy\",\"Humica_LBD\", \"Humica_MS\",\n                    \"Homeos_AD\",\"Homeos_ASD\",\"Homeos_COVID-19\",\"Homeos_Epilepsy\",\"Homeos_LBD\", \"Homeos_MS\",\n                    \"DAM_AD\",\"DAM_ASD\",\"DAM_COVID-19\",\"DAM_Epilepsy\",\"DAM_LBD\", \"DAM_MS\",\n                    \"DIM_AD\",\"DIM_ASD\",\"DIM_COVID-19\",\"DIM_Epilepsy\",\"DIM_LBD\", \"DIM_MS\")\n\nggplot(GO_all_up_sig%&gt;% dplyr::filter(Description %in% selected_terms), aes(cluster2, factor(Description,levels = selected_terms), colour = logFC)) +\n  scale_x_discrete(limits=order_cluster2)+\n  scale_size_continuous(range = c(3, 9)) + \n  geom_point(aes(size = logFDR)) +\n  scale_color_gradientn(colours = c(\"lightgray\",\"#A44A3F\"))+\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))+\n  border()\n\n\n\n\n\n\n\n# Plot list of selected terms\n   \nselected_terms &lt;- c(\"ATP metabolic process\",\"locomotory behavior\",\"secretory granule lumen\",\n                       \"intrinsic apoptotic signaling pathway\",\n                       \"synapse organization\", \"synaptic membrane\",\n                       \"regulation of trans-synaptic signaling\", \n                        \"glutamatergic synapse\",\n                       \"developmental growth involved in morphogenesis\",\n                       \"amyloid-beta binding\", \"adrenergic receptor binding\", \n                       \"proton-transporting ATP synthase complex\", \"WASH complex\",\n                       \"myelin sheath\", \"oxidative phosphorylation\",\n                        \"respiratory chain complex\",\n                       \"regulation of DNA repair\", \"GTPase regulator activity\",\n                       \"MHC protein complex\")\n   \nGO_all_down_sig&lt;- GO_all_down_sig %&gt;% \n   mutate(logFC = log(FC),\n          logFDR = -log(p.adjust))\n\norder_cluster2 &lt;- c(\"Humica_AD\",\"Humica_ASD\",\"Humica_COVID-19\",\"Humica_Epilepsy\",\"Humica_LBD\", \"Humica_MS\",\n                       \"Homeos_AD\",\"Homeos_ASD\",\"Homeos_COVID-19\",\"Homeos_Epilepsy\",\"Homeos_LBD\", \"Homeos_MS\",\n                       \"DAM_AD\",\"DAM_ASD\",\"DAM_COVID-19\",\"DAM_Epilepsy\",\"DAM_LBD\", \"DAM_MS\",\n                       \"DIM_AD\",\"DIM_ASD\",\"DIM_COVID-19\",\"DIM_Epilepsy\",\"DIM_LBD\", \"DIM_MS\")\n   \nggplot(GO_all_down_sig%&gt;% dplyr::filter(Description %in% selected_terms), aes(cluster2, factor(Description,levels = selected_terms), colour = logFC)) +\n     scale_x_discrete(limits=order_cluster2)+\n     scale_size_continuous(range = c(3, 9)) + \n     geom_point(aes(size = logFDR)) +\n     scale_color_gradientn(colours = c(\"lightgray\",\"#A44A3F\"))+\n     #theme_pubr() + \n     theme(axis.text.x = element_text(angle = 45, hjust = 1))+\n     border()\n\n\n\n\n\n\n\n\n\n\n\n\nThe significance of the overlap between the obtained DEGs was performing using the GeneOverlap package. The analysis was performed per HuMicA subset (comparing pathogies), related to Figure 5 B, and per pathology (comparing HuMicA subsets), related to Supplementary Figure 9. One example is presented bellow.\n\n# Upregulated DEGs in the full HuMicA object (background with 17943 genes)\nHumica_degs &lt;- All_degs[All_degs$cluster==\"DAM\",]\n\nup_Humica_degs &lt;- Humica_degs[Humica_degs$log2FoldChange&lt;0,]\n\n# Create lists of DEGs per pathology\nAD_up_Humica_degs &lt;- up_Humica_degs[up_Humica_degs$Group==\"AD\",]$gene \nASD_up_Humica_degs &lt;- up_Humica_degs[up_Humica_degs$Group==\"ASD\",]$gene\nCV19_up_Humica_degs &lt;- up_Humica_degs[up_Humica_degs$Group==\"COVID-19\",]$gene\nEpilepsy_up_Humica_degs &lt;- up_Humica_degs[up_Humica_degs$Group==\"Epilepsy\",]$gene\nLBD_up_Humica_degs &lt;- up_Humica_degs[up_Humica_degs$Group==\"LBD\",]$gene\nMS_up_Humica_degs &lt;- up_Humica_degs[up_Humica_degs$Group==\"MS\",]$gene\n\nHumica_degs_up_list &lt;- setNames(list(AD_up_Humica_degs,ASD_up_Humica_degs,CV19_up_Humica_degs,\n                                     Epilepsy_up_Humica_degs,LBD_up_Humica_degs,MS_up_Humica_degs),\n                                c(\"AD_up_Humica_degs\",\"ASD_up_Humica_degs\",\"CV19_up_Humica_degs\",\n                                  \"Epilepsy_up_Humica_degs\",\"LBD_up_Humica_degs\",\"MS_up_Humica_degs\"))\n\n\n# Calculate significance of the overlap based on the Jaccard index and the p value (in the figures, the * asterisck identifies overlaps with p &lt; 0.05)\ngom.obj &lt;- newGOM(Humica_degs_up_list,genome.size = 17943)\n\nHumica_mat_jaccard &lt;- getMatrix(gom.obj, \"Jaccard\")\nHumica_mat_p &lt;- getMatrix(gom.obj, \"pval\")\n\ncol_fun = colorRamp2(c(0,0.05,0.10,0.15,0.25), c(\"#00112b\",\"#185C5C\", \"#1f948cff\",\"#B4D650\",\"#FFDD55\"))\n\nHeatmap(Humica_mat_jaccard %&gt;% as.matrix(), cluster_columns = F, cluster_rows = F, col=col_fun)"
  },
  {
    "objectID": "10. Pseudobulk DEGs.html#pseudobulk-degs",
    "href": "10. Pseudobulk DEGs.html#pseudobulk-degs",
    "title": "Pseudobulk DEGs",
    "section": "",
    "text": "This script demonstrates the pipeline used for the calculation of pseudobulk DEGs between each pathology and the control population, related to Figure 5.\n\n\n\nlibs &lt;- c(\"Seurat\",\"tidyverse\", \"survminer\", \"GeneOverlap\", \"circlize\", \"ComplexHeatmap\",\"readxl\",\"sva\", \"DESeq2\")\nsuppressMessages(\nsuppressWarnings(sapply(libs, require, character.only =TRUE))\n)\n\n        Seurat      tidyverse      survminer    GeneOverlap       circlize \n          TRUE           TRUE           TRUE           TRUE           TRUE \nComplexHeatmap         readxl            sva         DESeq2 \n          TRUE           TRUE           TRUE           TRUE \n\n\n\n\n\nPseudobulk DEGs were calculated with the aggregated counts of all cells/nuclei in each study group/pathology. Of note, DEGs were calculates accounting for the full HuMicA object, homeostatic cells (clusters 0, 4, 8), DIMs (cluster 2), DAMs (clusters 1, 3, 5 and 6) and macrophages (cluster 7).\nThe pipeline was applied on a loop for the abovementioned data subsets. The main steps are as follows: 1) Subset the HuMicA object (or not for the analysis of the complete object) 2) Obtain pseudobulk counts with AggregateExpression per sample/subject and remove genes with low count number. Note: the annot.xlsl file has been deposited in the “Support data” folder of this repository and consists of the metadata of the 241 individual samples composing the HuMicA. 3) Remove batch effect of the “Methodology” variable (cells vs nuclei) using ComBat_seq (sva). 4) Calculate DEGs between each pathology and controls. Note: In the original analysis, the DEG results were saved as a txt file for each HuMicA subset and posteriorly uploaded for plot design. 5) Gene ontology (GO) enrichemnt (clusterProfiler) for the lists of significant upregulated and downregulated DEGs for each HuMicA subset for each comparison. *Note: In the original analysis, each GO results was saved as a txt file and posteriorly uploaded for plot design.\n\nclusterlist &lt;- list(c(\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\"),c(\"0\",\"4\",\"8\"),\n                    c(\"2\"),c(\"1\",\"3\",\"5\",\"6\"), c(\"7\"))\nclusterlist2 &lt;- c(\"Humica\",\"Homeos\",\"DIM\",\"DAM\",\"MAC\")\n  \nfor (i in 1:length(clusterlist)) {\n  \n# Subset object\nsubset_humica &lt;- subset(Humica, idents=clusterlist[[i]])\nsubset_humica &lt;- SetIdent(subset_humica, value = subset_humica@meta.data$Sample_ID)\n\n# Remove lowly expressed genes which have less than 10 cells without any counts\nkeep &lt;- subset_humica[[\"RNA\"]]@counts[rowSums(subset_humica@assays[[\"RNA\"]]@counts &gt; 1) &gt;= 10, ] %&gt;% rownames \n\n# obtain pseudobulk counts and remove genes with low counts\nbulk_counts &lt;- AggregateExpression(subset_humica,\n                                 group.by=c(\"Sample_ID\"), \n                                 assays=\"RNA\",\n                                 slots=\"counts\",\n                                 return.seurat=F)$RNA %&gt;% as.data.frame()\n\nbulk_counts &lt;- bulk_counts[keep,]\n\ncoldata &lt;- read_excel(\"~/d/Ricardo/HuMicA/annot.xlsx\")\ncoldata$Sample_ID2&lt;-gsub(\"_\", \".\", coldata$Sample_ID2)\ncoldata$Sample_ID2&lt;-gsub(\"-\", \".\", coldata$Sample_ID2)\nrownames(coldata)&lt;- coldata$Sample_ID2\n\ncolnames(bulk_counts)&lt;-gsub(\"_\", \".\", colnames(bulk_counts))\ncolnames(bulk_counts)&lt;-gsub(\"-\", \".\", colnames(bulk_counts))\n\ncoldata &lt;- coldata[colnames(bulk_counts),]\nrownames(coldata)&lt;- coldata$Sample_ID2\n\nall(colnames(bulk_counts)== rownames(coldata))\n#[1] TRUE\n\n# Adjust for batch effec\ncts&lt;- ComBat_seq(bulk_counts %&gt;% as.matrix(),batch = coldata$Methodology)\n\n# DESeq2\n## check if the order of the samples in cts (counts) and in coldata is equal\nrownames(coldata)&lt;- coldata$Sample_ID2\nall(rownames(coldata)==colnames(cts))\n\n## Make Deseq object\ncoldata$Group &lt;- as.factor(coldata$Group)\ndds &lt;- DESeqDataSetFromMatrix(countData = cts,\n                              colData = coldata,\n                              design= ~ Group)\n\ndds &lt;- estimateSizeFactors(dds)\n\n## fit model\ndds &lt;- DESeq(dds)\n\n## obtain table with results of all comparisons\ngroup_list &lt;- c(\"AD\",\"ASD\",\"COVID-19\",\"Epilepsy\",\"LBD\",\"MS\")\nres_ALL &lt;- data.frame()\nfor (z in 1:length(group_list)) {\n  \n  res &lt;- results(dds, contrast = c(\"Group\",group_list[z],\"No Neuropathology\"))\n  summary(res, alpha=0.05)\n  #res\n  res &lt;- data.frame(res)\n  res$gene = rownames(res)\n  \n  res$Group &lt;- group_list[z]\n  \n  \n  res_ALL &lt;- rbind(res_ALL, res)\n}\n\n# add column with the HuMicA subset being used\nres_ALL$cluster &lt;- clusterlist2[i]\n\n# Filter only significant DEGs\nres_sig &lt;- res_ALL[res_ALL$padj&lt;0.05 & abs(res_ALL$log2FoldChange)&gt;1,] %&gt;% drop_na(log2FoldChange)\n\n\n# Gene ontology\n## GO with upregulated\nf = 0\nresults &lt;- list()\ngo_all &lt;- data.frame()\nup_res_ALL &lt;- res_sig[res_sig$log2FoldChange&gt;0,]\nfor (comparison in levels(factor(res_ALL$Group))) {\n  f = f + 1\n  print(paste(comparison))\n  \n  # Use tryCatch to handle errors\n  tryCatch({\n    ego &lt;- enrichGO(gene              = up_res_ALL[up_res_ALL$Group == comparison,]$gene,\n                    OrgDb             = org.Hs.eg.db,\n                    universe = bg_genes,\n                    ont               = \"ALL\",\n                    keyType           = \"SYMBOL\",\n                    pAdjustMethod     = \"BH\",\n                    pvalueCutoff      = 1,\n                    qvalueCutoff      = 0.2,\n                    readable          = T )\n    ego &lt;- simplify(ego, cutoff=0.7, by=\"p.adjust\", select_fun=min) \n    results[[comparison]] &lt;- ego@result %&gt;%\n      separate(GeneRatio, into = c(\"gene_pos\", \"gene_total\"), sep = \"/\") %&gt;%\n      separate(BgRatio, into = c(\"bg_pos\", \"bg_total\"), sep = \"/\") %&gt;%\n      mutate(FC = (as.numeric(gene_pos)/as.numeric(gene_total)) /\n               (as.numeric(bg_pos)/as.numeric(bg_total)),\n             cluster = comparison) %&gt;%\n      arrange(.$p.adjust)\n    \n    results[[comparison]]$Group &lt;- comparison\n    go_all &lt;- rbind(go_all, results[[comparison]])\n    \n  }, error = function(e) {\n    # Print the error message (optional)\n    cat(\"Error occurred for\", comparison, \":\", conditionMessage(e), \"\\n\")\n    \n    # Continue with the next iteration\n    # ...\n  })\n}\n\n## GO with downregulated\nf = 0\nresults &lt;- list()\ngo_all &lt;- data.frame()\ndown_res_ALL &lt;- res_sig[res_sig$log2FoldChange &lt; 0,]\nfor (comparison in levels(factor(res_sig$Group))) {\n  f = f + 1\n  print(paste(comparison))\n  \n  # Use tryCatch to handle errors\n  tryCatch({\n    ego &lt;- enrichGO(gene              = down_res_ALL[down_res_ALL$Group == comparison,]$gene,\n                    OrgDb             = org.Hs.eg.db,\n                    ont               = \"ALL\",\n                    universe = bg_genes,\n                    keyType           = \"SYMBOL\",\n                    pAdjustMethod     = \"BH\",\n                    pvalueCutoff      = 1,\n                    qvalueCutoff      = 1,\n                    readable          = T )\n    ego &lt;- simplify(ego, cutoff=0.7, by=\"p.adjust\", select_fun=min)\n    \n    results[[comparison]] &lt;- ego@result %&gt;%\n      separate(GeneRatio, into = c(\"gene_pos\", \"gene_total\"), sep = \"/\") %&gt;%\n      separate(BgRatio, into = c(\"bg_pos\", \"bg_total\"), sep = \"/\") %&gt;%\n      mutate(FC = (as.numeric(gene_pos)/as.numeric(gene_total)) /\n               (as.numeric(bg_pos)/as.numeric(bg_total)),\n             cluster = comparison) %&gt;%\n      arrange(.$p.adjust)\n    \n    results[[comparison]]$Group &lt;- comparison\n    go_all &lt;- rbind(go_all, results[[comparison]])\n    \n  }, error = function(e) {\n    # Print the error message (optional)\n    cat(\"Error occurred for\", comparison, \":\", conditionMessage(e), \"\\n\")\n    \n    # Continue with the next iteration\n    # ...\n  })\n}\n}\n\n\n\nThe All_degs file consist of the joint data.table of the DESeq2::results() output obtained for each HuMicA subset and accounting only for the significant DEGs (padj &lt; 0.05 and log2FoldChange &gt; 1).\n\n# annoatate up and downregulated DEGs\nAll_degs$direction &lt;- ifelse(All_degs$log2FoldChange&gt;0, \"up\", \"down\")\n\nAll_degs$Group &lt;- as.factor(All_degs$Group)\nAll_degs$cluster &lt;- as.factor(All_degs$cluster)\n\n# Create a data.table for upregulated and downregulated DEGs\nup_degs &lt;- All_degs[All_degs$log2FoldChange&gt;1,]\ndown_degs &lt;- All_degs[All_degs$log2FoldChange&lt; -1,]\n\n\n# Barplot\n## Upregulated\nggplot(up_degs, aes(x = Group, fill = factor(cluster, levels = c(\"Humica\",\"Homeos\", \"DAM\", \"DIM\", \"MAC\")))) +\n  geom_bar(position = position_dodge2(width = 0.9, preserve = \"single\")) +\n  scale_fill_manual(values = c(\"#255C99\",\"#efdd8d\",\"#4c934c\",\"#7570b3\",\"#937666\"))+\n  labs(x = \"Group\", y = \"Number of upregulated Genes\") +\n  geom_text(\n    aes(label = ifelse(..count.. == 0, \"\", ..count..)),  # Display label only if count is not 0\n    stat = \"count\",\n    position = position_dodge(width = 0.9),\n    vjust = -0.5,\n    size = 3\n  ) +\n  theme_classic2() + theme(legend.position = \"none\")\n\nWarning: The dot-dot notation (`..count..`) was deprecated in ggplot2 3.4.0.\nℹ Please use `after_stat(count)` instead.\n\n\n\n\n\n\n\n\n# Downregulated\nggplot(down_degs, aes(x = Group, fill = factor(cluster, levels = c(\"Humica\",\"Homeos\", \"DAM\", \"DIM\", \"MAC\")))) +\n  geom_bar(position = position_dodge2(width = 0.9, preserve = \"single\")) +\n  scale_fill_manual(values = c(\"#255C99\",\"#efdd8d\",\"#4c934c\",\"#7570b3\",\"#937666\"))+\n  labs(x = \"Group\", y = \"Number of downregulated Genes\") +\n  geom_text(\n    aes(label = ifelse(..count.. == 0, \"\", ..count..)),  # Display label only if count is not 0\n    stat = \"count\",\n    position = position_dodge(width = 0.9),\n    vjust = -0.5,\n    size = 3\n  ) +\n  theme_classic2() + theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n\n\nThe GO_all_up_sig and GO_all_down_sig files consist of the joint data.table of the enrichGO output obtained for each HuMicA and accounting only for the significant terms (p.adjust &lt; 0.05). GO terms were selected fro representation based on significance and biological relevance.\n\n# GO of upreguated DEGs\n## Plot list of selected terms\nselected_terms &lt;- c(\"dynein light intermediate chain binding\",\n                   \"proton-transporting ATP synthase complex\", \n                   \"actin binding\", \"collagen-containing extracellular matrix\", \"minus-end-directed microtubule motor activity\",\n                   \"structural constituent of ribosome\",\"ribosome assembly\",\"ATPase complex\",\n                   \"myelination\", \"myelin sheath\",\n                   \"WASH complex\",\n                   \"immune receptor activity\", \"cytokine receptor activity\",\"leukocyte migration\",\n                   \"MHC protein complex\",\n                   \"triglyceride-rich plasma lipoprotein particle\")\n\nGO_all_up_sig&lt;- GO_all_up_sig %&gt;% \n  mutate(logFC = log(FC),\n         logFDR = -log(p.adjust))\n\norder_cluster2 &lt;- c(\"Humica_AD\",\"Humica_ASD\",\"Humica_COVID-19\",\"Humica_Epilepsy\",\"Humica_LBD\", \"Humica_MS\",\n                    \"Homeos_AD\",\"Homeos_ASD\",\"Homeos_COVID-19\",\"Homeos_Epilepsy\",\"Homeos_LBD\", \"Homeos_MS\",\n                    \"DAM_AD\",\"DAM_ASD\",\"DAM_COVID-19\",\"DAM_Epilepsy\",\"DAM_LBD\", \"DAM_MS\",\n                    \"DIM_AD\",\"DIM_ASD\",\"DIM_COVID-19\",\"DIM_Epilepsy\",\"DIM_LBD\", \"DIM_MS\")\n\nggplot(GO_all_up_sig%&gt;% dplyr::filter(Description %in% selected_terms), aes(cluster2, factor(Description,levels = selected_terms), colour = logFC)) +\n  scale_x_discrete(limits=order_cluster2)+\n  scale_size_continuous(range = c(3, 9)) + \n  geom_point(aes(size = logFDR)) +\n  scale_color_gradientn(colours = c(\"lightgray\",\"#A44A3F\"))+\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))+\n  border()\n\n\n\n\n\n\n\n# Plot list of selected terms\n   \nselected_terms &lt;- c(\"ATP metabolic process\",\"locomotory behavior\",\"secretory granule lumen\",\n                       \"intrinsic apoptotic signaling pathway\",\n                       \"synapse organization\", \"synaptic membrane\",\n                       \"regulation of trans-synaptic signaling\", \n                        \"glutamatergic synapse\",\n                       \"developmental growth involved in morphogenesis\",\n                       \"amyloid-beta binding\", \"adrenergic receptor binding\", \n                       \"proton-transporting ATP synthase complex\", \"WASH complex\",\n                       \"myelin sheath\", \"oxidative phosphorylation\",\n                        \"respiratory chain complex\",\n                       \"regulation of DNA repair\", \"GTPase regulator activity\",\n                       \"MHC protein complex\")\n   \nGO_all_down_sig&lt;- GO_all_down_sig %&gt;% \n   mutate(logFC = log(FC),\n          logFDR = -log(p.adjust))\n\norder_cluster2 &lt;- c(\"Humica_AD\",\"Humica_ASD\",\"Humica_COVID-19\",\"Humica_Epilepsy\",\"Humica_LBD\", \"Humica_MS\",\n                       \"Homeos_AD\",\"Homeos_ASD\",\"Homeos_COVID-19\",\"Homeos_Epilepsy\",\"Homeos_LBD\", \"Homeos_MS\",\n                       \"DAM_AD\",\"DAM_ASD\",\"DAM_COVID-19\",\"DAM_Epilepsy\",\"DAM_LBD\", \"DAM_MS\",\n                       \"DIM_AD\",\"DIM_ASD\",\"DIM_COVID-19\",\"DIM_Epilepsy\",\"DIM_LBD\", \"DIM_MS\")\n   \nggplot(GO_all_down_sig%&gt;% dplyr::filter(Description %in% selected_terms), aes(cluster2, factor(Description,levels = selected_terms), colour = logFC)) +\n     scale_x_discrete(limits=order_cluster2)+\n     scale_size_continuous(range = c(3, 9)) + \n     geom_point(aes(size = logFDR)) +\n     scale_color_gradientn(colours = c(\"lightgray\",\"#A44A3F\"))+\n     #theme_pubr() + \n     theme(axis.text.x = element_text(angle = 45, hjust = 1))+\n     border()\n\n\n\n\n\n\n\n\n\n\n\n\nThe significance of the overlap between the obtained DEGs was performing using the GeneOverlap package. The analysis was performed per HuMicA subset (comparing pathogies), related to Figure 5 B, and per pathology (comparing HuMicA subsets), related to Supplementary Figure 9. One example is presented bellow.\n\n# Upregulated DEGs in the full HuMicA object (background with 17943 genes)\nHumica_degs &lt;- All_degs[All_degs$cluster==\"DAM\",]\n\nup_Humica_degs &lt;- Humica_degs[Humica_degs$log2FoldChange&lt;0,]\n\n# Create lists of DEGs per pathology\nAD_up_Humica_degs &lt;- up_Humica_degs[up_Humica_degs$Group==\"AD\",]$gene \nASD_up_Humica_degs &lt;- up_Humica_degs[up_Humica_degs$Group==\"ASD\",]$gene\nCV19_up_Humica_degs &lt;- up_Humica_degs[up_Humica_degs$Group==\"COVID-19\",]$gene\nEpilepsy_up_Humica_degs &lt;- up_Humica_degs[up_Humica_degs$Group==\"Epilepsy\",]$gene\nLBD_up_Humica_degs &lt;- up_Humica_degs[up_Humica_degs$Group==\"LBD\",]$gene\nMS_up_Humica_degs &lt;- up_Humica_degs[up_Humica_degs$Group==\"MS\",]$gene\n\nHumica_degs_up_list &lt;- setNames(list(AD_up_Humica_degs,ASD_up_Humica_degs,CV19_up_Humica_degs,\n                                     Epilepsy_up_Humica_degs,LBD_up_Humica_degs,MS_up_Humica_degs),\n                                c(\"AD_up_Humica_degs\",\"ASD_up_Humica_degs\",\"CV19_up_Humica_degs\",\n                                  \"Epilepsy_up_Humica_degs\",\"LBD_up_Humica_degs\",\"MS_up_Humica_degs\"))\n\n\n# Calculate significance of the overlap based on the Jaccard index and the p value (in the figures, the * asterisck identifies overlaps with p &lt; 0.05)\ngom.obj &lt;- newGOM(Humica_degs_up_list,genome.size = 17943)\n\nHumica_mat_jaccard &lt;- getMatrix(gom.obj, \"Jaccard\")\nHumica_mat_p &lt;- getMatrix(gom.obj, \"pval\")\n\ncol_fun = colorRamp2(c(0,0.05,0.10,0.15,0.25), c(\"#00112b\",\"#185C5C\", \"#1f948cff\",\"#B4D650\",\"#FFDD55\"))\n\nHeatmap(Humica_mat_jaccard %&gt;% as.matrix(), cluster_columns = F, cluster_rows = F, col=col_fun)"
  },
  {
    "objectID": "01. Individual dataset processing.html",
    "href": "01. Individual dataset processing.html",
    "title": "Individual dataset processing",
    "section": "",
    "text": "The following script was applied to the Grubman dataset, which consists of single-nucleus (sn)RNA-seq in postmortem entorhinal cortex from six healthy controls and six patients with Alzheimer’s Disease (AD).\nThe data was accessed as a preprocessed count matrix and a covariare matrix, both available at GEO (GSE138852).\n\n\n\nlibs &lt;- c(\"Seurat\", \"tidyverse\", \"stringr\", \"data.table\", \"readxl\")\nsuppressMessages(\nsuppressWarnings(sapply(libs, require, character.only =TRUE))\n)\n\n    Seurat  tidyverse    stringr data.table     readxl \n      TRUE       TRUE       TRUE       TRUE       TRUE \n\n\n\n\n\nUpload the count matrix with 13,214 nuclei and 10,850 genes. Create Seurat object to include only genes present in at least 3 nuclei.\n\nSeurat = CreateSeuratObject(counts =count.matrix, min.cells=3)\n\n\n\n\nRemove nuclei with the following features: - Feature counts lower than 200 and higher than 5000; - UMI counts lower than 500 and higher than 20000; - Percentage of mitochondrial genes higher than 20%: - Percentage of ribosomal genes higher than 5% (only applied to snRNA-seq data).\n\n# Calculate the percentage of ribosomal genes\nC&lt;-GetAssayData(object = Seurat, slot = \"counts\")\nrb.genes &lt;- rownames(Seurat)[grep(\"^RP[SL]\",rownames(Seurat))]\npercent.ribo &lt;- colSums(C[rb.genes,])/Matrix::colSums(C)*100\nSeurat &lt;- AddMetaData(Seurat, percent.ribo, col.name = \"percent.ribo\")\n\n# Calculate thee percentage of mitochondrial genes\nSeurat[[\"percent.mt\"]] = PercentageFeatureSet(Seurat, pattern = \"^MT-\")\n\n# Filter low quality nuclei\nSeurat &lt;- subset(Seurat, subset = nFeature_RNA &gt; 200 & nFeature_RNA &lt; 5000  & nCount_RNA &gt; 500 & \n                    nCount_RNA &lt; 20000 & percent.mt &lt; 10 & percent.ribo &lt; 5)\n\nSeurat\n\nAn object of class Seurat \n10850 features across 11440 samples within 1 assay \nActive assay: RNA (10850 features, 0 variable features)\n 1 layer present: counts\n\n# check mean genes per nuclei\nmean(Seurat@meta.data$nFeature_RNA)\n\n[1] 756.6617\n\n\nThe used filtering pipeline originated a Seurat object with 11,440 nuclei, 10,850 genes and approximately 757 genes per nuclei.\n\n\n\nVisualize the number of genes and UMI counts per nuclei, and the percentage of mitochondrial and ribosomal genes as violin plots.\n\nprint(VlnPlot(Seurat, features = c(\"nFeature_RNA\", \"nCount_RNA\",\n\"percent.mt\",\"percent.ribo\"), ncol = 4))\n\nWarning: Default search for \"data\" layer in \"RNA\" assay yielded no results;\nutilizing \"counts\" layer instead.\n\n\n\n\n\n\n\n\n\nFeatureScatter representation of the association between the number of UMI counts per nuclei and the percentage of mitochondrial genes, and between UMI counts and the number of genes per nuclei.\n\nplot1 = FeatureScatter(Seurat, feature1 = \"nCount_RNA\", feature2 = \"percent.mt\")\nplot2 = FeatureScatter(Seurat, feature1 = \"nCount_RNA\", feature2 = \"nFeature_RNA\")\nprint(plot1 + plot2)\n\n\n\n\n\n\n\n\n\n\n\nThis dataset contains 3 controls and 3 patient samples, with each one being composed of two pooled individual samples.\nCreate a column in metadata (TAG) with the nuclei annotation.\n\nSeurat@meta.data$TAG &lt;- rownames(Seurat@meta.data)\n\nThe name of each sample (Sample_ID) is merged to each nuclei’s annotation. Split the sample name from the full nuclei name.\n\nx&lt;-as.data.frame(str_split_fixed(Seurat@meta.data$TAG,\"_\",2))\nSeurat@meta.data$Sample_ID &lt;- x$V2\nhead(Seurat@meta.data$Sample_ID)\n\n[1] \"AD5_AD6\" \"AD5_AD6\" \"AD5_AD6\" \"AD5_AD6\" \"AD5_AD6\" \"AD5_AD6\"\n\n\nRemove the columns on percent.ribo and percent.mt from the metadata.\n\nSeurat@meta.data &lt;- Seurat@meta.data[,-c(4,5)]\n\n\n\n\nRemove the list of genes associated with postmortem interval in bulk RNA-seq in cerebral cortex (Zhu et. al 2017; PMID: 28710439). This list (“PMI-genes.csv”) is available on the “Support data” folder from this repository.\nNote: In the original Grubman et al. study these genes had already been removed. This script was applied to all other datasets.\n\nkeep= c(!rownames(Seurat) %in% c(PMI_genes))\nSeurat&lt;- subset(x = Seurat,features =c(1:(dim(Seurat)[1]))[keep])\n\nSeurat\n\nAn object of class Seurat \n10850 features across 11440 samples within 1 assay \nActive assay: RNA (10850 features, 0 variable features)\n 1 layer present: counts\n\n# check mean genes per nuclei\nmean(Seurat@meta.data$nFeature_RNA)\n\n[1] 756.6617\n\n\n\n\n\nDoublets (n=858) had already been calculated using DoubletFinder (see script in “Double-Finder.html” in this repository). Upload a vector of nuclei (“doublets”) deemed as doublets. Plot the Seurat object highlighting the doublets.\n\nSeurat &lt;- SCTransform(Seurat, verbose = FALSE) #default variable features = 3000\nSeurat &lt;- RunPCA(Seurat, verbose = FALSE)\nSeurat &lt;- RunUMAP(Seurat, reduction = \"pca\",dims = 1:30, verbose = FALSE)\n\nDimPlot(Seurat, reduction = \"umap\", cells.highlight = doublets,pt.size = 0.1, sizes.highlight = 0.1)+ NoLegend()\n\n\n\n\n\n\n\n\nRemove the doublets from the Seurat object. The new object is composed of 10582 nuclei.\n\ntoRemove &lt;- doublets\nSeurat &lt;- Seurat[,!colnames(Seurat) %in% toRemove]\n\nSeurat\n\nAn object of class Seurat \n21700 features across 10582 samples within 2 assays \nActive assay: SCT (10850 features, 3000 variable features)\n 3 layers present: counts, data, scale.data\n 1 other assay present: RNA\n 2 dimensional reductions calculated: pca, umap\n\nmean(Seurat@meta.data$nFeature_RNA)\n\n[1] 756.4457\n\n\n\n\n\nAfter removal of the doublets, the SCT normalization is repeated and the clustering is done with FindNeighbors and FindClusters.\n\nSeurat &lt;- SCTransform(Seurat, verbose = FALSE) #default variable features = 3000\n\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\n\n\nWarning in sqrt(1/i): NaNs produced\n\n\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\n\n\nWarning in sqrt(1/i): NaNs produced\n\n\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\n\n\nWarning in sqrt(1/i): NaNs produced\n\n\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\n\n\nWarning in sqrt(1/i): NaNs produced\n\n\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\n\n\nWarning: Different cells and/or features from existing assay SCT\n\nSeurat &lt;- RunPCA(Seurat, verbose = FALSE)\nSeurat &lt;- RunUMAP(Seurat, reduction = \"pca\",dims = 1:30, verbose = FALSE)\nSeurat &lt;- FindNeighbors(Seurat, reduction = \"pca\",dims = 1:30)\nSeurat &lt;- FindClusters(Seurat,resolution = 0.05)\n\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 10582\nNumber of edges: 420910\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.9890\nNumber of communities: 8\nElapsed time: 1 seconds\n\n\nEight clusters were originated for a clustering resolution of 0.05.\n\nDimPlot(Seurat, reduction = \"umap\", label = TRUE, repel = TRUE)\n\n\n\n\n\n\n\n\nAnnotated by Sample_ID.\n\nDimPlot(Seurat, reduction = \"umap\", label = FALSE, repel = TRUE, group.by = \"Sample_ID\")\n\n\n\n\n\n\n\n\n\n\n\nUse FindAllMarkers to calculate the markers for each cluster.\n\nSeurat.markers &lt;- FindAllMarkers(Seurat, only.pos = TRUE, min.pct = 0.1, logfc.threshold = 0.25)\n\nUpload the list of canonical cell-type markers collected from the literature that is located at the “Support data” folder of this repository. Check for canonical markers within Seurat.markers.\n\nknown_markers &lt;- merge(Seurat.markers, Brain_cell_markers, by=\"gene\") \n\nCheck the expression of some canonical markers to guide cluster annotation. Script for the stacked violin plot function:\n\n## remove the x-axis text and tick\n## plot.margin to adjust the white space between each plot.\n## ... pass any arguments to VlnPlot in Seurat\nmodify_vlnplot&lt;- function(obj,\nfeature,\npt.size = 0,\nplot.margin = unit(c(-0.75, 0, -0.75, 0), \"cm\"),\n...) {\np&lt;- VlnPlot(obj, features = feature, pt.size = pt.size #,cols = UMAP_colors\n, ... ) +\nxlab(\"\") + ylab(feature) + ggtitle(\"\") +\ntheme(legend.position = \"none\",\naxis.text.x = element_blank(),\naxis.ticks.x = element_blank(),\naxis.title.y = element_text(size = rel(1), angle = 45),\naxis.text.y = element_text(size = rel(1)),\nplot.margin = plot.margin )\nreturn(p)\n}\n## extract the max value of the y axis\nextract_max&lt;- function(p){\nymax&lt;- max(ggplot_build(p)$layout$panel_scales_y[[1]]$range$range)\nreturn(ceiling(ymax))\n}\n## main function\nStackedVlnPlot&lt;- function(obj, features,\npt.size = 0,\nplot.margin = unit(c(-0.75, 0, -0.75, 0), \"cm\"),\n...) {\nplot_list&lt;- purrr::map(features, function(x) modify_vlnplot(obj = obj,feature = x, ...))\n# Add back x-axis title to bottom plot. patchwork is going to support this?\nplot_list[[length(plot_list)]]&lt;- plot_list[[length(plot_list)]] +\ntheme(axis.text.x=element_text(angle = 45, hjust = 1), axis.ticks.x = element_line())\n# change the y-axis tick to only max value\nymaxs&lt;- purrr::map_dbl(plot_list, extract_max)\nplot_list&lt;- purrr::map2(plot_list, ymaxs, function(x,y) x +\nscale_y_continuous(breaks = c(y)) +\nexpand_limits(y = y))\np&lt;- patchwork::wrap_plots(plotlist = plot_list, ncol = 1)\nreturn(p)\n}\n\nStacked violin plots\n\nmarkers&lt;- c(\"PLP1\",\"ST18\",  #OLIGO\n\"SYT1\", \"SNAP25\",           #NEURONS\n\"SLC1A2\", \"AQP4\",           #ASTROCYTES\n\"VCAN\", \"PDGFRA\",           #OPCS\n\"DOCK8\", \"P2RY12\",          #IMMUNE CELLS\n\"CLDN5\", \"FLT1\")            #ENDOT\n\nStackedVlnPlot(obj = Seurat, features = markers)\n\n\n\n\n\n\n\n\n\n\n\nMake this assessment based on the previous information.\n\nnew.cluster.ids &lt;- c(\"Oligodendrocytes\", \"Astrocytes\",\"Oligodendrocytes\",\"Oligodendrocytes\",\"OPCs\",\"Neurons\",\"Immune cells\",\"Astrocytes\")\nnames(new.cluster.ids) &lt;- levels(Seurat)\nSeurat &lt;- RenameIdents(Seurat, new.cluster.ids)\n\nFeature plot with the Module score of the expression of microglia/immune cell markers.\n\nDefaultAssay(Seurat) &lt;- \"SCT\"\nImmune_genes &lt;-c( \"P2RY12\",\"DOCK8\",\"CD74\",\"CX3CR1\",\"C1QB\",\"C3\",\"AIF1\",\"HLA-DRA\")\nSeurat &lt;- AddModuleScore(Seurat,features =list(Immune_genes),name='Immune_genes')\nFeaturePlot(Seurat, features = \"Immune_genes1\",cols = c(\"#F1EEE9\",\"#DF7861\"))\n\n\n\n\n\n\n\n\nColor the UMAP plot by cell-type.\n\nUMAP_colors&lt;-c(\"#525E75\", #Oligodendrocytes\n\"#92BA92\",                #Astrocytes\n\"#A7D2CB\",                #OPCs\n\"#F2D388\",                #Neurons\n\"#DF7861\"                 #Immune cells\n)\n\nDimPlot(Seurat, reduction = \"umap\", label = FALSE, repel = F ,cols = UMAP_colors)\n\n\n\n\n\n\n\n\n\n\n\nThe nuclei annotated as belonging to immune cells are singled-out in an individual Seurat object, consisting of 340 nuclei, to be later integrated with the other datasets to form the\nHuman Microglia Atlas (HuMicA).\n\nImmune_Seurat&lt;- Seurat[,Seurat@active.ident==\"Immune cells\"]"
  },
  {
    "objectID": "01. Individual dataset processing.html#example-for-the-grubman-et-al.-2019-dataset-pmid31768052",
    "href": "01. Individual dataset processing.html#example-for-the-grubman-et-al.-2019-dataset-pmid31768052",
    "title": "Individual dataset processing",
    "section": "",
    "text": "The following script was applied to the Grubman dataset, which consists of single-nucleus (sn)RNA-seq in postmortem entorhinal cortex from six healthy controls and six patients with Alzheimer’s Disease (AD).\nThe data was accessed as a preprocessed count matrix and a covariare matrix, both available at GEO (GSE138852).\n\n\n\nlibs &lt;- c(\"Seurat\", \"tidyverse\", \"stringr\", \"data.table\", \"readxl\")\nsuppressMessages(\nsuppressWarnings(sapply(libs, require, character.only =TRUE))\n)\n\n    Seurat  tidyverse    stringr data.table     readxl \n      TRUE       TRUE       TRUE       TRUE       TRUE \n\n\n\n\n\nUpload the count matrix with 13,214 nuclei and 10,850 genes. Create Seurat object to include only genes present in at least 3 nuclei.\n\nSeurat = CreateSeuratObject(counts =count.matrix, min.cells=3)\n\n\n\n\nRemove nuclei with the following features: - Feature counts lower than 200 and higher than 5000; - UMI counts lower than 500 and higher than 20000; - Percentage of mitochondrial genes higher than 20%: - Percentage of ribosomal genes higher than 5% (only applied to snRNA-seq data).\n\n# Calculate the percentage of ribosomal genes\nC&lt;-GetAssayData(object = Seurat, slot = \"counts\")\nrb.genes &lt;- rownames(Seurat)[grep(\"^RP[SL]\",rownames(Seurat))]\npercent.ribo &lt;- colSums(C[rb.genes,])/Matrix::colSums(C)*100\nSeurat &lt;- AddMetaData(Seurat, percent.ribo, col.name = \"percent.ribo\")\n\n# Calculate thee percentage of mitochondrial genes\nSeurat[[\"percent.mt\"]] = PercentageFeatureSet(Seurat, pattern = \"^MT-\")\n\n# Filter low quality nuclei\nSeurat &lt;- subset(Seurat, subset = nFeature_RNA &gt; 200 & nFeature_RNA &lt; 5000  & nCount_RNA &gt; 500 & \n                    nCount_RNA &lt; 20000 & percent.mt &lt; 10 & percent.ribo &lt; 5)\n\nSeurat\n\nAn object of class Seurat \n10850 features across 11440 samples within 1 assay \nActive assay: RNA (10850 features, 0 variable features)\n 1 layer present: counts\n\n# check mean genes per nuclei\nmean(Seurat@meta.data$nFeature_RNA)\n\n[1] 756.6617\n\n\nThe used filtering pipeline originated a Seurat object with 11,440 nuclei, 10,850 genes and approximately 757 genes per nuclei.\n\n\n\nVisualize the number of genes and UMI counts per nuclei, and the percentage of mitochondrial and ribosomal genes as violin plots.\n\nprint(VlnPlot(Seurat, features = c(\"nFeature_RNA\", \"nCount_RNA\",\n\"percent.mt\",\"percent.ribo\"), ncol = 4))\n\nWarning: Default search for \"data\" layer in \"RNA\" assay yielded no results;\nutilizing \"counts\" layer instead.\n\n\n\n\n\n\n\n\n\nFeatureScatter representation of the association between the number of UMI counts per nuclei and the percentage of mitochondrial genes, and between UMI counts and the number of genes per nuclei.\n\nplot1 = FeatureScatter(Seurat, feature1 = \"nCount_RNA\", feature2 = \"percent.mt\")\nplot2 = FeatureScatter(Seurat, feature1 = \"nCount_RNA\", feature2 = \"nFeature_RNA\")\nprint(plot1 + plot2)\n\n\n\n\n\n\n\n\n\n\n\nThis dataset contains 3 controls and 3 patient samples, with each one being composed of two pooled individual samples.\nCreate a column in metadata (TAG) with the nuclei annotation.\n\nSeurat@meta.data$TAG &lt;- rownames(Seurat@meta.data)\n\nThe name of each sample (Sample_ID) is merged to each nuclei’s annotation. Split the sample name from the full nuclei name.\n\nx&lt;-as.data.frame(str_split_fixed(Seurat@meta.data$TAG,\"_\",2))\nSeurat@meta.data$Sample_ID &lt;- x$V2\nhead(Seurat@meta.data$Sample_ID)\n\n[1] \"AD5_AD6\" \"AD5_AD6\" \"AD5_AD6\" \"AD5_AD6\" \"AD5_AD6\" \"AD5_AD6\"\n\n\nRemove the columns on percent.ribo and percent.mt from the metadata.\n\nSeurat@meta.data &lt;- Seurat@meta.data[,-c(4,5)]\n\n\n\n\nRemove the list of genes associated with postmortem interval in bulk RNA-seq in cerebral cortex (Zhu et. al 2017; PMID: 28710439). This list (“PMI-genes.csv”) is available on the “Support data” folder from this repository.\nNote: In the original Grubman et al. study these genes had already been removed. This script was applied to all other datasets.\n\nkeep= c(!rownames(Seurat) %in% c(PMI_genes))\nSeurat&lt;- subset(x = Seurat,features =c(1:(dim(Seurat)[1]))[keep])\n\nSeurat\n\nAn object of class Seurat \n10850 features across 11440 samples within 1 assay \nActive assay: RNA (10850 features, 0 variable features)\n 1 layer present: counts\n\n# check mean genes per nuclei\nmean(Seurat@meta.data$nFeature_RNA)\n\n[1] 756.6617\n\n\n\n\n\nDoublets (n=858) had already been calculated using DoubletFinder (see script in “Double-Finder.html” in this repository). Upload a vector of nuclei (“doublets”) deemed as doublets. Plot the Seurat object highlighting the doublets.\n\nSeurat &lt;- SCTransform(Seurat, verbose = FALSE) #default variable features = 3000\nSeurat &lt;- RunPCA(Seurat, verbose = FALSE)\nSeurat &lt;- RunUMAP(Seurat, reduction = \"pca\",dims = 1:30, verbose = FALSE)\n\nDimPlot(Seurat, reduction = \"umap\", cells.highlight = doublets,pt.size = 0.1, sizes.highlight = 0.1)+ NoLegend()\n\n\n\n\n\n\n\n\nRemove the doublets from the Seurat object. The new object is composed of 10582 nuclei.\n\ntoRemove &lt;- doublets\nSeurat &lt;- Seurat[,!colnames(Seurat) %in% toRemove]\n\nSeurat\n\nAn object of class Seurat \n21700 features across 10582 samples within 2 assays \nActive assay: SCT (10850 features, 3000 variable features)\n 3 layers present: counts, data, scale.data\n 1 other assay present: RNA\n 2 dimensional reductions calculated: pca, umap\n\nmean(Seurat@meta.data$nFeature_RNA)\n\n[1] 756.4457\n\n\n\n\n\nAfter removal of the doublets, the SCT normalization is repeated and the clustering is done with FindNeighbors and FindClusters.\n\nSeurat &lt;- SCTransform(Seurat, verbose = FALSE) #default variable features = 3000\n\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\n\n\nWarning in sqrt(1/i): NaNs produced\n\n\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\n\n\nWarning in sqrt(1/i): NaNs produced\n\n\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\n\n\nWarning in sqrt(1/i): NaNs produced\n\n\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\n\n\nWarning in sqrt(1/i): NaNs produced\n\n\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\n\n\nWarning: Different cells and/or features from existing assay SCT\n\nSeurat &lt;- RunPCA(Seurat, verbose = FALSE)\nSeurat &lt;- RunUMAP(Seurat, reduction = \"pca\",dims = 1:30, verbose = FALSE)\nSeurat &lt;- FindNeighbors(Seurat, reduction = \"pca\",dims = 1:30)\nSeurat &lt;- FindClusters(Seurat,resolution = 0.05)\n\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 10582\nNumber of edges: 420910\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.9890\nNumber of communities: 8\nElapsed time: 1 seconds\n\n\nEight clusters were originated for a clustering resolution of 0.05.\n\nDimPlot(Seurat, reduction = \"umap\", label = TRUE, repel = TRUE)\n\n\n\n\n\n\n\n\nAnnotated by Sample_ID.\n\nDimPlot(Seurat, reduction = \"umap\", label = FALSE, repel = TRUE, group.by = \"Sample_ID\")\n\n\n\n\n\n\n\n\n\n\n\nUse FindAllMarkers to calculate the markers for each cluster.\n\nSeurat.markers &lt;- FindAllMarkers(Seurat, only.pos = TRUE, min.pct = 0.1, logfc.threshold = 0.25)\n\nUpload the list of canonical cell-type markers collected from the literature that is located at the “Support data” folder of this repository. Check for canonical markers within Seurat.markers.\n\nknown_markers &lt;- merge(Seurat.markers, Brain_cell_markers, by=\"gene\") \n\nCheck the expression of some canonical markers to guide cluster annotation. Script for the stacked violin plot function:\n\n## remove the x-axis text and tick\n## plot.margin to adjust the white space between each plot.\n## ... pass any arguments to VlnPlot in Seurat\nmodify_vlnplot&lt;- function(obj,\nfeature,\npt.size = 0,\nplot.margin = unit(c(-0.75, 0, -0.75, 0), \"cm\"),\n...) {\np&lt;- VlnPlot(obj, features = feature, pt.size = pt.size #,cols = UMAP_colors\n, ... ) +\nxlab(\"\") + ylab(feature) + ggtitle(\"\") +\ntheme(legend.position = \"none\",\naxis.text.x = element_blank(),\naxis.ticks.x = element_blank(),\naxis.title.y = element_text(size = rel(1), angle = 45),\naxis.text.y = element_text(size = rel(1)),\nplot.margin = plot.margin )\nreturn(p)\n}\n## extract the max value of the y axis\nextract_max&lt;- function(p){\nymax&lt;- max(ggplot_build(p)$layout$panel_scales_y[[1]]$range$range)\nreturn(ceiling(ymax))\n}\n## main function\nStackedVlnPlot&lt;- function(obj, features,\npt.size = 0,\nplot.margin = unit(c(-0.75, 0, -0.75, 0), \"cm\"),\n...) {\nplot_list&lt;- purrr::map(features, function(x) modify_vlnplot(obj = obj,feature = x, ...))\n# Add back x-axis title to bottom plot. patchwork is going to support this?\nplot_list[[length(plot_list)]]&lt;- plot_list[[length(plot_list)]] +\ntheme(axis.text.x=element_text(angle = 45, hjust = 1), axis.ticks.x = element_line())\n# change the y-axis tick to only max value\nymaxs&lt;- purrr::map_dbl(plot_list, extract_max)\nplot_list&lt;- purrr::map2(plot_list, ymaxs, function(x,y) x +\nscale_y_continuous(breaks = c(y)) +\nexpand_limits(y = y))\np&lt;- patchwork::wrap_plots(plotlist = plot_list, ncol = 1)\nreturn(p)\n}\n\nStacked violin plots\n\nmarkers&lt;- c(\"PLP1\",\"ST18\",  #OLIGO\n\"SYT1\", \"SNAP25\",           #NEURONS\n\"SLC1A2\", \"AQP4\",           #ASTROCYTES\n\"VCAN\", \"PDGFRA\",           #OPCS\n\"DOCK8\", \"P2RY12\",          #IMMUNE CELLS\n\"CLDN5\", \"FLT1\")            #ENDOT\n\nStackedVlnPlot(obj = Seurat, features = markers)\n\n\n\n\n\n\n\n\n\n\n\nMake this assessment based on the previous information.\n\nnew.cluster.ids &lt;- c(\"Oligodendrocytes\", \"Astrocytes\",\"Oligodendrocytes\",\"Oligodendrocytes\",\"OPCs\",\"Neurons\",\"Immune cells\",\"Astrocytes\")\nnames(new.cluster.ids) &lt;- levels(Seurat)\nSeurat &lt;- RenameIdents(Seurat, new.cluster.ids)\n\nFeature plot with the Module score of the expression of microglia/immune cell markers.\n\nDefaultAssay(Seurat) &lt;- \"SCT\"\nImmune_genes &lt;-c( \"P2RY12\",\"DOCK8\",\"CD74\",\"CX3CR1\",\"C1QB\",\"C3\",\"AIF1\",\"HLA-DRA\")\nSeurat &lt;- AddModuleScore(Seurat,features =list(Immune_genes),name='Immune_genes')\nFeaturePlot(Seurat, features = \"Immune_genes1\",cols = c(\"#F1EEE9\",\"#DF7861\"))\n\n\n\n\n\n\n\n\nColor the UMAP plot by cell-type.\n\nUMAP_colors&lt;-c(\"#525E75\", #Oligodendrocytes\n\"#92BA92\",                #Astrocytes\n\"#A7D2CB\",                #OPCs\n\"#F2D388\",                #Neurons\n\"#DF7861\"                 #Immune cells\n)\n\nDimPlot(Seurat, reduction = \"umap\", label = FALSE, repel = F ,cols = UMAP_colors)\n\n\n\n\n\n\n\n\n\n\n\nThe nuclei annotated as belonging to immune cells are singled-out in an individual Seurat object, consisting of 340 nuclei, to be later integrated with the other datasets to form the\nHuman Microglia Atlas (HuMicA).\n\nImmune_Seurat&lt;- Seurat[,Seurat@active.ident==\"Immune cells\"]"
  },
  {
    "objectID": "01. Individual dataset processing.html#check-for-outlier-samples",
    "href": "01. Individual dataset processing.html#check-for-outlier-samples",
    "title": "Individual dataset processing",
    "section": "Check for outlier samples",
    "text": "Check for outlier samples\nThe last step consist on verifying if any of the samples within the filtered object shows an unbalanced number of nuclei. In this case, all samples have an approximate number of nuclei. Therefore, all were included in the final integration.\n\nmd &lt;- Immune_Seurat@meta.data %&gt;% as.data.table\nCell_number_subject &lt;- md[, .N, by = c(\"Sample_ID\")]\nCell_number_subject\n\n   Sample_ID     N\n      &lt;char&gt; &lt;int&gt;\n1:   AD5_AD6    29\n2:   AD3_AD4    84\n3:   Ct5_Ct6    55\n4:   Ct3_Ct4    83\n5:   Ct1_Ct2    39\n6:   AD1_AD2    45"
  },
  {
    "objectID": "02. Doublet-Finder.html",
    "href": "02. Doublet-Finder.html",
    "title": "Doublet finder",
    "section": "",
    "text": "The following script consists of the pipeline used to identify potential doublets with the DoubletFinder package (https://github.com/chris-mcginnis-ucsf/DoubletFinder), applied to the Grubman dataset (GSE138852).\n\n\n\nlibs &lt;- c(\"Seurat\", \"DoubletFinder\")\nsuppressMessages(\nsuppressWarnings(sapply(libs, require, character.only =TRUE))\n)\n\n       Seurat DoubletFinder \n         TRUE         FALSE \n\n\n\n\n\nTo estimate doublets within each individual sample, the complete Seurat object of the dataset is subsetted per sample before running DoubletFinder. The Seurat object used consist of the processed object from the Grubman dataset after exclusion of the genes associated with postmortem interval (PMI) (see “Individual dataset processing.html” in this repository).\n\nmylist &lt;- unique(Seurat@meta.data$Subject)\n\nfor (i in 1:length(mylist)) {\n  \n  Seurat_sample &lt;- Seurat[,Seurat@meta.data$Subject==mylist[i]]\n  \n  # run sctransform\n  Seurat_sample &lt;- SCTransform(Seurat_sample, verbose = FALSE, conserve.memory = FALSE) #defaul variable features = 3000\n  \n  # Perform linear dimensiona reduction\n  Seurat_sample &lt;- RunPCA(Seurat_sample, verbose = FALSE)\n  \n  #Dimensionality reduction and clustering\n  \n  Seurat_sample &lt;- RunUMAP(Seurat_sample,  reduction = \"pca\",dims = 1:30, verbose = FALSE)\n  Seurat_sample &lt;- FindNeighbors(Seurat_sample,  reduction = \"pca\",dims = 1:30)\n  Seurat_sample &lt;- FindClusters(Seurat_sample,resolution = 0.02) #low clustering resolution\n  \n  ## pK Identification (no ground-truth) ---------------------------------------------------------------------------------------\n  sweep.res.list_Seurat &lt;- paramSweep_v3(Seurat_sample, PCs = 1:10, sct = T)\n  sweep.stats_Seurat &lt;- summarizeSweep(sweep.res.list_Seurat, GT = FALSE)\n  bcmvn_Seurat &lt;- find.pK(sweep.stats_Seurat)\n  df &lt;- bcmvn_Seurat[which.max(bcmvn_Seurat$BCmetric),]\n  \n  max &lt;- as.character(df[,\"pK\"])\n  \n  ## Homotypic Doublet Proportion Estimate -------------------------------------------------------------------------------------\n  annotations &lt;- Seurat_sample@meta.data$SCT_snn_res.0.02 \n  homotypic.prop &lt;- modelHomotypic(annotations)           ## annotations consist of the calculated clusters\n  nExp_poi &lt;- round(0.075*nrow(Seurat_sample@meta.data))  ## Assuming 7.5% doublet formation rate\n  nExp_poi.adj &lt;- round(nExp_poi*(1-homotypic.prop))\n  \n  ## Run DoubletFinder with varying classification stringencies ----------------------------------------------------------------\n  Seurat_sample &lt;- doubletFinder_v3(Seurat_sample, PCs = 1:10, pN = 0.25, pK = as.numeric(max), nExp = nExp_poi, reuse.pANN = FALSE, sct = T)\n  colnames(Seurat_sample@meta.data)[ncol(Seurat_sample@meta.data)] &lt;- \"DoubletFinder\"\n  \n  doublet_nuclei &lt;- row.names(Seurat_sample@meta.data[Seurat_sample@meta.data$DoubletFinder==\"Doublet\",])\n  write.csv(doublet_nuclei, paste0(\"Doublets_\",mylist[i],\".csv\"), row.names = F) #create a csv file with the identified doubles for each sample\n}"
  },
  {
    "objectID": "02. Doublet-Finder.html#example-for-the-grubman-et-al.-2019-dataset-pmid31768052",
    "href": "02. Doublet-Finder.html#example-for-the-grubman-et-al.-2019-dataset-pmid31768052",
    "title": "Doublet finder",
    "section": "",
    "text": "The following script consists of the pipeline used to identify potential doublets with the DoubletFinder package (https://github.com/chris-mcginnis-ucsf/DoubletFinder), applied to the Grubman dataset (GSE138852).\n\n\n\nlibs &lt;- c(\"Seurat\", \"DoubletFinder\")\nsuppressMessages(\nsuppressWarnings(sapply(libs, require, character.only =TRUE))\n)\n\n       Seurat DoubletFinder \n         TRUE         FALSE \n\n\n\n\n\nTo estimate doublets within each individual sample, the complete Seurat object of the dataset is subsetted per sample before running DoubletFinder. The Seurat object used consist of the processed object from the Grubman dataset after exclusion of the genes associated with postmortem interval (PMI) (see “Individual dataset processing.html” in this repository).\n\nmylist &lt;- unique(Seurat@meta.data$Subject)\n\nfor (i in 1:length(mylist)) {\n  \n  Seurat_sample &lt;- Seurat[,Seurat@meta.data$Subject==mylist[i]]\n  \n  # run sctransform\n  Seurat_sample &lt;- SCTransform(Seurat_sample, verbose = FALSE, conserve.memory = FALSE) #defaul variable features = 3000\n  \n  # Perform linear dimensiona reduction\n  Seurat_sample &lt;- RunPCA(Seurat_sample, verbose = FALSE)\n  \n  #Dimensionality reduction and clustering\n  \n  Seurat_sample &lt;- RunUMAP(Seurat_sample,  reduction = \"pca\",dims = 1:30, verbose = FALSE)\n  Seurat_sample &lt;- FindNeighbors(Seurat_sample,  reduction = \"pca\",dims = 1:30)\n  Seurat_sample &lt;- FindClusters(Seurat_sample,resolution = 0.02) #low clustering resolution\n  \n  ## pK Identification (no ground-truth) ---------------------------------------------------------------------------------------\n  sweep.res.list_Seurat &lt;- paramSweep_v3(Seurat_sample, PCs = 1:10, sct = T)\n  sweep.stats_Seurat &lt;- summarizeSweep(sweep.res.list_Seurat, GT = FALSE)\n  bcmvn_Seurat &lt;- find.pK(sweep.stats_Seurat)\n  df &lt;- bcmvn_Seurat[which.max(bcmvn_Seurat$BCmetric),]\n  \n  max &lt;- as.character(df[,\"pK\"])\n  \n  ## Homotypic Doublet Proportion Estimate -------------------------------------------------------------------------------------\n  annotations &lt;- Seurat_sample@meta.data$SCT_snn_res.0.02 \n  homotypic.prop &lt;- modelHomotypic(annotations)           ## annotations consist of the calculated clusters\n  nExp_poi &lt;- round(0.075*nrow(Seurat_sample@meta.data))  ## Assuming 7.5% doublet formation rate\n  nExp_poi.adj &lt;- round(nExp_poi*(1-homotypic.prop))\n  \n  ## Run DoubletFinder with varying classification stringencies ----------------------------------------------------------------\n  Seurat_sample &lt;- doubletFinder_v3(Seurat_sample, PCs = 1:10, pN = 0.25, pK = as.numeric(max), nExp = nExp_poi, reuse.pANN = FALSE, sct = T)\n  colnames(Seurat_sample@meta.data)[ncol(Seurat_sample@meta.data)] &lt;- \"DoubletFinder\"\n  \n  doublet_nuclei &lt;- row.names(Seurat_sample@meta.data[Seurat_sample@meta.data$DoubletFinder==\"Doublet\",])\n  write.csv(doublet_nuclei, paste0(\"Doublets_\",mylist[i],\".csv\"), row.names = F) #create a csv file with the identified doubles for each sample\n}"
  },
  {
    "objectID": "03. Integration.html",
    "href": "03. Integration.html",
    "title": "Integration",
    "section": "",
    "text": "We used the subsetted Seurat objects of immune cells from each of the nineteen datasets integrated in the Human Microglia Atlas (HuMicA). The preprocessing and normalization pipelines were based on SCTransform normaliztion (see “Individual dataset processing.html” in this repository).\n\n\nThe integration and posterior analysis were performed with Seurat v5.\n\nlibs &lt;- c(\"Seurat\", \"tidyverse\")\nsuppressMessages(\nsuppressWarnings(sapply(libs, require, character.only =TRUE))\n)\n\n   Seurat tidyverse \n     TRUE      TRUE \n\n\n\n\n\nEach dataset consists of the immune cell populations of the respective datasets.\n\nlist &lt;- list(MG_Mathys, MG_Grubman, MG_Lau, MG_Morabito, MG_Leng, MG_Zhou, MG_Pappalardo, MG_Thrupp,\n             MG_Jakel, MG_Schirmer, MG_Velmeshev, MG_Feleke, MG_Tran, MG_Franjic, MG_Yang, MG_Fullard, \n             MG_Mancuso, MG_Olah, MG_Smajic)\n\n\nlist &lt;- lapply(X = list, FUN = SCTransform)\n\nfeatures &lt;- SelectIntegrationFeatures(object.list = list, nfeatures = 3000)\n\nlist &lt;- PrepSCTIntegration(object.list = list, anchor.features = features)\n\nanchors &lt;- FindIntegrationAnchors(object.list = list, normalization.method = \"SCT\",\n                                  anchor.features = features, dims=1:20)\n\ncombined.sct &lt;- IntegrateData(anchorset = anchors, normalization.method = \"SCT\",dims=1:20,features.to.integrate =anchors@anchor.features,\n                              preserve.order = TRUE)"
  },
  {
    "objectID": "03. Integration.html#integration-pipeline-with-sctransform-normalized-datasets",
    "href": "03. Integration.html#integration-pipeline-with-sctransform-normalized-datasets",
    "title": "Integration",
    "section": "",
    "text": "We used the subsetted Seurat objects of immune cells from each of the nineteen datasets integrated in the Human Microglia Atlas (HuMicA). The preprocessing and normalization pipelines were based on SCTransform normaliztion (see “Individual dataset processing.html” in this repository).\n\n\nThe integration and posterior analysis were performed with Seurat v5.\n\nlibs &lt;- c(\"Seurat\", \"tidyverse\")\nsuppressMessages(\nsuppressWarnings(sapply(libs, require, character.only =TRUE))\n)\n\n   Seurat tidyverse \n     TRUE      TRUE \n\n\n\n\n\nEach dataset consists of the immune cell populations of the respective datasets.\n\nlist &lt;- list(MG_Mathys, MG_Grubman, MG_Lau, MG_Morabito, MG_Leng, MG_Zhou, MG_Pappalardo, MG_Thrupp,\n             MG_Jakel, MG_Schirmer, MG_Velmeshev, MG_Feleke, MG_Tran, MG_Franjic, MG_Yang, MG_Fullard, \n             MG_Mancuso, MG_Olah, MG_Smajic)\n\n\nlist &lt;- lapply(X = list, FUN = SCTransform)\n\nfeatures &lt;- SelectIntegrationFeatures(object.list = list, nfeatures = 3000)\n\nlist &lt;- PrepSCTIntegration(object.list = list, anchor.features = features)\n\nanchors &lt;- FindIntegrationAnchors(object.list = list, normalization.method = \"SCT\",\n                                  anchor.features = features, dims=1:20)\n\ncombined.sct &lt;- IntegrateData(anchorset = anchors, normalization.method = \"SCT\",dims=1:20,features.to.integrate =anchors@anchor.features,\n                              preserve.order = TRUE)"
  },
  {
    "objectID": "RNAscope quantification.html",
    "href": "RNAscope quantification.html",
    "title": "RNAscope",
    "section": "",
    "text": "The following script depicts the quantification of P2RY12 and GPNMB RNA positive dots within IBA1+ cells, as well as the number, mean and max length of branches per IBA1+ cells. The script was run on Fiji (ImageJ 1.54f).\n\n########################################################################################################\n##\n##  Analysis of RNAScope points in Iba1-positive single cells\n##\n##  Cristina de Dios - Marta Valeri\n##  Microscopy Platform - High Technology Unit - Vall d'Hebron Research Institute (UAT-VHIR)\n##  Contact: microscopia@vhir.org\n##\n########################################################################################################\n\n## Requirements: MorpholibJ should be pre-installed before running the script. To install MorpholibJ, go to\n## Help &gt; Update &gt; Manage Update Sites and select IJBP-Plugins. Restart ImageJ after installation.\n\n## Adjustable parameters\n\npos_condition = newArray(\"Control\", \"AD\", \"MS\", \"PD\");      ## Possible groups#conditions on your experiment\nred_prom = 1000;        ## Prominence to use for red points count. Modify sensibly considering channel fluorescence and differences in signal-background fluorescence \nfar_red_prom = 1000;        ## Prominence to use for red points count. Modify sensibly considering channel fluorescence and differences in signal-background fluorescence\nfilename_end_regex = \"Focus.czi\";       ## Regular expression used for recognition of Z-projected images. Filenames must include Z-projection tag (e.g. \"Focus\" in \"Extended Depth of Focus\" for Zeiss LSM980 microscope) and file extension at the end of the filename\nautom_nuc_prominence = 750;     ## Prominence to use in the nuclei channel for automatic cell selection. Note this value is set after applying Gaussian filter (sigma=10) to the nuclei channel \n\n## Inicialization\n\nclose(\"*\");\nclose(\"ROI Manager\");\nrun(\"Set Measurements...\", \"area min redirect=None decimal=3\");\n\n## Essential global variables\ntitle_array = newArray();\ncondition_array = newArray();\nredpos_cells_array = newArray();\nfarpos_cells_array = newArray();\ndoublepos_cells_array = newArray();\navg_redpoints_percell_array = newArray();\navg_farpoints_percell_array = newArray();\navg_skelmax_array = newArray();\navg_skelmean_array = newArray();\navg_skelbranch_array = newArray();\n##setBatchMode(true);\n\n## Selecting projected images\n\ndir = getDir(\"Choose image folder\");\nresults_dir = dir + \"#Results#\";\nselected_dir =  dir + \"#Selection#\";\nFile.makeDirectory(results_dir);\nFile.makeDirectory(selected_dir);\nfilelist = getFileList(dir); \n\n## Selecting region segmentation method\n\nDialog.create(\"Nucleated Regions Selection\");\nDialog.addMessage(\"Select how you want to select nucleated regions:\\n \\n- Automatically (nuclei maxima overlap)\\n- Semi-automatically (point selection overlap)\\n \\nPlease, take into account that if nucleus does not overlap selection will not be properly done\\n \\n\"); \nDialog.addChoice(\"Select option\", newArray(\"Semi-automatic selection (recommended)\", \"Automatic Selection\"), \"Semi-automatic selection (recommended)\");\nDialog.show();\nchoice = Dialog.getChoice();\n\n## Iteration for every image\nfor (i = 0; i &lt; lengthOf(filelist); i++) {\n    if (endsWith(filelist[i], filename_end_regex)) { \n        ## Essential local variables (reset for every image)\n        label_array = newArray();\n        redpoints_percell_array = newArray();\n        farpoints_percell_array = newArray();\n        nuc_percell_array = newArray();\n        relat_redpoints_percell_array = newArray();\n        relat_farpoints_percell_array = newArray();\n        skel_numbranch_percell_array = newArray();\n        skel_meanlength_percell_array = newArray();\n        skel_maxlength_percell_array = newArray();\n        red_counter = 0;\n        far_red_counter = 0;\n        double_counter = 0;\n        classification_array = newArray();\n        run(\"Bio-Formats Importer\", \"open=[\" + dir + filelist[i] + \"] autoscale color_mode=Default rois_import=[ROI manager] view=Hyperstack stack_order=XYCZT\");\n        img_title = filelist[i];\n        title_array = Array.concat(title_array, img_title);\n        for (j = 0; j &lt; lengthOf(pos_condition); j++) {\n            if (matches(img_title.toUpperCase, \".*\" + pos_condition[j].toUpperCase + \".*\")) {\n                condition_array = Array.concat(condition_array, pos_condition[j]);\n            }\n        }   \n        run(\"Split Channels\");\n        selectImage(\"C3-\" + filelist[i]);\n        run(\"Duplicate...\", \"title=iba1_original\");\n        selectImage(\"C4-\" + filelist[i]);\n        run(\"Duplicate...\", \"title=nuclei_master\");\n        selectImage(\"C3-\" + filelist[i]);\n        \n        ## Binarization\n        setAutoThreshold(\"Huang dark\");\n        ##run(\"Threshold...\");\n        setOption(\"BlackBackground\", true);\n        run(\"Convert to Mask\");\n        \n        ## Mask perfectioning\n        run(\"Fill Holes\");\n        run(\"Options...\", \"iterations=10 count=4 black do=Erode\");\n        run(\"Analyze Particles...\", \"size=5-Infinity show=Masks\");\n        selectImage(\"Mask of C3-\" + filelist[i]);\n        rename(\"iba1\");\n        \n        ##Skeletonization for microglial morphology\n        run(\"Duplicate...\", \"title=iba1_skel\");\n        run(\"Invert LUT\");\n        run(\"Skeletonize\");\n        rename(\"iba1_skel\");\n        \n        ## Retrieval of selection coordinates\n        nucleated_cells = \"\";\n        if (choice == \"Automatic Selection\") {\n            selectImage(\"C4-\" + filelist[i]);\n            run(\"Duplicate...\", \"title=nuclei\");\n            selectImage(\"C4-\" + filelist[i]);\n            run(\"Gaussian Blur...\", \"sigma=10\");\n            run(\"Find Maxima...\", \"prominence=\"+d2s(autom_nuc_prominence, 0)+\" output=List\");\n            selectWindow(\"Results\");\n            y_coords = Table.getColumn(\"Y\");\n            x_coords = Table.getColumn(\"X\");\n            close(\"Results\");\n    \n            for (k = 0; k &lt; lengthOf(y_coords); k++) {\n                x_coords_def = newArray();\n                y_coords_def = newArray();\n                selectImage(\"iba1\");\n                coord_label = getPixel(x_coords[k], y_coords[k]);\n                if (coord_label != 0) {\n                    x_coords_def = Array.concat(x_coords_def, x_coords[k]);\n                    y_coords_def = Array.concat(y_coords_def, y_coords[k]);\n                }\n            }\n            if (nucleated_cells == \"\") {\n                x_coords_def = newArray();\n                y_coords_def = newArray();\n                waitForUser(\"No Iba1-positive regions overlapping with nuclei maxima were found. Moving on to semi-automatic selection\");\n                run(\"Merge Channels...\", \"c1=iba1 c2=nuclei c3=iba1_original c4=[C1-\" + filelist[i] + \"] c5=[C2-\" + filelist[i] + \"] create keep\");\n                setTool(7);\n                setBatchMode(\"exit and display\");\n                waitForUser(\"- Select cells with nucleus. When done, click OK\");\n                getSelectionCoordinates(xpoints, ypoints);\n                x_coords_def = Array.concat(x_coords_def, xpoints);\n                y_coords_def = Array.concat(y_coords_def, ypoints);\n                selectImage(\"iba1\");\n                setBatchMode(true);\n            }\n        }\n\n        if (choice == \"Semi-automatic selection (recommended)\") {\n            x_coords_def = newArray();\n            y_coords_def = newArray();\n            selectImage(\"iba1\");\n            run(\"16-bit\");\n            run(\"Red\");\n            run(\"Merge Channels...\", \"c1=iba1 c2=[C4-\" + filelist[i] + \"] c3=iba1_original c4=[C1-\" + filelist[i] + \"] c5=[C2-\" + filelist[i] + \"] create keep\");\n            setTool(7);\n            setBatchMode(\"exit and display\");\n            waitForUser(\"- Select cells with nucleus. When done, click OK\");\n            getSelectionCoordinates(xpoints, ypoints);\n            x_coords_def = Array.concat(x_coords_def, xpoints);\n            y_coords_def = Array.concat(y_coords_def, ypoints);\n            selectImage(\"iba1\");\n            setBatchMode(true);\n        }\n        ## Creation of green + nuclei mask\n        selectImage(\"nuclei_master\");\n        ##run(\"Threshold...\");\n        setAutoThreshold(\"MaxEntropy dark no-reset\");\n        setOption(\"BlackBackground\", true);\n        run(\"Convert to Mask\");\n        run(\"Fill Holes\");\n        run(\"Options...\", \"iterations=10 count=4 black do=Erode\");\n        run(\"Analyze Particles...\", \"size=20.00-Infinity show=Masks\");\n        rename(\"nuclei_binary\");\n        imageCalculator(\"Add create\", \"nuclei_binary\", \"iba1\");\n        rename(\"combined\");\n        close(\"iba1\");\n        selectImage(\"combined\");\n        run(\"Connected Components Labeling\", \"connectivity=4 type=[16 bits]\");\n        close(\"combined\");\n        selectImage(\"combined-lbl\");\n        rename(\"combined\");\n        ## Retrieval of selection masks and inclusion in ROI Manager for analysis\n        for(j = 0; j &lt; x_coords_def.length; j++){\n            nucleated_cells = nucleated_cells + d2s(getPixel(x_coords_def[j], y_coords_def[j]),0)+\", \";\n        }\n        run(\"Select Label(s)\", \"label(s)=[\" +nucleated_cells + \"]\");\n        run(\"Remap Labels\");\n        close(\"combined\");\n        selectImage(\"combined-keepLabels\");\n        rename(\"combined\");\n        run(\"Measure\");\n        setBatchMode(true);\n        max_value = getResult(\"Max\");\n        close(\"Results\");\n        run(\"ROI Manager...\");\n        for (l = 0; l &lt; max_value; l++) {\n            setThreshold(l+1, l+1, \"raw\");\n            run(\"Create Selection\");\n            roiManager(\"Add\");\n        }\n        \n        ## Nuclei count per cell (needed for relativization in multinucleated masks)\n        selectImage(\"nuclei_binary\");\n        for (m = 0; m &lt; roiManager(\"count\"); m++) {\n            roiManager(\"select\", m);\n            run(\"Find Maxima...\", \"prominence=250 output=Count\");\n            nuc = getResult(\"Count\");\n            if (nuc == 0) {\n                nuc_percell_array = Array.concat(nuc_percell_array, 1);\n            } \n            else {\n                nuc_percell_array = Array.concat(nuc_percell_array, nuc);\n            }\n            close(\"Results\");\n        }\n        \n        ## FarRed points count\n        selectImage(\"C1-\" + filelist[i]);\n        for (m = 0; m &lt; roiManager(\"count\"); m++) {\n            label_array = Array.concat(label_array, m+1);\n            roiManager(\"select\", m);\n            run(\"Find Maxima...\", \"prominence=\"+d2s(far_red_prom, 0)+\" output=Count\");\n            far_red = getResult(\"Count\");\n            farpoints_percell_array = Array.concat(farpoints_percell_array, far_red);\n            relat_farpoints_percell_array = Array.concat(relat_farpoints_percell_array, far_red#nuc_percell_array[m]);\n            close(\"Results\");\n        }\n        \n        \n        ## Red points count\n        selectImage(\"C2-\" + filelist[i]);\n        for (m = 0; m &lt; roiManager(\"count\"); m++) {\n            roiManager(\"select\", m);\n            run(\"Find Maxima...\", \"prominence=\"+d2s(red_prom, 0)+\" output=Count\");\n            red = getResult(\"Count\");\n            redpoints_percell_array = Array.concat(redpoints_percell_array, red);\n            relat_redpoints_percell_array = Array.concat(relat_redpoints_percell_array, red#nuc_percell_array[m]);\n            close(\"Results\");\n        }\n        \n        ## Skeleton analysis (for individual label)\n        selectImage(\"iba1_skel\");\n        for (m = 0; m &lt; roiManager(\"count\"); m++) {\n            roiManager(\"select\", m);\n            run(\"Duplicate...\", \"title=iba1_skelroi\");\n            run(\"Analyze Skeleton (2D#3D)\", \"prune=none\");\n            selectWindow(\"Results\");\n            mean_branch_len = getResult(\"Average Branch Length\");\n            max_branch_len = getResult(\"Maximum Branch Length\");\n            branch_number = getResult(\"# Branches\");\n            skel_numbranch_percell_array = Array.concat(skel_numbranch_percell_array, branch_number);\n            skel_meanlength_percell_array = Array.concat(skel_meanlength_percell_array,mean_branch_len);\n            skel_maxlength_percell_array = Array.concat(skel_maxlength_percell_array, max_branch_len);\n            close(\"Tagged skeleton\");\n            close(\"iba1_skelroi\");  \n        }\n        \n        ## Getting means for summary\n        Array.getStatistics(relat_redpoints_percell_array, min, max, red_mean, stdDev);\n        Array.getStatistics(relat_farpoints_percell_array, min, max, far_mean, stdDev);\n        Array.getStatistics(skel_numbranch_percell_array, min, max, num_mean, stdDev);\n        Array.getStatistics(skel_meanlength_percell_array, min, max, mn_mean, stdDev);\n        Array.getStatistics(skel_maxlength_percell_array, min, max, mx_mean, stdDev);\n        \n        ## Cleanup\n        close(\"Results\");\n        setBatchMode(\"exit and display\");\n        close(\"ROI Manager\");\n        setBatchMode(true);\n        \n        ## Label classification criteria\n        for (p = 0; p &lt; redpoints_percell_array.length; p++) {\n            class = \"\";\n            if (redpoints_percell_array[p] &gt; 0 && farpoints_percell_array[p] == 0) {\n                class = \"Red\";\n                red_counter += 1;\n            }\n            else if (redpoints_percell_array[p] == 0 && farpoints_percell_array[p] &gt; 0) {\n                class = \"FarRed\";\n                far_red_counter += 1;\n            }\n            else if (redpoints_percell_array[p] &gt; 0 && farpoints_percell_array[p] &gt; 0) {\n                class = \"Both\";\n                double_counter += 1;\n            }\n            else {\n                class = \"None\";\n            }\n            classification_array = Array.concat(classification_array, class);\n        }\n        \n        ## Create and save table for image\n        Table.create(\"Single Microglia Analysis of RNAScope Expression of Image \" + filelist[i]);\n\n        Table.setColumn(\"Cell Label\", label_array);\n        Table.setColumn(\"# Red points\", redpoints_percell_array);\n        Table.setColumn(\"# FarRed points\", farpoints_percell_array);\n        Table.setColumn(\"# Nuclei\", farpoints_percell_array);\n        Table.setColumn(\"Positive for\", classification_array);\n        \n        saveAs(\"Results\", results_dir + filelist[i] + \".csv\");\n        close(filelist[i] + \".csv\");\n        \n        ## Save label image\n        selectImage(\"combined\");\n        run(\"Select None\");\n        saveAs(\"Tiff\", selected_dir + filelist[i] + \".tif\");\n        close(\"*\");\n        redpos_cells_array = Array.concat(redpos_cells_array, red_counter);\n        farpos_cells_array = Array.concat(farpos_cells_array, far_red_counter);\n        avg_redpoints_percell_array = Array.concat(avg_redpoints_percell_array, red_mean);\n        avg_farpoints_percell_array = Array.concat(avg_farpoints_percell_array, far_mean);\n        doublepos_cells_array = Array.concat(doublepos_cells_array, double_counter);\n        avg_skelbranch_array = Array.concat(avg_skelbranch_array, num_mean);\n        avg_skelmax_array = Array.concat(avg_skelmax_array, mx_mean);\n        avg_skelmean_array = Array.concat(avg_skelmean_array, mn_mean);\n        \n    } \n    \n\n}\n\n## Creating global summary\n\nTable.create(\"Summary of Single Microglia Analysis of RNAScope Expression\");\n\nTable.setColumn(\"Image_Title\", title_array);\nTable.setColumn(\"Group\", condition_array);\nTable.setColumn(\"Average # of Red Points per Cell\", avg_redpoints_percell_array);\nTable.setColumn(\"Average # of FarRed Points per Cell\", avg_farpoints_percell_array);\nTable.setColumn(\"# Red-Only Positive Cells\", redpos_cells_array);\nTable.setColumn(\"# FarRed-Only Positive Cells\", farpos_cells_array);\nTable.setColumn(\"# Double Positive cells\", doublepos_cells_array);\nTable.setColumn(\"Average # of Branches\", avg_skelbranch_array);\nTable.setColumn(\"Average Mean Branch Length\", avg_skelmean_array);\nTable.setColumn(\"Average Maximum Branch Length\", avg_skelmax_array);"
  },
  {
    "objectID": "RNAscope quantification.html#rnascope-quantification",
    "href": "RNAscope quantification.html#rnascope-quantification",
    "title": "RNAscope",
    "section": "",
    "text": "The following script depicts the quantification of P2RY12 and GPNMB RNA positive dots within IBA1+ cells, as well as the number, mean and max length of branches per IBA1+ cells. The script was run on Fiji (ImageJ 1.54f).\n\n########################################################################################################\n##\n##  Analysis of RNAScope points in Iba1-positive single cells\n##\n##  Cristina de Dios - Marta Valeri\n##  Microscopy Platform - High Technology Unit - Vall d'Hebron Research Institute (UAT-VHIR)\n##  Contact: microscopia@vhir.org\n##\n########################################################################################################\n\n## Requirements: MorpholibJ should be pre-installed before running the script. To install MorpholibJ, go to\n## Help &gt; Update &gt; Manage Update Sites and select IJBP-Plugins. Restart ImageJ after installation.\n\n## Adjustable parameters\n\npos_condition = newArray(\"Control\", \"AD\", \"MS\", \"PD\");      ## Possible groups#conditions on your experiment\nred_prom = 1000;        ## Prominence to use for red points count. Modify sensibly considering channel fluorescence and differences in signal-background fluorescence \nfar_red_prom = 1000;        ## Prominence to use for red points count. Modify sensibly considering channel fluorescence and differences in signal-background fluorescence\nfilename_end_regex = \"Focus.czi\";       ## Regular expression used for recognition of Z-projected images. Filenames must include Z-projection tag (e.g. \"Focus\" in \"Extended Depth of Focus\" for Zeiss LSM980 microscope) and file extension at the end of the filename\nautom_nuc_prominence = 750;     ## Prominence to use in the nuclei channel for automatic cell selection. Note this value is set after applying Gaussian filter (sigma=10) to the nuclei channel \n\n## Inicialization\n\nclose(\"*\");\nclose(\"ROI Manager\");\nrun(\"Set Measurements...\", \"area min redirect=None decimal=3\");\n\n## Essential global variables\ntitle_array = newArray();\ncondition_array = newArray();\nredpos_cells_array = newArray();\nfarpos_cells_array = newArray();\ndoublepos_cells_array = newArray();\navg_redpoints_percell_array = newArray();\navg_farpoints_percell_array = newArray();\navg_skelmax_array = newArray();\navg_skelmean_array = newArray();\navg_skelbranch_array = newArray();\n##setBatchMode(true);\n\n## Selecting projected images\n\ndir = getDir(\"Choose image folder\");\nresults_dir = dir + \"#Results#\";\nselected_dir =  dir + \"#Selection#\";\nFile.makeDirectory(results_dir);\nFile.makeDirectory(selected_dir);\nfilelist = getFileList(dir); \n\n## Selecting region segmentation method\n\nDialog.create(\"Nucleated Regions Selection\");\nDialog.addMessage(\"Select how you want to select nucleated regions:\\n \\n- Automatically (nuclei maxima overlap)\\n- Semi-automatically (point selection overlap)\\n \\nPlease, take into account that if nucleus does not overlap selection will not be properly done\\n \\n\"); \nDialog.addChoice(\"Select option\", newArray(\"Semi-automatic selection (recommended)\", \"Automatic Selection\"), \"Semi-automatic selection (recommended)\");\nDialog.show();\nchoice = Dialog.getChoice();\n\n## Iteration for every image\nfor (i = 0; i &lt; lengthOf(filelist); i++) {\n    if (endsWith(filelist[i], filename_end_regex)) { \n        ## Essential local variables (reset for every image)\n        label_array = newArray();\n        redpoints_percell_array = newArray();\n        farpoints_percell_array = newArray();\n        nuc_percell_array = newArray();\n        relat_redpoints_percell_array = newArray();\n        relat_farpoints_percell_array = newArray();\n        skel_numbranch_percell_array = newArray();\n        skel_meanlength_percell_array = newArray();\n        skel_maxlength_percell_array = newArray();\n        red_counter = 0;\n        far_red_counter = 0;\n        double_counter = 0;\n        classification_array = newArray();\n        run(\"Bio-Formats Importer\", \"open=[\" + dir + filelist[i] + \"] autoscale color_mode=Default rois_import=[ROI manager] view=Hyperstack stack_order=XYCZT\");\n        img_title = filelist[i];\n        title_array = Array.concat(title_array, img_title);\n        for (j = 0; j &lt; lengthOf(pos_condition); j++) {\n            if (matches(img_title.toUpperCase, \".*\" + pos_condition[j].toUpperCase + \".*\")) {\n                condition_array = Array.concat(condition_array, pos_condition[j]);\n            }\n        }   \n        run(\"Split Channels\");\n        selectImage(\"C3-\" + filelist[i]);\n        run(\"Duplicate...\", \"title=iba1_original\");\n        selectImage(\"C4-\" + filelist[i]);\n        run(\"Duplicate...\", \"title=nuclei_master\");\n        selectImage(\"C3-\" + filelist[i]);\n        \n        ## Binarization\n        setAutoThreshold(\"Huang dark\");\n        ##run(\"Threshold...\");\n        setOption(\"BlackBackground\", true);\n        run(\"Convert to Mask\");\n        \n        ## Mask perfectioning\n        run(\"Fill Holes\");\n        run(\"Options...\", \"iterations=10 count=4 black do=Erode\");\n        run(\"Analyze Particles...\", \"size=5-Infinity show=Masks\");\n        selectImage(\"Mask of C3-\" + filelist[i]);\n        rename(\"iba1\");\n        \n        ##Skeletonization for microglial morphology\n        run(\"Duplicate...\", \"title=iba1_skel\");\n        run(\"Invert LUT\");\n        run(\"Skeletonize\");\n        rename(\"iba1_skel\");\n        \n        ## Retrieval of selection coordinates\n        nucleated_cells = \"\";\n        if (choice == \"Automatic Selection\") {\n            selectImage(\"C4-\" + filelist[i]);\n            run(\"Duplicate...\", \"title=nuclei\");\n            selectImage(\"C4-\" + filelist[i]);\n            run(\"Gaussian Blur...\", \"sigma=10\");\n            run(\"Find Maxima...\", \"prominence=\"+d2s(autom_nuc_prominence, 0)+\" output=List\");\n            selectWindow(\"Results\");\n            y_coords = Table.getColumn(\"Y\");\n            x_coords = Table.getColumn(\"X\");\n            close(\"Results\");\n    \n            for (k = 0; k &lt; lengthOf(y_coords); k++) {\n                x_coords_def = newArray();\n                y_coords_def = newArray();\n                selectImage(\"iba1\");\n                coord_label = getPixel(x_coords[k], y_coords[k]);\n                if (coord_label != 0) {\n                    x_coords_def = Array.concat(x_coords_def, x_coords[k]);\n                    y_coords_def = Array.concat(y_coords_def, y_coords[k]);\n                }\n            }\n            if (nucleated_cells == \"\") {\n                x_coords_def = newArray();\n                y_coords_def = newArray();\n                waitForUser(\"No Iba1-positive regions overlapping with nuclei maxima were found. Moving on to semi-automatic selection\");\n                run(\"Merge Channels...\", \"c1=iba1 c2=nuclei c3=iba1_original c4=[C1-\" + filelist[i] + \"] c5=[C2-\" + filelist[i] + \"] create keep\");\n                setTool(7);\n                setBatchMode(\"exit and display\");\n                waitForUser(\"- Select cells with nucleus. When done, click OK\");\n                getSelectionCoordinates(xpoints, ypoints);\n                x_coords_def = Array.concat(x_coords_def, xpoints);\n                y_coords_def = Array.concat(y_coords_def, ypoints);\n                selectImage(\"iba1\");\n                setBatchMode(true);\n            }\n        }\n\n        if (choice == \"Semi-automatic selection (recommended)\") {\n            x_coords_def = newArray();\n            y_coords_def = newArray();\n            selectImage(\"iba1\");\n            run(\"16-bit\");\n            run(\"Red\");\n            run(\"Merge Channels...\", \"c1=iba1 c2=[C4-\" + filelist[i] + \"] c3=iba1_original c4=[C1-\" + filelist[i] + \"] c5=[C2-\" + filelist[i] + \"] create keep\");\n            setTool(7);\n            setBatchMode(\"exit and display\");\n            waitForUser(\"- Select cells with nucleus. When done, click OK\");\n            getSelectionCoordinates(xpoints, ypoints);\n            x_coords_def = Array.concat(x_coords_def, xpoints);\n            y_coords_def = Array.concat(y_coords_def, ypoints);\n            selectImage(\"iba1\");\n            setBatchMode(true);\n        }\n        ## Creation of green + nuclei mask\n        selectImage(\"nuclei_master\");\n        ##run(\"Threshold...\");\n        setAutoThreshold(\"MaxEntropy dark no-reset\");\n        setOption(\"BlackBackground\", true);\n        run(\"Convert to Mask\");\n        run(\"Fill Holes\");\n        run(\"Options...\", \"iterations=10 count=4 black do=Erode\");\n        run(\"Analyze Particles...\", \"size=20.00-Infinity show=Masks\");\n        rename(\"nuclei_binary\");\n        imageCalculator(\"Add create\", \"nuclei_binary\", \"iba1\");\n        rename(\"combined\");\n        close(\"iba1\");\n        selectImage(\"combined\");\n        run(\"Connected Components Labeling\", \"connectivity=4 type=[16 bits]\");\n        close(\"combined\");\n        selectImage(\"combined-lbl\");\n        rename(\"combined\");\n        ## Retrieval of selection masks and inclusion in ROI Manager for analysis\n        for(j = 0; j &lt; x_coords_def.length; j++){\n            nucleated_cells = nucleated_cells + d2s(getPixel(x_coords_def[j], y_coords_def[j]),0)+\", \";\n        }\n        run(\"Select Label(s)\", \"label(s)=[\" +nucleated_cells + \"]\");\n        run(\"Remap Labels\");\n        close(\"combined\");\n        selectImage(\"combined-keepLabels\");\n        rename(\"combined\");\n        run(\"Measure\");\n        setBatchMode(true);\n        max_value = getResult(\"Max\");\n        close(\"Results\");\n        run(\"ROI Manager...\");\n        for (l = 0; l &lt; max_value; l++) {\n            setThreshold(l+1, l+1, \"raw\");\n            run(\"Create Selection\");\n            roiManager(\"Add\");\n        }\n        \n        ## Nuclei count per cell (needed for relativization in multinucleated masks)\n        selectImage(\"nuclei_binary\");\n        for (m = 0; m &lt; roiManager(\"count\"); m++) {\n            roiManager(\"select\", m);\n            run(\"Find Maxima...\", \"prominence=250 output=Count\");\n            nuc = getResult(\"Count\");\n            if (nuc == 0) {\n                nuc_percell_array = Array.concat(nuc_percell_array, 1);\n            } \n            else {\n                nuc_percell_array = Array.concat(nuc_percell_array, nuc);\n            }\n            close(\"Results\");\n        }\n        \n        ## FarRed points count\n        selectImage(\"C1-\" + filelist[i]);\n        for (m = 0; m &lt; roiManager(\"count\"); m++) {\n            label_array = Array.concat(label_array, m+1);\n            roiManager(\"select\", m);\n            run(\"Find Maxima...\", \"prominence=\"+d2s(far_red_prom, 0)+\" output=Count\");\n            far_red = getResult(\"Count\");\n            farpoints_percell_array = Array.concat(farpoints_percell_array, far_red);\n            relat_farpoints_percell_array = Array.concat(relat_farpoints_percell_array, far_red#nuc_percell_array[m]);\n            close(\"Results\");\n        }\n        \n        \n        ## Red points count\n        selectImage(\"C2-\" + filelist[i]);\n        for (m = 0; m &lt; roiManager(\"count\"); m++) {\n            roiManager(\"select\", m);\n            run(\"Find Maxima...\", \"prominence=\"+d2s(red_prom, 0)+\" output=Count\");\n            red = getResult(\"Count\");\n            redpoints_percell_array = Array.concat(redpoints_percell_array, red);\n            relat_redpoints_percell_array = Array.concat(relat_redpoints_percell_array, red#nuc_percell_array[m]);\n            close(\"Results\");\n        }\n        \n        ## Skeleton analysis (for individual label)\n        selectImage(\"iba1_skel\");\n        for (m = 0; m &lt; roiManager(\"count\"); m++) {\n            roiManager(\"select\", m);\n            run(\"Duplicate...\", \"title=iba1_skelroi\");\n            run(\"Analyze Skeleton (2D#3D)\", \"prune=none\");\n            selectWindow(\"Results\");\n            mean_branch_len = getResult(\"Average Branch Length\");\n            max_branch_len = getResult(\"Maximum Branch Length\");\n            branch_number = getResult(\"# Branches\");\n            skel_numbranch_percell_array = Array.concat(skel_numbranch_percell_array, branch_number);\n            skel_meanlength_percell_array = Array.concat(skel_meanlength_percell_array,mean_branch_len);\n            skel_maxlength_percell_array = Array.concat(skel_maxlength_percell_array, max_branch_len);\n            close(\"Tagged skeleton\");\n            close(\"iba1_skelroi\");  \n        }\n        \n        ## Getting means for summary\n        Array.getStatistics(relat_redpoints_percell_array, min, max, red_mean, stdDev);\n        Array.getStatistics(relat_farpoints_percell_array, min, max, far_mean, stdDev);\n        Array.getStatistics(skel_numbranch_percell_array, min, max, num_mean, stdDev);\n        Array.getStatistics(skel_meanlength_percell_array, min, max, mn_mean, stdDev);\n        Array.getStatistics(skel_maxlength_percell_array, min, max, mx_mean, stdDev);\n        \n        ## Cleanup\n        close(\"Results\");\n        setBatchMode(\"exit and display\");\n        close(\"ROI Manager\");\n        setBatchMode(true);\n        \n        ## Label classification criteria\n        for (p = 0; p &lt; redpoints_percell_array.length; p++) {\n            class = \"\";\n            if (redpoints_percell_array[p] &gt; 0 && farpoints_percell_array[p] == 0) {\n                class = \"Red\";\n                red_counter += 1;\n            }\n            else if (redpoints_percell_array[p] == 0 && farpoints_percell_array[p] &gt; 0) {\n                class = \"FarRed\";\n                far_red_counter += 1;\n            }\n            else if (redpoints_percell_array[p] &gt; 0 && farpoints_percell_array[p] &gt; 0) {\n                class = \"Both\";\n                double_counter += 1;\n            }\n            else {\n                class = \"None\";\n            }\n            classification_array = Array.concat(classification_array, class);\n        }\n        \n        ## Create and save table for image\n        Table.create(\"Single Microglia Analysis of RNAScope Expression of Image \" + filelist[i]);\n\n        Table.setColumn(\"Cell Label\", label_array);\n        Table.setColumn(\"# Red points\", redpoints_percell_array);\n        Table.setColumn(\"# FarRed points\", farpoints_percell_array);\n        Table.setColumn(\"# Nuclei\", farpoints_percell_array);\n        Table.setColumn(\"Positive for\", classification_array);\n        \n        saveAs(\"Results\", results_dir + filelist[i] + \".csv\");\n        close(filelist[i] + \".csv\");\n        \n        ## Save label image\n        selectImage(\"combined\");\n        run(\"Select None\");\n        saveAs(\"Tiff\", selected_dir + filelist[i] + \".tif\");\n        close(\"*\");\n        redpos_cells_array = Array.concat(redpos_cells_array, red_counter);\n        farpos_cells_array = Array.concat(farpos_cells_array, far_red_counter);\n        avg_redpoints_percell_array = Array.concat(avg_redpoints_percell_array, red_mean);\n        avg_farpoints_percell_array = Array.concat(avg_farpoints_percell_array, far_mean);\n        doublepos_cells_array = Array.concat(doublepos_cells_array, double_counter);\n        avg_skelbranch_array = Array.concat(avg_skelbranch_array, num_mean);\n        avg_skelmax_array = Array.concat(avg_skelmax_array, mx_mean);\n        avg_skelmean_array = Array.concat(avg_skelmean_array, mn_mean);\n        \n    } \n    \n\n}\n\n## Creating global summary\n\nTable.create(\"Summary of Single Microglia Analysis of RNAScope Expression\");\n\nTable.setColumn(\"Image_Title\", title_array);\nTable.setColumn(\"Group\", condition_array);\nTable.setColumn(\"Average # of Red Points per Cell\", avg_redpoints_percell_array);\nTable.setColumn(\"Average # of FarRed Points per Cell\", avg_farpoints_percell_array);\nTable.setColumn(\"# Red-Only Positive Cells\", redpos_cells_array);\nTable.setColumn(\"# FarRed-Only Positive Cells\", farpos_cells_array);\nTable.setColumn(\"# Double Positive cells\", doublepos_cells_array);\nTable.setColumn(\"Average # of Branches\", avg_skelbranch_array);\nTable.setColumn(\"Average Mean Branch Length\", avg_skelmean_array);\nTable.setColumn(\"Average Maximum Branch Length\", avg_skelmax_array);"
  },
  {
    "objectID": "Individual dataset processing.html",
    "href": "Individual dataset processing.html",
    "title": "Individual dataset processing",
    "section": "",
    "text": "The following script was applied to the Grubman dataset, which consists of single-nucleus (sn)RNA-seq in postmortem entorhinal cortex from six healthy controls and six patients with Alzheimer’s Disease (AD).\nThe data was accessed as a preprocessed count matrix and a covariare matrix, both available at GEO (GSE138852).\n\n\n\nlibs &lt;- c(\"Seurat\", \"tidyverse\", \"stringr\", \"data.table\", \"readxl\")\nsuppressMessages(\nsuppressWarnings(sapply(libs, require, character.only =TRUE))\n)\n\n    Seurat  tidyverse    stringr data.table     readxl \n      TRUE       TRUE       TRUE       TRUE       TRUE \n\n\n\n\n\nUpload the count matrix with 13,214 nuclei and 10,850 genes. Create Seurat object to include only genes present in at least 3 nuclei.\n\nSeurat = CreateSeuratObject(counts =count.matrix, min.cells=3)\n\n\n\n\nRemove nuclei with the following features: - Feature counts lower than 200 and higher than 5000; - UMI counts lower than 500 and higher than 20000; - Percentage of mitochondrial genes higher than 20%: - Percentage of ribosomal genes higher than 5% (only applied to snRNA-seq data).\n\n# Calculate the percentage of ribosomal genes\nC&lt;-GetAssayData(object = Seurat, slot = \"counts\")\nrb.genes &lt;- rownames(Seurat)[grep(\"^RP[SL]\",rownames(Seurat))]\npercent.ribo &lt;- colSums(C[rb.genes,])/Matrix::colSums(C)*100\nSeurat &lt;- AddMetaData(Seurat, percent.ribo, col.name = \"percent.ribo\")\n\n# Calculate thee percentage of mitochondrial genes\nSeurat[[\"percent.mt\"]] = PercentageFeatureSet(Seurat, pattern = \"^MT-\")\n\n# Filter low quality nuclei\nSeurat &lt;- subset(Seurat, subset = nFeature_RNA &gt; 200 & nFeature_RNA &lt; 5000  & nCount_RNA &gt; 500 & \n                    nCount_RNA &lt; 20000 & percent.mt &lt; 10 & percent.ribo &lt; 5)\n\nSeurat\n\nAn object of class Seurat \n10850 features across 11440 samples within 1 assay \nActive assay: RNA (10850 features, 0 variable features)\n 1 layer present: counts\n\n# check mean genes per nuclei\nmean(Seurat@meta.data$nFeature_RNA)\n\n[1] 756.6617\n\n\nThe used filtering pipeline originated a Seurat object with 11,440 nuclei, 10,850 genes and approximately 757 genes per nuclei.\n\n\n\nVisualize the number of genes and UMI counts per nuclei, and the percentage of mitochondrial and ribosomal genes as violin plots.\n\nprint(VlnPlot(Seurat, features = c(\"nFeature_RNA\", \"nCount_RNA\",\n\"percent.mt\",\"percent.ribo\"), ncol = 4))\n\nWarning: Default search for \"data\" layer in \"RNA\" assay yielded no results;\nutilizing \"counts\" layer instead.\n\n\n\n\n\n\n\n\n\nFeatureScatter representation of the association between the number of UMI counts per nuclei and the percentage of mitochondrial genes, and between UMI counts and the number of genes per nuclei.\n\nplot1 = FeatureScatter(Seurat, feature1 = \"nCount_RNA\", feature2 = \"percent.mt\")\nplot2 = FeatureScatter(Seurat, feature1 = \"nCount_RNA\", feature2 = \"nFeature_RNA\")\nprint(plot1 + plot2)\n\n\n\n\n\n\n\n\n\n\n\nThis dataset contains 3 controls and 3 patient samples, with each one being composed of two pooled individual samples.\nCreate a column in metadata (TAG) with the nuclei annotation.\n\nSeurat@meta.data$TAG &lt;- rownames(Seurat@meta.data)\n\nThe name of each sample (Sample_ID) is merged to each nuclei’s annotation. Split the sample name from the full nuclei name.\n\nx&lt;-as.data.frame(str_split_fixed(Seurat@meta.data$TAG,\"_\",2))\nSeurat@meta.data$Sample_ID &lt;- x$V2\nhead(Seurat@meta.data$Sample_ID)\n\n[1] \"AD5_AD6\" \"AD5_AD6\" \"AD5_AD6\" \"AD5_AD6\" \"AD5_AD6\" \"AD5_AD6\"\n\n\nRemove the columns on percent.ribo and percent.mt from the metadata.\n\nSeurat@meta.data &lt;- Seurat@meta.data[,-c(4,5)]\n\n\n\n\nRemove the list of genes associated with postmortem interval in bulk RNA-seq in cerebral cortex (Zhu et. al 2017; PMID: 28710439). This list (“PMI-genes.csv”) is available on the “Support data” folder from this repository.\nNote: In the original Grubman et al. study these genes had already been removed. This script was applied to all other datasets.\n\nkeep= c(!rownames(Seurat) %in% c(PMI_genes))\nSeurat&lt;- subset(x = Seurat,features =c(1:(dim(Seurat)[1]))[keep])\n\nSeurat\n\nAn object of class Seurat \n10850 features across 11440 samples within 1 assay \nActive assay: RNA (10850 features, 0 variable features)\n 1 layer present: counts\n\n# check mean genes per nuclei\nmean(Seurat@meta.data$nFeature_RNA)\n\n[1] 756.6617\n\n\n\n\n\nDoublets (n=858) had already been calculated using DoubletFinder (see script in “Double-Finder.html” in this repository). Upload a vector of nuclei (“doublets”) deemed as doublets. Plot the Seurat object highlighting the doublets.\n\nSeurat &lt;- SCTransform(Seurat, verbose = FALSE) #default variable features = 3000\nSeurat &lt;- RunPCA(Seurat, verbose = FALSE)\nSeurat &lt;- RunUMAP(Seurat, reduction = \"pca\",dims = 1:30, verbose = FALSE)\n\nDimPlot(Seurat, reduction = \"umap\", cells.highlight = doublets,pt.size = 0.1, sizes.highlight = 0.1)+ NoLegend()\n\n\n\n\n\n\n\n\nRemove the doublets from the Seurat object. The new object is composed of 10582 nuclei.\n\ntoRemove &lt;- doublets\nSeurat &lt;- Seurat[,!colnames(Seurat) %in% toRemove]\n\nSeurat\n\nAn object of class Seurat \n21700 features across 10582 samples within 2 assays \nActive assay: SCT (10850 features, 3000 variable features)\n 3 layers present: counts, data, scale.data\n 1 other assay present: RNA\n 2 dimensional reductions calculated: pca, umap\n\nmean(Seurat@meta.data$nFeature_RNA)\n\n[1] 756.4457\n\n\n\n\n\nAfter removal of the doublets, the SCT normalization is repeated and the clustering is done with FindNeighbors and FindClusters.\n\nSeurat &lt;- SCTransform(Seurat, verbose = FALSE) #default variable features = 3000\n\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\n\n\nWarning in sqrt(1/i): NaNs produced\n\n\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\n\n\nWarning in sqrt(1/i): NaNs produced\n\n\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\n\n\nWarning in sqrt(1/i): NaNs produced\n\n\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\n\n\nWarning in sqrt(1/i): NaNs produced\n\n\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\n\n\nWarning: Different cells and/or features from existing assay SCT\n\nSeurat &lt;- RunPCA(Seurat, verbose = FALSE)\nSeurat &lt;- RunUMAP(Seurat, reduction = \"pca\",dims = 1:30, verbose = FALSE)\nSeurat &lt;- FindNeighbors(Seurat, reduction = \"pca\",dims = 1:30)\nSeurat &lt;- FindClusters(Seurat,resolution = 0.05)\n\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 10582\nNumber of edges: 420910\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.9890\nNumber of communities: 8\nElapsed time: 1 seconds\n\n\nEight clusters were originated for a clustering resolution of 0.05.\n\nDimPlot(Seurat, reduction = \"umap\", label = TRUE, repel = TRUE)\n\n\n\n\n\n\n\n\nAnnotated by Sample_ID.\n\nDimPlot(Seurat, reduction = \"umap\", label = FALSE, repel = TRUE, group.by = \"Sample_ID\")\n\n\n\n\n\n\n\n\n\n\n\nUse FindAllMarkers to calculate the markers for each cluster.\n\nSeurat.markers &lt;- FindAllMarkers(Seurat, only.pos = TRUE, min.pct = 0.1, logfc.threshold = 0.25)\n\nUpload the list of canonical cell-type markers collected from the literature that is located at the “Support data” folder of this repository. Check for canonical markers within Seurat.markers.\n\nknown_markers &lt;- merge(Seurat.markers, Brain_cell_markers, by=\"gene\") \n\nCheck the expression of some canonical markers to guide cluster annotation. Script for the stacked violin plot function:\n\n## remove the x-axis text and tick\n## plot.margin to adjust the white space between each plot.\n## ... pass any arguments to VlnPlot in Seurat\nmodify_vlnplot&lt;- function(obj,\nfeature,\npt.size = 0,\nplot.margin = unit(c(-0.75, 0, -0.75, 0), \"cm\"),\n...) {\np&lt;- VlnPlot(obj, features = feature, pt.size = pt.size #,cols = UMAP_colors\n, ... ) +\nxlab(\"\") + ylab(feature) + ggtitle(\"\") +\ntheme(legend.position = \"none\",\naxis.text.x = element_blank(),\naxis.ticks.x = element_blank(),\naxis.title.y = element_text(size = rel(1), angle = 45),\naxis.text.y = element_text(size = rel(1)),\nplot.margin = plot.margin )\nreturn(p)\n}\n## extract the max value of the y axis\nextract_max&lt;- function(p){\nymax&lt;- max(ggplot_build(p)$layout$panel_scales_y[[1]]$range$range)\nreturn(ceiling(ymax))\n}\n## main function\nStackedVlnPlot&lt;- function(obj, features,\npt.size = 0,\nplot.margin = unit(c(-0.75, 0, -0.75, 0), \"cm\"),\n...) {\nplot_list&lt;- purrr::map(features, function(x) modify_vlnplot(obj = obj,feature = x, ...))\n# Add back x-axis title to bottom plot. patchwork is going to support this?\nplot_list[[length(plot_list)]]&lt;- plot_list[[length(plot_list)]] +\ntheme(axis.text.x=element_text(angle = 45, hjust = 1), axis.ticks.x = element_line())\n# change the y-axis tick to only max value\nymaxs&lt;- purrr::map_dbl(plot_list, extract_max)\nplot_list&lt;- purrr::map2(plot_list, ymaxs, function(x,y) x +\nscale_y_continuous(breaks = c(y)) +\nexpand_limits(y = y))\np&lt;- patchwork::wrap_plots(plotlist = plot_list, ncol = 1)\nreturn(p)\n}\n\nStacked violin plots\n\nmarkers&lt;- c(\"PLP1\",\"ST18\",  #OLIGO\n\"SYT1\", \"SNAP25\",           #NEURONS\n\"SLC1A2\", \"AQP4\",           #ASTROCYTES\n\"VCAN\", \"PDGFRA\",           #OPCS\n\"DOCK8\", \"P2RY12\",          #IMMUNE CELLS\n\"CLDN5\", \"FLT1\")            #ENDOT\n\nStackedVlnPlot(obj = Seurat, features = markers)\n\n\n\n\n\n\n\n\n\n\n\nMake this assessment based on the previous information.\n\nnew.cluster.ids &lt;- c(\"Oligodendrocytes\", \"Astrocytes\",\"Oligodendrocytes\",\"Oligodendrocytes\",\"OPCs\",\"Neurons\",\"Immune cells\",\"Astrocytes\")\nnames(new.cluster.ids) &lt;- levels(Seurat)\nSeurat &lt;- RenameIdents(Seurat, new.cluster.ids)\n\nFeature plot with the Module score of the expression of microglia/immune cell markers.\n\nDefaultAssay(Seurat) &lt;- \"SCT\"\nImmune_genes &lt;-c( \"P2RY12\",\"DOCK8\",\"CD74\",\"CX3CR1\",\"C1QB\",\"C3\",\"AIF1\",\"HLA-DRA\")\nSeurat &lt;- AddModuleScore(Seurat,features =list(Immune_genes),name='Immune_genes')\nFeaturePlot(Seurat, features = \"Immune_genes1\",cols = c(\"#F1EEE9\",\"#DF7861\"))\n\n\n\n\n\n\n\n\nColor the UMAP plot by cell-type.\n\nUMAP_colors&lt;-c(\"#525E75\", #Oligodendrocytes\n\"#92BA92\",                #Astrocytes\n\"#A7D2CB\",                #OPCs\n\"#F2D388\",                #Neurons\n\"#DF7861\"                 #Immune cells\n)\n\nDimPlot(Seurat, reduction = \"umap\", label = FALSE, repel = F ,cols = UMAP_colors)\n\n\n\n\n\n\n\n\n\n\n\nThe nuclei annotated as belonging to immune cells are singled-out in an individual Seurat object, consisting of 340 nuclei, to be later integrated with the other datasets to form the\nHuman Microglia Atlas (HuMicA).\n\nImmune_Seurat&lt;- Seurat[,Seurat@active.ident==\"Immune cells\"]"
  },
  {
    "objectID": "Individual dataset processing.html#example-for-the-grubman-et-al.-2019-dataset-pmid31768052",
    "href": "Individual dataset processing.html#example-for-the-grubman-et-al.-2019-dataset-pmid31768052",
    "title": "Individual dataset processing",
    "section": "",
    "text": "The following script was applied to the Grubman dataset, which consists of single-nucleus (sn)RNA-seq in postmortem entorhinal cortex from six healthy controls and six patients with Alzheimer’s Disease (AD).\nThe data was accessed as a preprocessed count matrix and a covariare matrix, both available at GEO (GSE138852).\n\n\n\nlibs &lt;- c(\"Seurat\", \"tidyverse\", \"stringr\", \"data.table\", \"readxl\")\nsuppressMessages(\nsuppressWarnings(sapply(libs, require, character.only =TRUE))\n)\n\n    Seurat  tidyverse    stringr data.table     readxl \n      TRUE       TRUE       TRUE       TRUE       TRUE \n\n\n\n\n\nUpload the count matrix with 13,214 nuclei and 10,850 genes. Create Seurat object to include only genes present in at least 3 nuclei.\n\nSeurat = CreateSeuratObject(counts =count.matrix, min.cells=3)\n\n\n\n\nRemove nuclei with the following features: - Feature counts lower than 200 and higher than 5000; - UMI counts lower than 500 and higher than 20000; - Percentage of mitochondrial genes higher than 20%: - Percentage of ribosomal genes higher than 5% (only applied to snRNA-seq data).\n\n# Calculate the percentage of ribosomal genes\nC&lt;-GetAssayData(object = Seurat, slot = \"counts\")\nrb.genes &lt;- rownames(Seurat)[grep(\"^RP[SL]\",rownames(Seurat))]\npercent.ribo &lt;- colSums(C[rb.genes,])/Matrix::colSums(C)*100\nSeurat &lt;- AddMetaData(Seurat, percent.ribo, col.name = \"percent.ribo\")\n\n# Calculate thee percentage of mitochondrial genes\nSeurat[[\"percent.mt\"]] = PercentageFeatureSet(Seurat, pattern = \"^MT-\")\n\n# Filter low quality nuclei\nSeurat &lt;- subset(Seurat, subset = nFeature_RNA &gt; 200 & nFeature_RNA &lt; 5000  & nCount_RNA &gt; 500 & \n                    nCount_RNA &lt; 20000 & percent.mt &lt; 10 & percent.ribo &lt; 5)\n\nSeurat\n\nAn object of class Seurat \n10850 features across 11440 samples within 1 assay \nActive assay: RNA (10850 features, 0 variable features)\n 1 layer present: counts\n\n# check mean genes per nuclei\nmean(Seurat@meta.data$nFeature_RNA)\n\n[1] 756.6617\n\n\nThe used filtering pipeline originated a Seurat object with 11,440 nuclei, 10,850 genes and approximately 757 genes per nuclei.\n\n\n\nVisualize the number of genes and UMI counts per nuclei, and the percentage of mitochondrial and ribosomal genes as violin plots.\n\nprint(VlnPlot(Seurat, features = c(\"nFeature_RNA\", \"nCount_RNA\",\n\"percent.mt\",\"percent.ribo\"), ncol = 4))\n\nWarning: Default search for \"data\" layer in \"RNA\" assay yielded no results;\nutilizing \"counts\" layer instead.\n\n\n\n\n\n\n\n\n\nFeatureScatter representation of the association between the number of UMI counts per nuclei and the percentage of mitochondrial genes, and between UMI counts and the number of genes per nuclei.\n\nplot1 = FeatureScatter(Seurat, feature1 = \"nCount_RNA\", feature2 = \"percent.mt\")\nplot2 = FeatureScatter(Seurat, feature1 = \"nCount_RNA\", feature2 = \"nFeature_RNA\")\nprint(plot1 + plot2)\n\n\n\n\n\n\n\n\n\n\n\nThis dataset contains 3 controls and 3 patient samples, with each one being composed of two pooled individual samples.\nCreate a column in metadata (TAG) with the nuclei annotation.\n\nSeurat@meta.data$TAG &lt;- rownames(Seurat@meta.data)\n\nThe name of each sample (Sample_ID) is merged to each nuclei’s annotation. Split the sample name from the full nuclei name.\n\nx&lt;-as.data.frame(str_split_fixed(Seurat@meta.data$TAG,\"_\",2))\nSeurat@meta.data$Sample_ID &lt;- x$V2\nhead(Seurat@meta.data$Sample_ID)\n\n[1] \"AD5_AD6\" \"AD5_AD6\" \"AD5_AD6\" \"AD5_AD6\" \"AD5_AD6\" \"AD5_AD6\"\n\n\nRemove the columns on percent.ribo and percent.mt from the metadata.\n\nSeurat@meta.data &lt;- Seurat@meta.data[,-c(4,5)]\n\n\n\n\nRemove the list of genes associated with postmortem interval in bulk RNA-seq in cerebral cortex (Zhu et. al 2017; PMID: 28710439). This list (“PMI-genes.csv”) is available on the “Support data” folder from this repository.\nNote: In the original Grubman et al. study these genes had already been removed. This script was applied to all other datasets.\n\nkeep= c(!rownames(Seurat) %in% c(PMI_genes))\nSeurat&lt;- subset(x = Seurat,features =c(1:(dim(Seurat)[1]))[keep])\n\nSeurat\n\nAn object of class Seurat \n10850 features across 11440 samples within 1 assay \nActive assay: RNA (10850 features, 0 variable features)\n 1 layer present: counts\n\n# check mean genes per nuclei\nmean(Seurat@meta.data$nFeature_RNA)\n\n[1] 756.6617\n\n\n\n\n\nDoublets (n=858) had already been calculated using DoubletFinder (see script in “Double-Finder.html” in this repository). Upload a vector of nuclei (“doublets”) deemed as doublets. Plot the Seurat object highlighting the doublets.\n\nSeurat &lt;- SCTransform(Seurat, verbose = FALSE) #default variable features = 3000\nSeurat &lt;- RunPCA(Seurat, verbose = FALSE)\nSeurat &lt;- RunUMAP(Seurat, reduction = \"pca\",dims = 1:30, verbose = FALSE)\n\nDimPlot(Seurat, reduction = \"umap\", cells.highlight = doublets,pt.size = 0.1, sizes.highlight = 0.1)+ NoLegend()\n\n\n\n\n\n\n\n\nRemove the doublets from the Seurat object. The new object is composed of 10582 nuclei.\n\ntoRemove &lt;- doublets\nSeurat &lt;- Seurat[,!colnames(Seurat) %in% toRemove]\n\nSeurat\n\nAn object of class Seurat \n21700 features across 10582 samples within 2 assays \nActive assay: SCT (10850 features, 3000 variable features)\n 3 layers present: counts, data, scale.data\n 1 other assay present: RNA\n 2 dimensional reductions calculated: pca, umap\n\nmean(Seurat@meta.data$nFeature_RNA)\n\n[1] 756.4457\n\n\n\n\n\nAfter removal of the doublets, the SCT normalization is repeated and the clustering is done with FindNeighbors and FindClusters.\n\nSeurat &lt;- SCTransform(Seurat, verbose = FALSE) #default variable features = 3000\n\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\n\n\nWarning in sqrt(1/i): NaNs produced\n\n\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\n\n\nWarning in sqrt(1/i): NaNs produced\n\n\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\n\n\nWarning in sqrt(1/i): NaNs produced\n\n\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\n\n\nWarning in sqrt(1/i): NaNs produced\n\n\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\nWarning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =\ncontrol$trace &gt; : iteration limit reached\n\n\nWarning: Different cells and/or features from existing assay SCT\n\nSeurat &lt;- RunPCA(Seurat, verbose = FALSE)\nSeurat &lt;- RunUMAP(Seurat, reduction = \"pca\",dims = 1:30, verbose = FALSE)\nSeurat &lt;- FindNeighbors(Seurat, reduction = \"pca\",dims = 1:30)\nSeurat &lt;- FindClusters(Seurat,resolution = 0.05)\n\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 10582\nNumber of edges: 420910\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.9890\nNumber of communities: 8\nElapsed time: 1 seconds\n\n\nEight clusters were originated for a clustering resolution of 0.05.\n\nDimPlot(Seurat, reduction = \"umap\", label = TRUE, repel = TRUE)\n\n\n\n\n\n\n\n\nAnnotated by Sample_ID.\n\nDimPlot(Seurat, reduction = \"umap\", label = FALSE, repel = TRUE, group.by = \"Sample_ID\")\n\n\n\n\n\n\n\n\n\n\n\nUse FindAllMarkers to calculate the markers for each cluster.\n\nSeurat.markers &lt;- FindAllMarkers(Seurat, only.pos = TRUE, min.pct = 0.1, logfc.threshold = 0.25)\n\nUpload the list of canonical cell-type markers collected from the literature that is located at the “Support data” folder of this repository. Check for canonical markers within Seurat.markers.\n\nknown_markers &lt;- merge(Seurat.markers, Brain_cell_markers, by=\"gene\") \n\nCheck the expression of some canonical markers to guide cluster annotation. Script for the stacked violin plot function:\n\n## remove the x-axis text and tick\n## plot.margin to adjust the white space between each plot.\n## ... pass any arguments to VlnPlot in Seurat\nmodify_vlnplot&lt;- function(obj,\nfeature,\npt.size = 0,\nplot.margin = unit(c(-0.75, 0, -0.75, 0), \"cm\"),\n...) {\np&lt;- VlnPlot(obj, features = feature, pt.size = pt.size #,cols = UMAP_colors\n, ... ) +\nxlab(\"\") + ylab(feature) + ggtitle(\"\") +\ntheme(legend.position = \"none\",\naxis.text.x = element_blank(),\naxis.ticks.x = element_blank(),\naxis.title.y = element_text(size = rel(1), angle = 45),\naxis.text.y = element_text(size = rel(1)),\nplot.margin = plot.margin )\nreturn(p)\n}\n## extract the max value of the y axis\nextract_max&lt;- function(p){\nymax&lt;- max(ggplot_build(p)$layout$panel_scales_y[[1]]$range$range)\nreturn(ceiling(ymax))\n}\n## main function\nStackedVlnPlot&lt;- function(obj, features,\npt.size = 0,\nplot.margin = unit(c(-0.75, 0, -0.75, 0), \"cm\"),\n...) {\nplot_list&lt;- purrr::map(features, function(x) modify_vlnplot(obj = obj,feature = x, ...))\n# Add back x-axis title to bottom plot. patchwork is going to support this?\nplot_list[[length(plot_list)]]&lt;- plot_list[[length(plot_list)]] +\ntheme(axis.text.x=element_text(angle = 45, hjust = 1), axis.ticks.x = element_line())\n# change the y-axis tick to only max value\nymaxs&lt;- purrr::map_dbl(plot_list, extract_max)\nplot_list&lt;- purrr::map2(plot_list, ymaxs, function(x,y) x +\nscale_y_continuous(breaks = c(y)) +\nexpand_limits(y = y))\np&lt;- patchwork::wrap_plots(plotlist = plot_list, ncol = 1)\nreturn(p)\n}\n\nStacked violin plots\n\nmarkers&lt;- c(\"PLP1\",\"ST18\",  #OLIGO\n\"SYT1\", \"SNAP25\",           #NEURONS\n\"SLC1A2\", \"AQP4\",           #ASTROCYTES\n\"VCAN\", \"PDGFRA\",           #OPCS\n\"DOCK8\", \"P2RY12\",          #IMMUNE CELLS\n\"CLDN5\", \"FLT1\")            #ENDOT\n\nStackedVlnPlot(obj = Seurat, features = markers)\n\n\n\n\n\n\n\n\n\n\n\nMake this assessment based on the previous information.\n\nnew.cluster.ids &lt;- c(\"Oligodendrocytes\", \"Astrocytes\",\"Oligodendrocytes\",\"Oligodendrocytes\",\"OPCs\",\"Neurons\",\"Immune cells\",\"Astrocytes\")\nnames(new.cluster.ids) &lt;- levels(Seurat)\nSeurat &lt;- RenameIdents(Seurat, new.cluster.ids)\n\nFeature plot with the Module score of the expression of microglia/immune cell markers.\n\nDefaultAssay(Seurat) &lt;- \"SCT\"\nImmune_genes &lt;-c( \"P2RY12\",\"DOCK8\",\"CD74\",\"CX3CR1\",\"C1QB\",\"C3\",\"AIF1\",\"HLA-DRA\")\nSeurat &lt;- AddModuleScore(Seurat,features =list(Immune_genes),name='Immune_genes')\nFeaturePlot(Seurat, features = \"Immune_genes1\",cols = c(\"#F1EEE9\",\"#DF7861\"))\n\n\n\n\n\n\n\n\nColor the UMAP plot by cell-type.\n\nUMAP_colors&lt;-c(\"#525E75\", #Oligodendrocytes\n\"#92BA92\",                #Astrocytes\n\"#A7D2CB\",                #OPCs\n\"#F2D388\",                #Neurons\n\"#DF7861\"                 #Immune cells\n)\n\nDimPlot(Seurat, reduction = \"umap\", label = FALSE, repel = F ,cols = UMAP_colors)\n\n\n\n\n\n\n\n\n\n\n\nThe nuclei annotated as belonging to immune cells are singled-out in an individual Seurat object, consisting of 340 nuclei, to be later integrated with the other datasets to form the\nHuman Microglia Atlas (HuMicA).\n\nImmune_Seurat&lt;- Seurat[,Seurat@active.ident==\"Immune cells\"]"
  },
  {
    "objectID": "Individual dataset processing.html#check-for-outlier-samples",
    "href": "Individual dataset processing.html#check-for-outlier-samples",
    "title": "Individual dataset processing",
    "section": "Check for outlier samples",
    "text": "Check for outlier samples\nThe last step consist on verifying if any of the samples within the filtered object shows an unbalanced number of nuclei. In this case, all samples have an approximate number of nuclei. Therefore, all were included in the final integration.\n\nmd &lt;- Immune_Seurat@meta.data %&gt;% as.data.table\nCell_number_subject &lt;- md[, .N, by = c(\"Sample_ID\")]\nCell_number_subject\n\n   Sample_ID     N\n      &lt;char&gt; &lt;int&gt;\n1:   AD5_AD6    29\n2:   AD3_AD4    84\n3:   Ct5_Ct6    55\n4:   Ct3_Ct4    83\n5:   Ct1_Ct2    39\n6:   AD1_AD2    45"
  },
  {
    "objectID": "Covariate.html",
    "href": "Covariate.html",
    "title": "Covariate influence",
    "section": "",
    "text": "The following script is related to Supplementary Figures 4 and 5. The “Methodology” variable (single cell or single nucleus RNA-seq) will be used as an example.\n\n\n\nlibs &lt;- c(\"Seurat\", \"tidyverse\", \"sccomp\",\"ggpubr\")\nsuppressMessages(\nsuppressWarnings(sapply(libs, require, character.only =TRUE))\n)\n\n   Seurat tidyverse    sccomp    ggpubr \n     TRUE      TRUE      TRUE      TRUE \n\n\n\n\n\nRepresentation of the HuMicA object annotated by the “Methodology” variable in a grouped UMAP plot.\n\n\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 90716\nNumber of edges: 5570085\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.9128\nNumber of communities: 14\nElapsed time: 46 seconds\n\n\n\nmethodology_colors &lt;- c(\"#7EB77F\",\"#E95D69\")\n\nDimPlot(Humica, reduction = \"umap\",\n        group.by = \"Methodology\", \n        cols = methodology_colors, \n        pt.size = 0.01) + NoLegend()\n\n\n\n\n\n\n\n\nRepresentation of the HuMicA object annotated by the “Methodology” variable in a grouped UMAP plot.\n\ncolor_clusters &lt;-c(\"#fdc835ff\", \"#FC8D62\", \"#7570B3\" ,\"#679436\", \"#D43921\" ,\"#344D67\", \"#874C62\" ,\"#937666\",\"#5B7B7A\")\n\nDimPlot(Humica, reduction = \"umap\",\n        split.by = \"Methodology\", \n        cols = color_clusters, \n        pt.size = 0.01)+ NoLegend()\n\n\n\n\n\n\n\n\n\n\n\n\n# subset Humica object per category\ncell&lt;- Humica[,Humica@meta.data$Methodology==\"cell\"]\nnucleus&lt;- Humica[,Humica@meta.data$Methodology==\"nucleus\"]\n\n\n# Calculate number of cells/nuclei and and number of genes per cells/nuclei\nmain.list &lt;- list(cell,nucleus)\n\nmy.files &lt;- c(\"cell\",\"nucleus\")\n\ndf &lt;- data.frame(Sample=my.files, Nuclei=\"\", Genes=\"\")\nnumber_nuclei= numeric(length(my.files))\nnumber_genes = numeric(length(my.files))\n\nfor (i in 1:length(main.list)) {\n  \n  number_nuclei[i]&lt;- nrow(main.list[[i]]@meta.data)\n  number_genes[i] &lt;- mean(main.list[[i]]@meta.data$nFeature_RNA)\n}\n\ndf$Nuclei = number_nuclei\ndf$Genes = number_genes\ndf$Genes = format(round(df$Genes, 0))\n\ndf$Label &lt;- paste0(df$Nuclei,\"(\",df$Genes,\")\")\ndf &lt;- df[order(df$Nuclei),]\n\n#plot\nggplot(df, aes(x= factor(Sample, levels = Sample), y=Nuclei, fill=Sample)) +\n  geom_bar(stat=\"identity\",position = \"stack\")+\n  geom_text(aes(label = Label), hjust=0,position = position_fill(vjust = 0), size = 3,colour=\"black\")+\n  coord_flip()+\n  ylab(label = \"Nuclei (mean genes/nuclei)\")+\n  scale_fill_manual(values = methodology_colors)+\n  theme_linedraw()+\n  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.text = element_text(colour=\"black\"))\n\n\n\n\n\n\n\n\n\n\n\n\n# Calculate the proportions\ndata &lt;- Humica@meta.data[,c(\"Sample_ID\",\"Methodology\",\"integrated_snn_res.0.2\")]\ncolnames(data)&lt;- c(\"Sample_ID\",\"Methodology\",\"Cluster\")\n\ndata &lt;- data %&gt;% group_by(Methodology, Cluster) %&gt;%\n  dplyr::summarise(Nb = n()) %&gt;%\n  dplyr::mutate(C = sum(Nb))%&gt;%\n  dplyr::mutate(percent = Nb/C*100)\n\n`summarise()` has grouped output by 'Methodology'. You can override using the\n`.groups` argument.\n\ndata$percent2 &lt;- format(round(data$percent,2), nsmall=2)\n\n#percentage of cluster in the whole dataset \nHumica@meta.data$whole &lt;- \"ALL\"\ndata2 &lt;- Humica@meta.data[,c(\"whole\",\"integrated_snn_res.0.2\")]\ncolnames(data2)&lt;- c(\"whole\",\"Cluster\")\n\n\ndata2 &lt;- data2 %&gt;% group_by(whole, Cluster) %&gt;%\n  dplyr::summarise(Nb = n()) %&gt;%\n  dplyr::mutate(C = sum(Nb))%&gt;%\n  dplyr::mutate(percent = Nb/C*100)\n\n`summarise()` has grouped output by 'whole'. You can override using the\n`.groups` argument.\n\ndata2$percent2 &lt;- format(round(data2$percent,2), nsmall=2)\ncolnames(data2)[1]&lt;- \"Methodology\"\n\ndata &lt;- rbind(data,data2)\n## Stacked Bar plot per Group\n\ndata &lt;-data[order(as.numeric(as.character(data$Cluster))), ]\ndata$Methodology&lt;- as.factor(data$Methodology)\n\n# add 0 values when there is no match\nreference_data &lt;- expand.grid(Methodology = unique(data$Methodology), Cluster = unique(data$Cluster))\nresult_data &lt;- left_join(reference_data, data, by = c(\"Methodology\", \"Cluster\"))\nresult_data[is.na(result_data)] &lt;- 0\n\n# Plot\nggplot(result_data, aes(x = factor(Methodology, levels = c(\"cell\",\"nucleus\",\"ALL\")), y = percent, fill = Cluster))+\n  geom_bar(stat = \"Identity\")+\n  scale_fill_manual(values=color_clusters)+\n  #geom_text(aes(label = paste(percent2,\"%\")), position = position_stack(vjust = 0.5), size=2.5)+\n  theme_linedraw()+\n  facet_wrap(~Cluster,scales = \"free_y\", ncol = 3) +  # Create indivgeneual barplots for each Group\n  theme(panel.grid=element_blank(), axis.text.x = element_text(angle = 45, hjust = 1))\n\n\n\n\n\n\n\n\n\n\n\nhttps://github.com/stemangiola/sccomp\nThe contrast function is set to compare each category vs the largest one, which is “nucleus” in this case.\n\n#with contrast\nres = Humica |&gt;\n  sccomp_glm( \n    formula_composition = ~ 0+Methodology, \n    contrasts =  c(\"Methodologycell - Methodologynucleus\"),\n    .sample =Sample_ID,\n    .cell_group = integrated_snn_res.0.2 , \n    bimodal_mean_variability_association = TRUE,\n    cores = 5\n  ) \n\nWarning: `sccomp_glm()` was deprecated in sccomp 1.7.1.\nℹ sccomp says: sccomp_glm() is soft-deprecated. Please use the new modular\n  framework instead, which includes sccomp_estimate(), sccomp_test(),\n  sccomp_remove_outliers(), among other functions.\nℹ The deprecated feature was likely used in the sccomp package.\n  Please report the issue at &lt;https://github.com/stemangiola/sccomp/issues&gt;.\n\n\nsccomp says: count column is an integer. The sum-constrained beta binomial model will be used\n\n\nsccomp says: estimation\n\n\nsccomp says: the composition design matrix has columns: Methodologycell, Methodologynucleus\n\n\nsccomp says: the variability design matrix has columns: (Intercept)\n\n\nsccomp says: From version 1.7.7 the model by default is fit with the variational inference method (variational_inference = TRUE; much faster). For a full Bayesian inference (HMC method; the gold standard) use variational_inference = FALSE.\nThis message is displayed once per session.\n\n\nWarning: The `approximate_posterior_inference` argument of `sccomp_estimate()` is\ndeprecated as of sccomp 1.7.7.\nℹ The argument approximate_posterior_inference is now deprecated please use\n  variational_inference. By default variational_inference value is inferred\n  from approximate_posterior_inference.\nℹ The deprecated feature was likely used in the sccomp package.\n  Please report the issue at &lt;https://github.com/stemangiola/sccomp/issues&gt;.\n\n\nsccomp says: outlier identification - step 1/2\nsccomp says: outlier-free model fitting - step 2/2\nsccomp says: the composition design matrix has columns: Methodologycell, Methodologynucleus\nsccomp says: the variability design matrix has columns: (Intercept)\n\n# Plot\nres$sig&lt;-  ifelse(res$c_FDR&lt;0.05, \"yes\", \"no\")\nggplot(res, aes(x = factor(integrated_snn_res.0.2, levels= levels(Idents(Humica))),\n                y = res$c_effect, color=sig)) +\n  geom_point(stat = \"Identity\", shape = 15) +\n  scale_color_manual(values = c(\"grey\",\"#A21F16\"))+\n  geom_hline(yintercept = c(-0.2,0.2), linetype = \"dashed\", color = \"grey\") +\n  geom_errorbar(aes(ymin = c_lower, ymax = c_upper), width = 0.4) +\n  facet_wrap(~parameter,scales=\"free\")+\n  ylab(\"Credible interval of the slope\")+\n  xlab(\"Cluster\")+\n  coord_flip()+\n  theme_pubr()+\n  border()\n\nWarning: Use of `res$c_effect` is discouraged.\nℹ Use `c_effect` instead.\n\n\nWarning: Use of `res$c_effect` is discouraged.\nℹ Use `c_effect` instead.\n\n\n\n\n\n\n\n\ndev.off()  \n\nnull device \n          1 \n\n\nPlot the obtained results"
  },
  {
    "objectID": "Covariate.html#inference-of-the-bias-effect-of-additional-variables",
    "href": "Covariate.html#inference-of-the-bias-effect-of-additional-variables",
    "title": "Covariate influence",
    "section": "",
    "text": "The following script is related to Supplementary Figures 4 and 5. The “Methodology” variable (single cell or single nucleus RNA-seq) will be used as an example.\n\n\n\nlibs &lt;- c(\"Seurat\", \"tidyverse\", \"sccomp\",\"ggpubr\")\nsuppressMessages(\nsuppressWarnings(sapply(libs, require, character.only =TRUE))\n)\n\n   Seurat tidyverse    sccomp    ggpubr \n     TRUE      TRUE      TRUE      TRUE \n\n\n\n\n\nRepresentation of the HuMicA object annotated by the “Methodology” variable in a grouped UMAP plot.\n\n\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 90716\nNumber of edges: 5570085\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.9128\nNumber of communities: 14\nElapsed time: 46 seconds\n\n\n\nmethodology_colors &lt;- c(\"#7EB77F\",\"#E95D69\")\n\nDimPlot(Humica, reduction = \"umap\",\n        group.by = \"Methodology\", \n        cols = methodology_colors, \n        pt.size = 0.01) + NoLegend()\n\n\n\n\n\n\n\n\nRepresentation of the HuMicA object annotated by the “Methodology” variable in a grouped UMAP plot.\n\ncolor_clusters &lt;-c(\"#fdc835ff\", \"#FC8D62\", \"#7570B3\" ,\"#679436\", \"#D43921\" ,\"#344D67\", \"#874C62\" ,\"#937666\",\"#5B7B7A\")\n\nDimPlot(Humica, reduction = \"umap\",\n        split.by = \"Methodology\", \n        cols = color_clusters, \n        pt.size = 0.01)+ NoLegend()\n\n\n\n\n\n\n\n\n\n\n\n\n# subset Humica object per category\ncell&lt;- Humica[,Humica@meta.data$Methodology==\"cell\"]\nnucleus&lt;- Humica[,Humica@meta.data$Methodology==\"nucleus\"]\n\n\n# Calculate number of cells/nuclei and and number of genes per cells/nuclei\nmain.list &lt;- list(cell,nucleus)\n\nmy.files &lt;- c(\"cell\",\"nucleus\")\n\ndf &lt;- data.frame(Sample=my.files, Nuclei=\"\", Genes=\"\")\nnumber_nuclei= numeric(length(my.files))\nnumber_genes = numeric(length(my.files))\n\nfor (i in 1:length(main.list)) {\n  \n  number_nuclei[i]&lt;- nrow(main.list[[i]]@meta.data)\n  number_genes[i] &lt;- mean(main.list[[i]]@meta.data$nFeature_RNA)\n}\n\ndf$Nuclei = number_nuclei\ndf$Genes = number_genes\ndf$Genes = format(round(df$Genes, 0))\n\ndf$Label &lt;- paste0(df$Nuclei,\"(\",df$Genes,\")\")\ndf &lt;- df[order(df$Nuclei),]\n\n#plot\nggplot(df, aes(x= factor(Sample, levels = Sample), y=Nuclei, fill=Sample)) +\n  geom_bar(stat=\"identity\",position = \"stack\")+\n  geom_text(aes(label = Label), hjust=0,position = position_fill(vjust = 0), size = 3,colour=\"black\")+\n  coord_flip()+\n  ylab(label = \"Nuclei (mean genes/nuclei)\")+\n  scale_fill_manual(values = methodology_colors)+\n  theme_linedraw()+\n  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.text = element_text(colour=\"black\"))\n\n\n\n\n\n\n\n\n\n\n\n\n# Calculate the proportions\ndata &lt;- Humica@meta.data[,c(\"Sample_ID\",\"Methodology\",\"integrated_snn_res.0.2\")]\ncolnames(data)&lt;- c(\"Sample_ID\",\"Methodology\",\"Cluster\")\n\ndata &lt;- data %&gt;% group_by(Methodology, Cluster) %&gt;%\n  dplyr::summarise(Nb = n()) %&gt;%\n  dplyr::mutate(C = sum(Nb))%&gt;%\n  dplyr::mutate(percent = Nb/C*100)\n\n`summarise()` has grouped output by 'Methodology'. You can override using the\n`.groups` argument.\n\ndata$percent2 &lt;- format(round(data$percent,2), nsmall=2)\n\n#percentage of cluster in the whole dataset \nHumica@meta.data$whole &lt;- \"ALL\"\ndata2 &lt;- Humica@meta.data[,c(\"whole\",\"integrated_snn_res.0.2\")]\ncolnames(data2)&lt;- c(\"whole\",\"Cluster\")\n\n\ndata2 &lt;- data2 %&gt;% group_by(whole, Cluster) %&gt;%\n  dplyr::summarise(Nb = n()) %&gt;%\n  dplyr::mutate(C = sum(Nb))%&gt;%\n  dplyr::mutate(percent = Nb/C*100)\n\n`summarise()` has grouped output by 'whole'. You can override using the\n`.groups` argument.\n\ndata2$percent2 &lt;- format(round(data2$percent,2), nsmall=2)\ncolnames(data2)[1]&lt;- \"Methodology\"\n\ndata &lt;- rbind(data,data2)\n## Stacked Bar plot per Group\n\ndata &lt;-data[order(as.numeric(as.character(data$Cluster))), ]\ndata$Methodology&lt;- as.factor(data$Methodology)\n\n# add 0 values when there is no match\nreference_data &lt;- expand.grid(Methodology = unique(data$Methodology), Cluster = unique(data$Cluster))\nresult_data &lt;- left_join(reference_data, data, by = c(\"Methodology\", \"Cluster\"))\nresult_data[is.na(result_data)] &lt;- 0\n\n# Plot\nggplot(result_data, aes(x = factor(Methodology, levels = c(\"cell\",\"nucleus\",\"ALL\")), y = percent, fill = Cluster))+\n  geom_bar(stat = \"Identity\")+\n  scale_fill_manual(values=color_clusters)+\n  #geom_text(aes(label = paste(percent2,\"%\")), position = position_stack(vjust = 0.5), size=2.5)+\n  theme_linedraw()+\n  facet_wrap(~Cluster,scales = \"free_y\", ncol = 3) +  # Create indivgeneual barplots for each Group\n  theme(panel.grid=element_blank(), axis.text.x = element_text(angle = 45, hjust = 1))\n\n\n\n\n\n\n\n\n\n\n\nhttps://github.com/stemangiola/sccomp\nThe contrast function is set to compare each category vs the largest one, which is “nucleus” in this case.\n\n#with contrast\nres = Humica |&gt;\n  sccomp_glm( \n    formula_composition = ~ 0+Methodology, \n    contrasts =  c(\"Methodologycell - Methodologynucleus\"),\n    .sample =Sample_ID,\n    .cell_group = integrated_snn_res.0.2 , \n    bimodal_mean_variability_association = TRUE,\n    cores = 5\n  ) \n\nWarning: `sccomp_glm()` was deprecated in sccomp 1.7.1.\nℹ sccomp says: sccomp_glm() is soft-deprecated. Please use the new modular\n  framework instead, which includes sccomp_estimate(), sccomp_test(),\n  sccomp_remove_outliers(), among other functions.\nℹ The deprecated feature was likely used in the sccomp package.\n  Please report the issue at &lt;https://github.com/stemangiola/sccomp/issues&gt;.\n\n\nsccomp says: count column is an integer. The sum-constrained beta binomial model will be used\n\n\nsccomp says: estimation\n\n\nsccomp says: the composition design matrix has columns: Methodologycell, Methodologynucleus\n\n\nsccomp says: the variability design matrix has columns: (Intercept)\n\n\nsccomp says: From version 1.7.7 the model by default is fit with the variational inference method (variational_inference = TRUE; much faster). For a full Bayesian inference (HMC method; the gold standard) use variational_inference = FALSE.\nThis message is displayed once per session.\n\n\nWarning: The `approximate_posterior_inference` argument of `sccomp_estimate()` is\ndeprecated as of sccomp 1.7.7.\nℹ The argument approximate_posterior_inference is now deprecated please use\n  variational_inference. By default variational_inference value is inferred\n  from approximate_posterior_inference.\nℹ The deprecated feature was likely used in the sccomp package.\n  Please report the issue at &lt;https://github.com/stemangiola/sccomp/issues&gt;.\n\n\nsccomp says: outlier identification - step 1/2\nsccomp says: outlier-free model fitting - step 2/2\nsccomp says: the composition design matrix has columns: Methodologycell, Methodologynucleus\nsccomp says: the variability design matrix has columns: (Intercept)\n\n# Plot\nres$sig&lt;-  ifelse(res$c_FDR&lt;0.05, \"yes\", \"no\")\nggplot(res, aes(x = factor(integrated_snn_res.0.2, levels= levels(Idents(Humica))),\n                y = res$c_effect, color=sig)) +\n  geom_point(stat = \"Identity\", shape = 15) +\n  scale_color_manual(values = c(\"grey\",\"#A21F16\"))+\n  geom_hline(yintercept = c(-0.2,0.2), linetype = \"dashed\", color = \"grey\") +\n  geom_errorbar(aes(ymin = c_lower, ymax = c_upper), width = 0.4) +\n  facet_wrap(~parameter,scales=\"free\")+\n  ylab(\"Credible interval of the slope\")+\n  xlab(\"Cluster\")+\n  coord_flip()+\n  theme_pubr()+\n  border()\n\nWarning: Use of `res$c_effect` is discouraged.\nℹ Use `c_effect` instead.\n\n\nWarning: Use of `res$c_effect` is discouraged.\nℹ Use `c_effect` instead.\n\n\n\n\n\n\n\n\ndev.off()  \n\nnull device \n          1 \n\n\nPlot the obtained results"
  },
  {
    "objectID": "Characterization of the HuMicA.html",
    "href": "Characterization of the HuMicA.html",
    "title": "Characterization of the HuMicA",
    "section": "",
    "text": "The following script depicts the identification and characterization of the nine populations within the HuMicA, and relates to the results represented in Figure 1 of the paper.\n\n\n\nlibs &lt;- c(\"Seurat\", \"tidyverse\", \"gplots\", \"ComplexHeatmap\",\"circlize\",\"readxl\", \"fgsea\",\"ggpubr\")\nsuppressMessages(\nsuppressWarnings(sapply(libs, require, character.only =TRUE))\n)\n\n        Seurat      tidyverse         gplots ComplexHeatmap       circlize \n          TRUE           TRUE           TRUE           TRUE           TRUE \n        readxl          fgsea         ggpubr \n          TRUE           TRUE           TRUE \n\n\n\n\n\n\ncolor_clusters &lt;-c(\"#fdc835ff\", \"#FC8D62\", \"#7570B3\" ,\"#679436\", \"#D43921\" ,\"#344D67\", \"#874C62\" ,\"#937666\", \"#5B7B7A\" )\nDefaultAssay(Humica)&lt;-\"integrated\"\nDimPlot(Humica, reduction = \"umap\", order = rev(levels(Idents(Humica))),\n        cols = color_clusters, \n        group.by = \"integrated_snn_res.0.2\", raster = FALSE,pt.size =0.001)\n\n\n\n\n\n\n\n\n\n\n\nThe number of cells/nucleis and the mean number of genes per cell/nucleus were calculated for each cluster and represented in a barplot.\n\ncluster0&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"0\"]\ncluster1&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"1\"]\ncluster2&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"2\"]\ncluster3&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"3\"]\ncluster4&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"4\"]\ncluster5&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"5\"]\ncluster6&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"6\"]\ncluster7&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"7\"]\ncluster8&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"8\"]\n\n#\nmain.list &lt;- list(cluster0, cluster1, cluster2,cluster3, cluster4, cluster5,\n                  cluster6, cluster7, cluster8)\n\nmy.files &lt;-c(\"cluster0\", \"cluster1\", \"cluster2\",\"cluster3\", \"cluster4\", \"cluster5\",\n             \"cluster6\", \"cluster7\",\"cluster8\")\n\ndf &lt;- data.frame(Sample=my.files, Nuclei=\"\", Genes=\"\")\nnumber_nuclei= numeric(length(my.files))\nnumber_genes = numeric(length(my.files))\n\nfor (i in 1:length(main.list)) {\n  \n  number_nuclei[i]&lt;- nrow(main.list[[i]]@meta.data)\n  number_genes[i] &lt;- mean(main.list[[i]]@meta.data$nFeature_RNA)\n}\n\ndf$Nuclei = number_nuclei\ndf$Genes = number_genes\ndf$Genes = format(round(df$Genes, 0))\n\ndf$Label &lt;- paste0(df$Nuclei,\"(\",df$Genes,\")\")\ndf &lt;- df[order(df$Nuclei),]\ndf\n\n    Sample Nuclei Genes       Label\n9 cluster8   1563  1305  1563(1305)\n8 cluster7   2425  1281  2425(1281)\n7 cluster6   2616  1468  2616(1468)\n6 cluster5   3195  1303  3195(1303)\n5 cluster4   8559  1344  8559(1344)\n4 cluster3   8635  1069  8635(1069)\n3 cluster2  16186  1371 16186(1371)\n2 cluster1  21974  1281 21974(1281)\n1 cluster0  25563  1281 25563(1281)\n\nggplot(df, aes(x= factor(df$Sample, levels = df$Sample), y=Nuclei, fill=factor(Sample,levels =rev(Sample) ))) +\n  geom_bar(stat=\"identity\",position = \"stack\")+\n  geom_text(aes(label = Label), hjust=0,position = position_fill(vjust = 0), size = 3,colour=\"black\")+\n  coord_flip()+\n  ylab(label = \"Nuclei (mean genes/nuclei)\")+\n  scale_fill_manual(values = color_clusters)+\n  theme_linedraw()+\n  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.text = element_text(colour=\"black\")) +NoLegend()\n\n\n\n\n\n\n\n\n\n\n\nThe prevalence of border-associated macrophages within the HuMicA was tested by checking the expression of canonical microglia (P2RY12, CX3CR1) and macrophage markers (MRC1, CD163). Based on this, we annotated cluster 7 as macrophages.\n\nDefaultAssay(Humica)&lt;-\"RNA\"\nHumica &lt;- NormalizeData(Humica) #gene expression is evaluated using the normalized \"RNA\" assay\n\n# Dotplot\nDotPlot(Humica, features = c(\"P2RY12\",\"CX3CR1\", \"MRC1\",\"CD163\"), dot.scale = 10, group.by =\"integrated_snn_res.0.2\") +\n  scale_colour_gradient2(low = \"darkblue\", mid = \"white\", high = \"darkred\")+\n  #scale_color_viridis_c() +\n  theme(axis.text.x = element_text(angle=90, hjust = 0))+coord_flip()\n\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n\n\n\n\n\n\n\n\n# Feature plot of the Module Score of macrophage markers\nMac_genes &lt;- c(\"MRC1\",\"CD163\")\nHumica &lt;- AddModuleScore(Humica,\n                         features =list(Mac_genes),\n                         name='Mac_genes')\nFeaturePlot(Humica, features = 'Mac_genes1', label = F, repel = TRUE,pt.size = 0.5) & scale_colour_gradientn(colours = c(\"#FCFCFF\",\"#FCFCFF\",\"#DCF2CE\",\"#FFCB77\",\"#BD6B73\",\"#A30B37\"))\n\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n\n\n\n\n\n\n\n\n\n\n\n\nThe markers for each cluster were calculated using FindAllMarkers with the MAST test, min.pct=0.25 and logfc.theshold=0.25. Significant markers were considered for an adj p value (FDR) &lt; 0.05.\n\nHumica.markers &lt;- FindAllMarkers(Humica,assay = \"RNA\", only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25, test.use = \"MAST\") \nsig_markers &lt;- Humica.markers[Humica.markers$p_val_adj&lt;0.05,]\n\n\n\nThe heatmap represents the average gene expression per cluster, which consists of the average expression of all cells/nuclei annotated to each cluster. The heatmap.2 function from gplots is initially used to obtain the z-scores. Then the matrix with the z-scores is represented by the Heatmap function of ComplexHeatmap. In addition, the matching between the genes in the heatmap and microglia-related gene signatures collected from the literature is represented on the left panel. Each black lines represents the presence of one of the markers within each geneset/signature. The “Genesets_literature.xlsx” file has bee added to this repository (“Support data”).\n\nHumica@active.ident &lt;- factor(x = Humica@active.ident, levels = c(\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\"))\nav.exp_cluster &lt;- AverageExpression(Humica)$RNA %&gt;% data.frame()\n\ngenes &lt;- sig_markers$gene\n  \nmat &lt;- as.matrix(av.exp_cluster[genes,])\n\nheatmap &lt;- heatmap.2(mat,Colv = F, Rowv = F, scale=\"row\")\n\n\n\n\n\n\n\nmat_scale &lt;- t(heatmap$carpet)\n\ncol_fun = colorRamp2(c(-4,-2,0,2, 4), c(\"#071E22\",\"#15616D\", \"white\",\"#AA5042\",\"#78290F\"))\n\n\ngenesets$genesets &lt;- paste0(genesets$Population, \"_\",genesets$Study)\ndata &lt;- genes %&gt;% as.data.frame(); colnames(data) &lt;- \"Gene\"\n\ngeneset_list &lt;- c(\"Human_microglia_signature_Gosselin\",\"Microglia_signature_Galatro\",\"up_aging_Galatro\",\n                  \"down_DAM_Keren_shaul_Thrupp\",\"up_DAM_Keren_shaul_Thrupp\",\n                  \"Human_Adult_DAMs_Silvin\", \"Human_Adult_YAMs_Silvin\",\"Human_Adult_DIMs_Silvin\", \n                  \"Mic0_Mathys\",\"Mic1_Mathys\",\"Mic2_Mathys\",\"Mic3_Mathys\",\n                  \"MG1_Olah\",\"MG2_Olah\",\"MG3_Olah\",\"MG4_Olah\",\"MG5_Olah\",\"MG6_Olah\",\"MG7_Olah\",\"MG8_Olah\",\"MG9_Olah\",\n                  \"Micro0_Zhou\",\"Micro1_Zhou\",\n                  \"a_Schirmer\",\"b_Schirmer\",\"c_Schirmer\",\"d_Schirmer\",\"e_Schirmer\",\"f_Schirmer\",\n                  \"0_Gerritis\",\"1_Gerritis\",\"2_Gerritis\",\"3_Gerritis\",\"4_Gerritis\",\"5_Gerritis\",\"6_Gerritis\",\"7_Gerritis\",\"8_Gerritis\",\"9_Gerritis\",\n                  \"10_Gerritis\",\"11_Gerritis\",\"12_Gerritis\",\n                  \"MG0_Sun\",\"MG1_Sun\",\"MG2_Sun\",\"MG3_Sun\",\"MG4_Sun\",\"MG5_Sun\",\"MG6_Sun\",\"MG7_Sun\",\"MG8_Sun\",\"MG10_Sun\",\"MG11_Sun\",\"MG12_Sun\")\n\nhits &lt;- data.frame(Gene=data$Gene)\nfor (i in 1:length(geneset_list)) {\n  \ndf &lt;- data %&gt;% mutate(hit=ifelse(data$Gene %in% genesets[genesets$genesets==geneset_list[i],]$Gene, y=\"1\",no = \"0\"))\ndf&lt;-df[,2] %&gt;% as.data.frame()\ncolnames(df)&lt;- geneset_list[i]\n\nhits&lt;- cbind(hits, df) \n}\n  \n  \n\nrow_ha &lt;- rowAnnotation(Gosselin = hits$Human_microglia_signature_Gosselin, \n                        Galatro = hits$Microglia_signature_Galatro, \n                        aging_Galatro = hits$up_aging_Galatro,\n                        down_DAM = hits$down_DAM_Keren_shaul_Thrupp,\n                        up_DAM = hits$up_DAM_Keren_shaul_Thrupp,\n                        DAMs_Silvin=hits$Human_Adult_DAMs_Silvin,\n                        YAMs_Silvin=hits$Human_Adult_YAMs_Silvin,\n                        DIMs_Silvin=hits$Human_Adult_DIMs_Silvin,\n                        Mic0_Mathys=hits$Mic0_Mathys,\n                        Mic1_Mathys=hits$Mic1_Mathys,\n                        Mic2_Mathys=hits$Mic2_Mathys,\n                        Mic3_Mathys=hits$Mic3_Mathys,\n                        MG1_Olah=hits$MG1_Olah,\n                        MG2_Olah=hits$MG2_Olah,\n                        MG3_Olah=hits$MG3_Olah,\n                        MG4_Olah=hits$MG4_Olah,\n                        MG5_Olah=hits$MG5_Olah,\n                        MG6_Olah=hits$MG6_Olah,\n                        MG7_Olah=hits$MG7_Olah,\n                        MG8_Olah=hits$MG8_Olah,\n                        MG9_Olah=hits$MG9_Olah,\n                        Micro0_Zhou=hits$Micro0_Zhou,\n                        Micro1_Zhou=hits$Micro1_Zhou,\n                        a_Schirmer=hits$a_Schirmer,\n                        b_Schirmer=hits$b_Schirmer,\n                        c_Schirmer=hits$c_Schirmer,\n                        d_Schirmer=hits$d_Schirmer,\n                        e_Schirmer=hits$e_Schirmer,\n                        f_Schirmer=hits$f_Schirmer,\n                        Gerritis_0=hits$`0_Gerritis`,\n                        Gerritis_1=hits$`1_Gerritis`,\n                        Gerritis_2=hits$`2_Gerritis`,\n                        Gerritis_3=hits$`3_Gerritis`,\n                        Gerritis_4=hits$`4_Gerritis`,\n                        Gerritis_5=hits$`5_Gerritis`,\n                        Gerritis_6=hits$`6_Gerritis`,\n                        Gerritis_7=hits$`7_Gerritis`,\n                        Gerritis_8=hits$`8_Gerritis`,\n                        Gerritis_9=hits$`9_Gerritis`,\n                        Gerritis_10=hits$`10_Gerritis`,\n                        Gerritis_11=hits$`11_Gerritis`,\n                        Gerritis_12=hits$`12_Gerritis`,\n                        MG0_Sun=hits$MG0_Sun,\n                        MG1_Sun=hits$MG1_Sun,\n                        MG2_Sun=hits$MG2_Sun,\n                        MG3_Sun=hits$MG3_Sun,\n                        MG4_Sun=hits$MG4_Sun,\n                        MG5_Sun=hits$MG5_Sun,\n                        MG6_Sun=hits$MG6_Sun,\n                        MG7_Sun=hits$MG7_Sun,\n                        MG8_Sun=hits$MG8_Sun,\n                        MG10_Sun=hits$MG10_Sun,\n                        MG11_Sun=hits$MG11_Sun,\n                        MG12_Sun=hits$MG12_Sun,\n          \n                        \n                                  col = list(Gosselin = c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Galatro = c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   aging_Galatro = c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   down_DAM=c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   up_DAM=c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   DAMs_Silvin=c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   YAMs_Silvin=c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   DIMs_Silvin=c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Mic0_Mathys =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Mic1_Mathys =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Mic2_Mathys =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Mic3_Mathys =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG1_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG2_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG3_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG4_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG5_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG6_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG7_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG8_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG9_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Micro0_Zhou =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Micro1_Zhou =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   a_Schirmer =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   b_Schirmer =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   c_Schirmer =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   d_Schirmer =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   e_Schirmer =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   f_Schirmer =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_0 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_1 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_2 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_3 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_4 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_5 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_6 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_7 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_8 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_9 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_10 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_11 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_12 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG0_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG1_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG2_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG3_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG4_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG5_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG6_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG7_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG8_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG10_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG11_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG12_Sun =c(\"1\" =\"black\", \"0\"=\"white\")\n                        ))\n\nHeatmap(mat_scale,row_order = hits$Gene,cluster_rows = F, cluster_columns = F, col = col_fun,border = T,show_row_names = F,right_annotation =  row_ha,\n        row_names_gp = grid::gpar(fontsize = 3))\n\n\n\n\n\n\n\n\n\n\n\n\nGSEA was calculated using the fgsea package. The results from FindAllMarkers with a less significant cutoff were used as cutoff. This intends to account for the broad spectrum of differential expression and not only the significant differentially expressed markers (only.pos = F, min.pct = 0.1, logfc.threshold = 0.0, test.use = “MAST”). Of note, both up and downregulated markers were considered. The avg_log2FC and the p_val_adj were used for ranking.\n\nHumica.markers &lt;- FindAllMarkers(Humica,assay = \"RNA\", only.pos = F, min.pct = 0.1, logfc.threshold = 0.0, test.use = \"MAST\") \n\n\ngenesets &lt;- split(x=genesets$Gene, f=genesets$genesets)\n\nclusterlist &lt;- c(\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\")\np &lt;- list()\nresults &lt;- data.frame()\nfor (i in 1:length(clusterlist)) {\n  print(clusterlist[i])\n  genes &lt;- Humica.markers[Humica.markers$cluster==clusterlist[i],]\n  genes&lt;- structure(genes$avg_log2FC, names=genes$gene)\n  genes &lt;- fgsea(pathways =genesets, \n                 stats    = genes,\n                 scoreType =\"pos\",\n                 minSize  = 0,\n                 maxSize = Inf)\n  genes &lt;- as.data.frame(apply(genes, 2, as.character))\n  genes&lt;- as.data.frame(genes) %&gt;% mutate(cluster = clusterlist[i])\n  \n  results &lt;- rbind(results,genes)\n}\n\n\n\nThe normalized enrichmant score (NES) and the negative of the logarithm of the p value were used as significance metrics.\n\nresults$padj&lt;- as.numeric(results$padj)\nresults$LOG &lt;- -log10(results$padj)\nresults$NES &lt;- as.numeric(results$NES)\n\nrow_order &lt;- c(\"Human_microglia_signature_Gosselin\",\"Microglia_signature_Galatro\",\"up_aging_Galatro\",\n               \"down_DAM_Keren_shaul_Thrupp\",\"up_DAM_Keren_shaul_Thrupp\",\n               \"Human_Adult_DAMs_Silvin\", \"Human_Adult_YAMs_Silvin\",\"Human_Adult_DIMs_Silvin\", \n               \"Mic0_Mathys\",\"Mic1_Mathys\",\"Mic2_Mathys\",\"Mic3_Mathys\",\n               \"MG1_Olah\",\"MG2_Olah\",\"MG3_Olah\",\"MG4_Olah\",\"MG5_Olah\",\"MG6_Olah\",\"MG7_Olah\",\"MG8_Olah\",\"MG9_Olah\",\n               \"Micro0_Zhou\",\"Micro1_Zhou\",\n               \"a_Schirmer\",\"b_Schirmer\",\"c_Schirmer\",\"d_Schirmer\",\"e_Schirmer\",\"f_Schirmer\",\n               \"0_Gerritis\",\"1_Gerritis\",\"2_Gerritis\",\"3_Gerritis\",\"4_Gerritis\",\"5_Gerritis\",\"6_Gerritis\",\"7_Gerritis\",\"8_Gerritis\",\"9_Gerritis\",\n               \"10_Gerritis\",\"11_Gerritis\",\"12_Gerritis\",\n               \"MG0_Sun\",\"MG1_Sun\",\"MG2_Sun\",\"MG3_Sun\",\"MG4_Sun\",\"MG5_Sun\",\"MG6_Sun\",\"MG7_Sun\",\"MG8_Sun\",\"MG10_Sun\",\"MG11_Sun\",\"MG12_Sun\")\n\nggplot(results, aes(factor(pathway, levels=row_order), factor(cluster, \n                                                              levels = c(\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\",\"0\")),\n                                                              colour = LOG)) +\n  geom_point(aes(size = NES)) +\n  theme_pubr() + \n  scale_size_continuous(range = c(1, 8))+\n  scale_color_gradient(low = \"white\",high = \"darkred\")+\n  scale_shape_manual(values = c(significant = 16, \"non-significant\" = NA)) +\n    border() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1),panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.text = element_text(colour=\"black\"),\n      axis.title.y = element_blank())"
  },
  {
    "objectID": "Characterization of the HuMicA.html#characterization-of-the-humica-integrated-object",
    "href": "Characterization of the HuMicA.html#characterization-of-the-humica-integrated-object",
    "title": "Characterization of the HuMicA",
    "section": "",
    "text": "The following script depicts the identification and characterization of the nine populations within the HuMicA, and relates to the results represented in Figure 1 of the paper.\n\n\n\nlibs &lt;- c(\"Seurat\", \"tidyverse\", \"gplots\", \"ComplexHeatmap\",\"circlize\",\"readxl\", \"fgsea\",\"ggpubr\")\nsuppressMessages(\nsuppressWarnings(sapply(libs, require, character.only =TRUE))\n)\n\n        Seurat      tidyverse         gplots ComplexHeatmap       circlize \n          TRUE           TRUE           TRUE           TRUE           TRUE \n        readxl          fgsea         ggpubr \n          TRUE           TRUE           TRUE \n\n\n\n\n\n\ncolor_clusters &lt;-c(\"#fdc835ff\", \"#FC8D62\", \"#7570B3\" ,\"#679436\", \"#D43921\" ,\"#344D67\", \"#874C62\" ,\"#937666\", \"#5B7B7A\" )\nDefaultAssay(Humica)&lt;-\"integrated\"\nDimPlot(Humica, reduction = \"umap\", order = rev(levels(Idents(Humica))),\n        cols = color_clusters, \n        group.by = \"integrated_snn_res.0.2\", raster = FALSE,pt.size =0.001)\n\n\n\n\n\n\n\n\n\n\n\nThe number of cells/nucleis and the mean number of genes per cell/nucleus were calculated for each cluster and represented in a barplot.\n\ncluster0&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"0\"]\ncluster1&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"1\"]\ncluster2&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"2\"]\ncluster3&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"3\"]\ncluster4&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"4\"]\ncluster5&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"5\"]\ncluster6&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"6\"]\ncluster7&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"7\"]\ncluster8&lt;- Humica[,Humica@meta.data$integrated_snn_res.0.2==\"8\"]\n\n#\nmain.list &lt;- list(cluster0, cluster1, cluster2,cluster3, cluster4, cluster5,\n                  cluster6, cluster7, cluster8)\n\nmy.files &lt;-c(\"cluster0\", \"cluster1\", \"cluster2\",\"cluster3\", \"cluster4\", \"cluster5\",\n             \"cluster6\", \"cluster7\",\"cluster8\")\n\ndf &lt;- data.frame(Sample=my.files, Nuclei=\"\", Genes=\"\")\nnumber_nuclei= numeric(length(my.files))\nnumber_genes = numeric(length(my.files))\n\nfor (i in 1:length(main.list)) {\n  \n  number_nuclei[i]&lt;- nrow(main.list[[i]]@meta.data)\n  number_genes[i] &lt;- mean(main.list[[i]]@meta.data$nFeature_RNA)\n}\n\ndf$Nuclei = number_nuclei\ndf$Genes = number_genes\ndf$Genes = format(round(df$Genes, 0))\n\ndf$Label &lt;- paste0(df$Nuclei,\"(\",df$Genes,\")\")\ndf &lt;- df[order(df$Nuclei),]\ndf\n\n    Sample Nuclei Genes       Label\n9 cluster8   1563  1305  1563(1305)\n8 cluster7   2425  1281  2425(1281)\n7 cluster6   2616  1468  2616(1468)\n6 cluster5   3195  1303  3195(1303)\n5 cluster4   8559  1344  8559(1344)\n4 cluster3   8635  1069  8635(1069)\n3 cluster2  16186  1371 16186(1371)\n2 cluster1  21974  1281 21974(1281)\n1 cluster0  25563  1281 25563(1281)\n\nggplot(df, aes(x= factor(df$Sample, levels = df$Sample), y=Nuclei, fill=factor(Sample,levels =rev(Sample) ))) +\n  geom_bar(stat=\"identity\",position = \"stack\")+\n  geom_text(aes(label = Label), hjust=0,position = position_fill(vjust = 0), size = 3,colour=\"black\")+\n  coord_flip()+\n  ylab(label = \"Nuclei (mean genes/nuclei)\")+\n  scale_fill_manual(values = color_clusters)+\n  theme_linedraw()+\n  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.text = element_text(colour=\"black\")) +NoLegend()\n\n\n\n\n\n\n\n\n\n\n\nThe prevalence of border-associated macrophages within the HuMicA was tested by checking the expression of canonical microglia (P2RY12, CX3CR1) and macrophage markers (MRC1, CD163). Based on this, we annotated cluster 7 as macrophages.\n\nDefaultAssay(Humica)&lt;-\"RNA\"\nHumica &lt;- NormalizeData(Humica) #gene expression is evaluated using the normalized \"RNA\" assay\n\n# Dotplot\nDotPlot(Humica, features = c(\"P2RY12\",\"CX3CR1\", \"MRC1\",\"CD163\"), dot.scale = 10, group.by =\"integrated_snn_res.0.2\") +\n  scale_colour_gradient2(low = \"darkblue\", mid = \"white\", high = \"darkred\")+\n  #scale_color_viridis_c() +\n  theme(axis.text.x = element_text(angle=90, hjust = 0))+coord_flip()\n\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n\n\n\n\n\n\n\n\n# Feature plot of the Module Score of macrophage markers\nMac_genes &lt;- c(\"MRC1\",\"CD163\")\nHumica &lt;- AddModuleScore(Humica,\n                         features =list(Mac_genes),\n                         name='Mac_genes')\nFeaturePlot(Humica, features = 'Mac_genes1', label = F, repel = TRUE,pt.size = 0.5) & scale_colour_gradientn(colours = c(\"#FCFCFF\",\"#FCFCFF\",\"#DCF2CE\",\"#FFCB77\",\"#BD6B73\",\"#A30B37\"))\n\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n\n\n\n\n\n\n\n\n\n\n\n\nThe markers for each cluster were calculated using FindAllMarkers with the MAST test, min.pct=0.25 and logfc.theshold=0.25. Significant markers were considered for an adj p value (FDR) &lt; 0.05.\n\nHumica.markers &lt;- FindAllMarkers(Humica,assay = \"RNA\", only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25, test.use = \"MAST\") \nsig_markers &lt;- Humica.markers[Humica.markers$p_val_adj&lt;0.05,]\n\n\n\nThe heatmap represents the average gene expression per cluster, which consists of the average expression of all cells/nuclei annotated to each cluster. The heatmap.2 function from gplots is initially used to obtain the z-scores. Then the matrix with the z-scores is represented by the Heatmap function of ComplexHeatmap. In addition, the matching between the genes in the heatmap and microglia-related gene signatures collected from the literature is represented on the left panel. Each black lines represents the presence of one of the markers within each geneset/signature. The “Genesets_literature.xlsx” file has bee added to this repository (“Support data”).\n\nHumica@active.ident &lt;- factor(x = Humica@active.ident, levels = c(\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\"))\nav.exp_cluster &lt;- AverageExpression(Humica)$RNA %&gt;% data.frame()\n\ngenes &lt;- sig_markers$gene\n  \nmat &lt;- as.matrix(av.exp_cluster[genes,])\n\nheatmap &lt;- heatmap.2(mat,Colv = F, Rowv = F, scale=\"row\")\n\n\n\n\n\n\n\nmat_scale &lt;- t(heatmap$carpet)\n\ncol_fun = colorRamp2(c(-4,-2,0,2, 4), c(\"#071E22\",\"#15616D\", \"white\",\"#AA5042\",\"#78290F\"))\n\n\ngenesets$genesets &lt;- paste0(genesets$Population, \"_\",genesets$Study)\ndata &lt;- genes %&gt;% as.data.frame(); colnames(data) &lt;- \"Gene\"\n\ngeneset_list &lt;- c(\"Human_microglia_signature_Gosselin\",\"Microglia_signature_Galatro\",\"up_aging_Galatro\",\n                  \"down_DAM_Keren_shaul_Thrupp\",\"up_DAM_Keren_shaul_Thrupp\",\n                  \"Human_Adult_DAMs_Silvin\", \"Human_Adult_YAMs_Silvin\",\"Human_Adult_DIMs_Silvin\", \n                  \"Mic0_Mathys\",\"Mic1_Mathys\",\"Mic2_Mathys\",\"Mic3_Mathys\",\n                  \"MG1_Olah\",\"MG2_Olah\",\"MG3_Olah\",\"MG4_Olah\",\"MG5_Olah\",\"MG6_Olah\",\"MG7_Olah\",\"MG8_Olah\",\"MG9_Olah\",\n                  \"Micro0_Zhou\",\"Micro1_Zhou\",\n                  \"a_Schirmer\",\"b_Schirmer\",\"c_Schirmer\",\"d_Schirmer\",\"e_Schirmer\",\"f_Schirmer\",\n                  \"0_Gerritis\",\"1_Gerritis\",\"2_Gerritis\",\"3_Gerritis\",\"4_Gerritis\",\"5_Gerritis\",\"6_Gerritis\",\"7_Gerritis\",\"8_Gerritis\",\"9_Gerritis\",\n                  \"10_Gerritis\",\"11_Gerritis\",\"12_Gerritis\",\n                  \"MG0_Sun\",\"MG1_Sun\",\"MG2_Sun\",\"MG3_Sun\",\"MG4_Sun\",\"MG5_Sun\",\"MG6_Sun\",\"MG7_Sun\",\"MG8_Sun\",\"MG10_Sun\",\"MG11_Sun\",\"MG12_Sun\")\n\nhits &lt;- data.frame(Gene=data$Gene)\nfor (i in 1:length(geneset_list)) {\n  \ndf &lt;- data %&gt;% mutate(hit=ifelse(data$Gene %in% genesets[genesets$genesets==geneset_list[i],]$Gene, y=\"1\",no = \"0\"))\ndf&lt;-df[,2] %&gt;% as.data.frame()\ncolnames(df)&lt;- geneset_list[i]\n\nhits&lt;- cbind(hits, df) \n}\n  \n  \n\nrow_ha &lt;- rowAnnotation(Gosselin = hits$Human_microglia_signature_Gosselin, \n                        Galatro = hits$Microglia_signature_Galatro, \n                        aging_Galatro = hits$up_aging_Galatro,\n                        down_DAM = hits$down_DAM_Keren_shaul_Thrupp,\n                        up_DAM = hits$up_DAM_Keren_shaul_Thrupp,\n                        DAMs_Silvin=hits$Human_Adult_DAMs_Silvin,\n                        YAMs_Silvin=hits$Human_Adult_YAMs_Silvin,\n                        DIMs_Silvin=hits$Human_Adult_DIMs_Silvin,\n                        Mic0_Mathys=hits$Mic0_Mathys,\n                        Mic1_Mathys=hits$Mic1_Mathys,\n                        Mic2_Mathys=hits$Mic2_Mathys,\n                        Mic3_Mathys=hits$Mic3_Mathys,\n                        MG1_Olah=hits$MG1_Olah,\n                        MG2_Olah=hits$MG2_Olah,\n                        MG3_Olah=hits$MG3_Olah,\n                        MG4_Olah=hits$MG4_Olah,\n                        MG5_Olah=hits$MG5_Olah,\n                        MG6_Olah=hits$MG6_Olah,\n                        MG7_Olah=hits$MG7_Olah,\n                        MG8_Olah=hits$MG8_Olah,\n                        MG9_Olah=hits$MG9_Olah,\n                        Micro0_Zhou=hits$Micro0_Zhou,\n                        Micro1_Zhou=hits$Micro1_Zhou,\n                        a_Schirmer=hits$a_Schirmer,\n                        b_Schirmer=hits$b_Schirmer,\n                        c_Schirmer=hits$c_Schirmer,\n                        d_Schirmer=hits$d_Schirmer,\n                        e_Schirmer=hits$e_Schirmer,\n                        f_Schirmer=hits$f_Schirmer,\n                        Gerritis_0=hits$`0_Gerritis`,\n                        Gerritis_1=hits$`1_Gerritis`,\n                        Gerritis_2=hits$`2_Gerritis`,\n                        Gerritis_3=hits$`3_Gerritis`,\n                        Gerritis_4=hits$`4_Gerritis`,\n                        Gerritis_5=hits$`5_Gerritis`,\n                        Gerritis_6=hits$`6_Gerritis`,\n                        Gerritis_7=hits$`7_Gerritis`,\n                        Gerritis_8=hits$`8_Gerritis`,\n                        Gerritis_9=hits$`9_Gerritis`,\n                        Gerritis_10=hits$`10_Gerritis`,\n                        Gerritis_11=hits$`11_Gerritis`,\n                        Gerritis_12=hits$`12_Gerritis`,\n                        MG0_Sun=hits$MG0_Sun,\n                        MG1_Sun=hits$MG1_Sun,\n                        MG2_Sun=hits$MG2_Sun,\n                        MG3_Sun=hits$MG3_Sun,\n                        MG4_Sun=hits$MG4_Sun,\n                        MG5_Sun=hits$MG5_Sun,\n                        MG6_Sun=hits$MG6_Sun,\n                        MG7_Sun=hits$MG7_Sun,\n                        MG8_Sun=hits$MG8_Sun,\n                        MG10_Sun=hits$MG10_Sun,\n                        MG11_Sun=hits$MG11_Sun,\n                        MG12_Sun=hits$MG12_Sun,\n          \n                        \n                                  col = list(Gosselin = c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Galatro = c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   aging_Galatro = c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   down_DAM=c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   up_DAM=c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   DAMs_Silvin=c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   YAMs_Silvin=c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   DIMs_Silvin=c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Mic0_Mathys =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Mic1_Mathys =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Mic2_Mathys =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Mic3_Mathys =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG1_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG2_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG3_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG4_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG5_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG6_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG7_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG8_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG9_Olah =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Micro0_Zhou =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Micro1_Zhou =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   a_Schirmer =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   b_Schirmer =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   c_Schirmer =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   d_Schirmer =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   e_Schirmer =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   f_Schirmer =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_0 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_1 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_2 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_3 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_4 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_5 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_6 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_7 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_8 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_9 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_10 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_11 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   Gerritis_12 =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG0_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG1_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG2_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG3_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG4_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG5_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG6_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG7_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG8_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG10_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG11_Sun =c(\"1\" =\"black\", \"0\"=\"white\"),\n                                   MG12_Sun =c(\"1\" =\"black\", \"0\"=\"white\")\n                        ))\n\nHeatmap(mat_scale,row_order = hits$Gene,cluster_rows = F, cluster_columns = F, col = col_fun,border = T,show_row_names = F,right_annotation =  row_ha,\n        row_names_gp = grid::gpar(fontsize = 3))\n\n\n\n\n\n\n\n\n\n\n\n\nGSEA was calculated using the fgsea package. The results from FindAllMarkers with a less significant cutoff were used as cutoff. This intends to account for the broad spectrum of differential expression and not only the significant differentially expressed markers (only.pos = F, min.pct = 0.1, logfc.threshold = 0.0, test.use = “MAST”). Of note, both up and downregulated markers were considered. The avg_log2FC and the p_val_adj were used for ranking.\n\nHumica.markers &lt;- FindAllMarkers(Humica,assay = \"RNA\", only.pos = F, min.pct = 0.1, logfc.threshold = 0.0, test.use = \"MAST\") \n\n\ngenesets &lt;- split(x=genesets$Gene, f=genesets$genesets)\n\nclusterlist &lt;- c(\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\")\np &lt;- list()\nresults &lt;- data.frame()\nfor (i in 1:length(clusterlist)) {\n  print(clusterlist[i])\n  genes &lt;- Humica.markers[Humica.markers$cluster==clusterlist[i],]\n  genes&lt;- structure(genes$avg_log2FC, names=genes$gene)\n  genes &lt;- fgsea(pathways =genesets, \n                 stats    = genes,\n                 scoreType =\"pos\",\n                 minSize  = 0,\n                 maxSize = Inf)\n  genes &lt;- as.data.frame(apply(genes, 2, as.character))\n  genes&lt;- as.data.frame(genes) %&gt;% mutate(cluster = clusterlist[i])\n  \n  results &lt;- rbind(results,genes)\n}\n\n\n\nThe normalized enrichmant score (NES) and the negative of the logarithm of the p value were used as significance metrics.\n\nresults$padj&lt;- as.numeric(results$padj)\nresults$LOG &lt;- -log10(results$padj)\nresults$NES &lt;- as.numeric(results$NES)\n\nrow_order &lt;- c(\"Human_microglia_signature_Gosselin\",\"Microglia_signature_Galatro\",\"up_aging_Galatro\",\n               \"down_DAM_Keren_shaul_Thrupp\",\"up_DAM_Keren_shaul_Thrupp\",\n               \"Human_Adult_DAMs_Silvin\", \"Human_Adult_YAMs_Silvin\",\"Human_Adult_DIMs_Silvin\", \n               \"Mic0_Mathys\",\"Mic1_Mathys\",\"Mic2_Mathys\",\"Mic3_Mathys\",\n               \"MG1_Olah\",\"MG2_Olah\",\"MG3_Olah\",\"MG4_Olah\",\"MG5_Olah\",\"MG6_Olah\",\"MG7_Olah\",\"MG8_Olah\",\"MG9_Olah\",\n               \"Micro0_Zhou\",\"Micro1_Zhou\",\n               \"a_Schirmer\",\"b_Schirmer\",\"c_Schirmer\",\"d_Schirmer\",\"e_Schirmer\",\"f_Schirmer\",\n               \"0_Gerritis\",\"1_Gerritis\",\"2_Gerritis\",\"3_Gerritis\",\"4_Gerritis\",\"5_Gerritis\",\"6_Gerritis\",\"7_Gerritis\",\"8_Gerritis\",\"9_Gerritis\",\n               \"10_Gerritis\",\"11_Gerritis\",\"12_Gerritis\",\n               \"MG0_Sun\",\"MG1_Sun\",\"MG2_Sun\",\"MG3_Sun\",\"MG4_Sun\",\"MG5_Sun\",\"MG6_Sun\",\"MG7_Sun\",\"MG8_Sun\",\"MG10_Sun\",\"MG11_Sun\",\"MG12_Sun\")\n\nggplot(results, aes(factor(pathway, levels=row_order), factor(cluster, \n                                                              levels = c(\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\",\"0\")),\n                                                              colour = LOG)) +\n  geom_point(aes(size = NES)) +\n  theme_pubr() + \n  scale_size_continuous(range = c(1, 8))+\n  scale_color_gradient(low = \"white\",high = \"darkred\")+\n  scale_shape_manual(values = c(significant = 16, \"non-significant\" = NA)) +\n    border() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1),panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.text = element_text(colour=\"black\"),\n      axis.title.y = element_blank())"
  },
  {
    "objectID": "Homeostatic clusters.html",
    "href": "Homeostatic clusters.html",
    "title": "Homeostatic clusters",
    "section": "",
    "text": "This script depicts the specific and in-depth characterization of the homeostatic clusters, including gene markers, gene ontology and transcription factor enrichment, related to Figure 2.\n\n\n\nlibs &lt;- c(\"Seurat\", \"tidyverse\", \"clusterProfiler\",\"viper\",\"dorothea\",\"org.Hs.eg.db\",\"ggrepel\",\"gridExtra\",\"ggpubr\",\"data.table\")\nsuppressMessages(\nsuppressWarnings(sapply(libs, require, character.only =TRUE))\n)\n\n         Seurat       tidyverse clusterProfiler           viper        dorothea \n           TRUE            TRUE            TRUE            TRUE            TRUE \n   org.Hs.eg.db         ggrepel       gridExtra          ggpubr      data.table \n           TRUE            TRUE            TRUE            TRUE            TRUE \n\n\n\n\n\nDendrogram accounting for the averaged gene expression of the cluster markers (from Figure 1F) per cluster. The “RNA” assay was used. The calculation of the significant cluster markers is depicted at the “Characterization of the HuMicA” script from this repository.\n\ngenes &lt;- sig_markers$gene\nmat &lt;- AverageExpression(Humica)$RNA %&gt;% data.frame()\nmat &lt;- mat[genes,] %&gt;% as.matrix() \n\nseeds_df_sc &lt;- as.data.frame(scale(mat))\nsummary(seeds_df_sc)\n\n\nhc &lt;-hclust(as.dist(1-cor(seeds_df_sc, method=\"spearman\")), method=\"ward.D\") \nsampleTree = as.dendrogram(hc)\n\nplot(sampleTree)\n\n\n\n\n\n\n\n\n\n\n\nThe representation of the HuMicA object was edited to depict only the four homeostatic populations, namely clusters 0 (Homeos1), 4 (Homeos2) and 8 (Homeos3).\n\ncolor_clusters &lt;-c(\"#fdc835ff\", \"white\", \"white\" ,\"white\", \"#D43921\" ,\"white\", \"white\" ,\"white\", \"#5B7B7A\")\nDimPlot(Humica, reduction = \"umap\",cols = color_clusters, repel = TRUE, pt.size = 0.01, label = F)+NoLegend()\n\n\n\n\n\n\n\n\n\n\n\nThe top 10 signigicant markers for clusters 0, 4 and 8 were represented.\n\n\n\nhomeos_markers &lt;- sig_markers[sig_markers$cluster %in% c(\"0\",\"4\",\"8\"),]\nhomeos_markers$avg_log2FC&lt;- as.numeric(homeos_markers$avg_log2FC)\n\nhomeos_markers %&gt;%\n  group_by(cluster) %&gt;% arrange(-avg_log2FC) %&gt;% arrange(cluster) %&gt;% \n  top_n(n = 10, wt = avg_log2FC)-&gt; top10_up \n\nDefaultAssay(Humica) &lt;- \"RNA\"\nHumica&lt;- NormalizeData(Humica)\n\nDotPlot(Humica, features = factor(rev(top10_up$gene %&gt;% unique), levels = rev(top10_up$gene %&gt;% unique)) , dot.scale = 10) +\n  scale_colour_gradient2(low = \"darkblue\", mid = \"white\", high = \"darkred\")+\n  theme(axis.text.x = element_text(angle=90, hjust = 0))+coord_flip()\n\n\n\n\n\n\n\n\n\n\n\nThe most prominent markers of each cluster were represented separately in Feature plots: P2RY12 and KBTBD12 for Homeos1; GRID2 for Homeos2; SERPINE1 for Homeos3 (related to Supplementary Figure 6A).\n\nHumica &lt;- SetIdent(Humica, value = Humica@meta.data$integrated_snn_res.0.2)\nDefaultAssay(Humica)&lt;-\"RNA\"\nHumica &lt;- NormalizeData(Humica)\n\nFeaturePlot(Humica, features = c(\"P2RY12\",\"KBTBD12\",\"GRID2\",\"SERPINE1\"), ncol=4,label = F, repel = TRUE,pt.size = 0.5) & scale_colour_gradientn(colours = c(\"#FCFCFF\",\"#FCFCFF\",\"#DCF2CE\",\"#FFCB77\",\"#BD6B73\",\"#A30B37\"))\n\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n\n\n\n\n\n\n\n\n\n\n\n\n\nGene ontology (GO) was calculated with the enrichGO function from clusterProfiler.\n\n\nGO enrichment was calculated for the list of markers of each homeostatic cluster. The simplify function was used to remove redundancy to the obtained results. The cnetplots were set to represent only the top 3 categories.\n\ni=0\n\np &lt;- list()\nfor(comparison in levels(factor(homeos_markers$cluster))){\n  i = i+1\n  print(paste(comparison))\n  \n  ego &lt;- enrichGO(gene              = homeos_markers[homeos_markers$cluster == comparison,]$gene,\n                  OrgDb             = org.Hs.eg.db,\n                  ont               = \"ALL\",\n                  keyType           = \"SYMBOL\",\n                  pAdjustMethod     = \"BH\",\n                  pvalueCutoff      = 1,\n                  qvalueCutoff      = 0.05,\n                  readable          = T )\n  ego &lt;- simplify(ego, cutoff=0.7, by=\"p.adjust\", select_fun=min)\n  \n  geneList &lt;- homeos_markers[homeos_markers$cluster==comparison,]$avg_log2FC\n  names(geneList)&lt;-homeos_markers[homeos_markers$cluster==comparison,]$gene\n  \n  p[[i]]&lt;- cnetplot(ego, cex_label_category=1,colorEdge = F,shadowtext=\"none\",showCategory = 3,categorySize=\"pvalue\", foldChange =geneList, color_category=\"#339989\") + ggtitle(comparison) &\n    scale_colour_gradient2(high = \"#8B0000\", low=\"#371E97\", midpoint = 0)\n}\n\np[1]\n\n\n\n\n\n\n\np[2]\n\n\n\n\n\n\n\np[3]\n\n\n\n\n\n\n\n\n\n\n\nThe top 10 significant GO terms for each of the homeostatic clusters were represented in barplots to provide a broader insight on the GO enrichment (related to Supplementary Figure 6B). GO was recalculated and edited to obtain the Fold Change of enrichment.\n\ni = 0\nresults &lt;- list()\ngo_all_simplify &lt;- data.frame()\nfor(comparison in levels(factor(homeos_markers$cluster))){\n  i = i+1\n  print(paste(comparison))\n  ego &lt;- enrichGO(gene              = homeos_markers[homeos_markers$cluster == comparison,]$gene,\n                  OrgDb             = org.Hs.eg.db,\n                  ont               = \"ALL\",\n                  keyType           = \"SYMBOL\",\n                  pAdjustMethod     = \"BH\",\n                  pvalueCutoff      = 1,\n                  qvalueCutoff      = 0.05,\n                  readable          = T )\n  ego &lt;- simplify(ego, cutoff=0.7, by=\"p.adjust\", select_fun=min)\n  \n  results[[comparison]] &lt;- ego@result %&gt;%\n    separate(GeneRatio, into = c(\"gene_pos\", \"gene_total\"), sep = \"/\") %&gt;%\n    separate(BgRatio, into = c(\"bg_pos\", \"bg_total\"), sep = \"/\") %&gt;%\n    mutate(FC = (as.numeric(gene_pos)/as.numeric(gene_total)) /\n             (as.numeric(bg_pos)/as.numeric(bg_total)),\n           cluster = comparison) %&gt;%\n    arrange(.$p.adjust)\n  go_all_simplify &lt;- rbind(go_all_simplify, results[[comparison]])\n}\n\n[1] \"0\"\n[1] \"4\"\n[1] \"8\"\n\n\n\nclusterlist &lt;- c(\"0\",\"4\",\"8\")\np&lt;-list()\nfor (i in 1:length(clusterlist)) {\n  data &lt;-go_all_simplify[go_all_simplify$cluster==clusterlist[i],]\n  data$logpadj &lt;- -log10(data$p.adjust)\n  data$logFC&lt;- log10(data$FC)\n  top10 &lt;- data %&gt;%top_n(n = 10, wt = logpadj)\n  top10 &lt;- top10[1:10,]\n  \n  \n  p[[i]]&lt;- ggplot(top10,\n                  aes(fill=logFC,\n                      x=factor(ID, level = rev(ID)),\n                      y=logpadj,\n                      color=\"black\")) +\n    geom_col(color=\"black\", size=0.2) +\n    geom_text(aes(label = Description), hjust=0,position = position_fill(vjust = 0), size = 4, color=\"black\")+\n    theme_bw() +\n    scale_fill_gradientn(colours = c(\"#B9CFD4\",\"#AFAAB9\",\"#B48291\",\"#8C5465\"))+\n    #scale_fill_viridis(option = \"plasma\")+\n    coord_flip()\n}\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\ndo.call(grid.arrange,p)\n\n\n\n\n\n\n\n\n\n\n\n\nThe collection of transcription factors (TFs) and their target genes was obtained from the DoRothEA regulon A. The enrichment analysis was performed using the viper package. The regulon object downloaded from https://github.com/deeenes/DoRothEA/tree/master/data/TFregulons/Robjects_VIPERformat/consensus, already in the appropriate format to be used in the viper pipeline. The Humica.markers file correspond to the broad spectrum differential expression output, mentioned in the “Characterization of the HuMicA” script of this repository. The following represents the loop for the calculation of TF enrichment in all nine clusters.\n\nregulon_A&lt;- viper_regulon\nnames(regulon_A)=sapply(strsplit(names(regulon_A),split=\" - \"),head, 1)\n\nlist &lt;- unique(Humica_markers$cluster)\nTF_activities_all &lt;- data.frame()\n\nfor (i in 1:length(list)) {\n\ndata &lt;- Humica_markers[Humica_markers$cluster==list[i],]\n\n#Exclude probes with unknown or duplicated gene symbol\nDEsignature = subset(data, gene != \"\" )\n\nDEsignature = subset(DEsignature, ! duplicated(gene))\n\n# Estimatez-score values for the GES. Cheeck VIPER manual for details\n\nmyStatistics = matrix(DEsignature$avg_log2FC, dimnames = list(DEsignature$gene,\n                                                              \n                                                              'avg_log2FC') )\n\nmyPvalue = matrix(DEsignature$p_val_adj, dimnames = list(DEsignature$gene, 'padj') )\n\nmySignature = (qnorm(myPvalue/2, lower.tail = FALSE) * sign(myStatistics))[, 1]\n\nmySignature = mySignature[order(mySignature, decreasing = T)]\n\n# Estimate TF activities\n\nmrs = msviper(ges = mySignature, regulon = regulon_A,minsize = 25, ges.filter = F)\n\nTF_activities = data.frame(Regulon = names(mrs$es$nes),\n                           \n                           Size = mrs$es$size[ names(mrs$es$nes) ],\n                           \n                           NES = mrs$es$nes,\n                           \n                           p.value = mrs$es$p.value,\n                           \n                           FDR = p.adjust(mrs$es$p.value, method = 'fdr'))\n\nTF_activities = TF_activities[ order(TF_activities$p.value), ]\nTF_activities$cluster &lt;- list[i]\nTF_activities_all&lt;- rbind(TF_activities_all, TF_activities)\n}\n\n\n\nThe plot depicts the enrichment for all clusters in the HuMicA but only considers the significant TFs for the three homeostatic clusters is considered for representation. The statistically significant TFs were considered for an adj p value (FDR) &lt; 0.05.\n\nTF_activities_homeos &lt;- TF_activities_all[TF_activities_all$cluster %in% c(\"0\",\"4\",\"8\"),]\n\nTF_activities_homeos_sig &lt;- TF_activities_homeos[TF_activities_homeos$FDR &lt; 0.05,]\n\n#Plot TF enrichment results\nTF_activities_all &lt;- TF_activities_all%&gt;% \n  mutate(logFDR = -log(FDR))\n\ncommon_features &lt;- TF_activities_homeos_sig$Regulon %&gt;% unique()\n\nggplot(TF_activities_all %&gt;% dplyr::filter(Regulon %in% common_features), aes(as.factor(cluster), y= factor(Regulon, levels = common_features),color=NES,size =logFDR)) +\n  geom_point() +\n  scale_color_gradient2(low=\"#47663D\",mid = \"white\",high=\"#B86B00\")+\n  theme_pubr(border = 1)+ \n  coord_flip()+\n  theme(axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5))"
  },
  {
    "objectID": "Homeostatic clusters.html#homeostatic-clusters",
    "href": "Homeostatic clusters.html#homeostatic-clusters",
    "title": "Homeostatic clusters",
    "section": "",
    "text": "This script depicts the specific and in-depth characterization of the homeostatic clusters, including gene markers, gene ontology and transcription factor enrichment, related to Figure 2.\n\n\n\nlibs &lt;- c(\"Seurat\", \"tidyverse\", \"clusterProfiler\",\"viper\",\"dorothea\",\"org.Hs.eg.db\",\"ggrepel\",\"gridExtra\",\"ggpubr\",\"data.table\")\nsuppressMessages(\nsuppressWarnings(sapply(libs, require, character.only =TRUE))\n)\n\n         Seurat       tidyverse clusterProfiler           viper        dorothea \n           TRUE            TRUE            TRUE            TRUE            TRUE \n   org.Hs.eg.db         ggrepel       gridExtra          ggpubr      data.table \n           TRUE            TRUE            TRUE            TRUE            TRUE \n\n\n\n\n\nDendrogram accounting for the averaged gene expression of the cluster markers (from Figure 1F) per cluster. The “RNA” assay was used. The calculation of the significant cluster markers is depicted at the “Characterization of the HuMicA” script from this repository.\n\ngenes &lt;- sig_markers$gene\nmat &lt;- AverageExpression(Humica)$RNA %&gt;% data.frame()\nmat &lt;- mat[genes,] %&gt;% as.matrix() \n\nseeds_df_sc &lt;- as.data.frame(scale(mat))\nsummary(seeds_df_sc)\n\n\nhc &lt;-hclust(as.dist(1-cor(seeds_df_sc, method=\"spearman\")), method=\"ward.D\") \nsampleTree = as.dendrogram(hc)\n\nplot(sampleTree)\n\n\n\n\n\n\n\n\n\n\n\nThe representation of the HuMicA object was edited to depict only the four homeostatic populations, namely clusters 0 (Homeos1), 4 (Homeos2) and 8 (Homeos3).\n\ncolor_clusters &lt;-c(\"#fdc835ff\", \"white\", \"white\" ,\"white\", \"#D43921\" ,\"white\", \"white\" ,\"white\", \"#5B7B7A\")\nDimPlot(Humica, reduction = \"umap\",cols = color_clusters, repel = TRUE, pt.size = 0.01, label = F)+NoLegend()\n\n\n\n\n\n\n\n\n\n\n\nThe top 10 signigicant markers for clusters 0, 4 and 8 were represented.\n\n\n\nhomeos_markers &lt;- sig_markers[sig_markers$cluster %in% c(\"0\",\"4\",\"8\"),]\nhomeos_markers$avg_log2FC&lt;- as.numeric(homeos_markers$avg_log2FC)\n\nhomeos_markers %&gt;%\n  group_by(cluster) %&gt;% arrange(-avg_log2FC) %&gt;% arrange(cluster) %&gt;% \n  top_n(n = 10, wt = avg_log2FC)-&gt; top10_up \n\nDefaultAssay(Humica) &lt;- \"RNA\"\nHumica&lt;- NormalizeData(Humica)\n\nDotPlot(Humica, features = factor(rev(top10_up$gene %&gt;% unique), levels = rev(top10_up$gene %&gt;% unique)) , dot.scale = 10) +\n  scale_colour_gradient2(low = \"darkblue\", mid = \"white\", high = \"darkred\")+\n  theme(axis.text.x = element_text(angle=90, hjust = 0))+coord_flip()\n\n\n\n\n\n\n\n\n\n\n\nThe most prominent markers of each cluster were represented separately in Feature plots: P2RY12 and KBTBD12 for Homeos1; GRID2 for Homeos2; SERPINE1 for Homeos3 (related to Supplementary Figure 6A).\n\nHumica &lt;- SetIdent(Humica, value = Humica@meta.data$integrated_snn_res.0.2)\nDefaultAssay(Humica)&lt;-\"RNA\"\nHumica &lt;- NormalizeData(Humica)\n\nFeaturePlot(Humica, features = c(\"P2RY12\",\"KBTBD12\",\"GRID2\",\"SERPINE1\"), ncol=4,label = F, repel = TRUE,pt.size = 0.5) & scale_colour_gradientn(colours = c(\"#FCFCFF\",\"#FCFCFF\",\"#DCF2CE\",\"#FFCB77\",\"#BD6B73\",\"#A30B37\"))\n\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n\n\n\n\n\n\n\n\n\n\n\n\n\nGene ontology (GO) was calculated with the enrichGO function from clusterProfiler.\n\n\nGO enrichment was calculated for the list of markers of each homeostatic cluster. The simplify function was used to remove redundancy to the obtained results. The cnetplots were set to represent only the top 3 categories.\n\ni=0\n\np &lt;- list()\nfor(comparison in levels(factor(homeos_markers$cluster))){\n  i = i+1\n  print(paste(comparison))\n  \n  ego &lt;- enrichGO(gene              = homeos_markers[homeos_markers$cluster == comparison,]$gene,\n                  OrgDb             = org.Hs.eg.db,\n                  ont               = \"ALL\",\n                  keyType           = \"SYMBOL\",\n                  pAdjustMethod     = \"BH\",\n                  pvalueCutoff      = 1,\n                  qvalueCutoff      = 0.05,\n                  readable          = T )\n  ego &lt;- simplify(ego, cutoff=0.7, by=\"p.adjust\", select_fun=min)\n  \n  geneList &lt;- homeos_markers[homeos_markers$cluster==comparison,]$avg_log2FC\n  names(geneList)&lt;-homeos_markers[homeos_markers$cluster==comparison,]$gene\n  \n  p[[i]]&lt;- cnetplot(ego, cex_label_category=1,colorEdge = F,shadowtext=\"none\",showCategory = 3,categorySize=\"pvalue\", foldChange =geneList, color_category=\"#339989\") + ggtitle(comparison) &\n    scale_colour_gradient2(high = \"#8B0000\", low=\"#371E97\", midpoint = 0)\n}\n\np[1]\n\n\n\n\n\n\n\np[2]\n\n\n\n\n\n\n\np[3]\n\n\n\n\n\n\n\n\n\n\n\nThe top 10 significant GO terms for each of the homeostatic clusters were represented in barplots to provide a broader insight on the GO enrichment (related to Supplementary Figure 6B). GO was recalculated and edited to obtain the Fold Change of enrichment.\n\ni = 0\nresults &lt;- list()\ngo_all_simplify &lt;- data.frame()\nfor(comparison in levels(factor(homeos_markers$cluster))){\n  i = i+1\n  print(paste(comparison))\n  ego &lt;- enrichGO(gene              = homeos_markers[homeos_markers$cluster == comparison,]$gene,\n                  OrgDb             = org.Hs.eg.db,\n                  ont               = \"ALL\",\n                  keyType           = \"SYMBOL\",\n                  pAdjustMethod     = \"BH\",\n                  pvalueCutoff      = 1,\n                  qvalueCutoff      = 0.05,\n                  readable          = T )\n  ego &lt;- simplify(ego, cutoff=0.7, by=\"p.adjust\", select_fun=min)\n  \n  results[[comparison]] &lt;- ego@result %&gt;%\n    separate(GeneRatio, into = c(\"gene_pos\", \"gene_total\"), sep = \"/\") %&gt;%\n    separate(BgRatio, into = c(\"bg_pos\", \"bg_total\"), sep = \"/\") %&gt;%\n    mutate(FC = (as.numeric(gene_pos)/as.numeric(gene_total)) /\n             (as.numeric(bg_pos)/as.numeric(bg_total)),\n           cluster = comparison) %&gt;%\n    arrange(.$p.adjust)\n  go_all_simplify &lt;- rbind(go_all_simplify, results[[comparison]])\n}\n\n[1] \"0\"\n[1] \"4\"\n[1] \"8\"\n\n\n\nclusterlist &lt;- c(\"0\",\"4\",\"8\")\np&lt;-list()\nfor (i in 1:length(clusterlist)) {\n  data &lt;-go_all_simplify[go_all_simplify$cluster==clusterlist[i],]\n  data$logpadj &lt;- -log10(data$p.adjust)\n  data$logFC&lt;- log10(data$FC)\n  top10 &lt;- data %&gt;%top_n(n = 10, wt = logpadj)\n  top10 &lt;- top10[1:10,]\n  \n  \n  p[[i]]&lt;- ggplot(top10,\n                  aes(fill=logFC,\n                      x=factor(ID, level = rev(ID)),\n                      y=logpadj,\n                      color=\"black\")) +\n    geom_col(color=\"black\", size=0.2) +\n    geom_text(aes(label = Description), hjust=0,position = position_fill(vjust = 0), size = 4, color=\"black\")+\n    theme_bw() +\n    scale_fill_gradientn(colours = c(\"#B9CFD4\",\"#AFAAB9\",\"#B48291\",\"#8C5465\"))+\n    #scale_fill_viridis(option = \"plasma\")+\n    coord_flip()\n}\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\ndo.call(grid.arrange,p)\n\n\n\n\n\n\n\n\n\n\n\n\nThe collection of transcription factors (TFs) and their target genes was obtained from the DoRothEA regulon A. The enrichment analysis was performed using the viper package. The regulon object downloaded from https://github.com/deeenes/DoRothEA/tree/master/data/TFregulons/Robjects_VIPERformat/consensus, already in the appropriate format to be used in the viper pipeline. The Humica.markers file correspond to the broad spectrum differential expression output, mentioned in the “Characterization of the HuMicA” script of this repository. The following represents the loop for the calculation of TF enrichment in all nine clusters.\n\nregulon_A&lt;- viper_regulon\nnames(regulon_A)=sapply(strsplit(names(regulon_A),split=\" - \"),head, 1)\n\nlist &lt;- unique(Humica_markers$cluster)\nTF_activities_all &lt;- data.frame()\n\nfor (i in 1:length(list)) {\n\ndata &lt;- Humica_markers[Humica_markers$cluster==list[i],]\n\n#Exclude probes with unknown or duplicated gene symbol\nDEsignature = subset(data, gene != \"\" )\n\nDEsignature = subset(DEsignature, ! duplicated(gene))\n\n# Estimatez-score values for the GES. Cheeck VIPER manual for details\n\nmyStatistics = matrix(DEsignature$avg_log2FC, dimnames = list(DEsignature$gene,\n                                                              \n                                                              'avg_log2FC') )\n\nmyPvalue = matrix(DEsignature$p_val_adj, dimnames = list(DEsignature$gene, 'padj') )\n\nmySignature = (qnorm(myPvalue/2, lower.tail = FALSE) * sign(myStatistics))[, 1]\n\nmySignature = mySignature[order(mySignature, decreasing = T)]\n\n# Estimate TF activities\n\nmrs = msviper(ges = mySignature, regulon = regulon_A,minsize = 25, ges.filter = F)\n\nTF_activities = data.frame(Regulon = names(mrs$es$nes),\n                           \n                           Size = mrs$es$size[ names(mrs$es$nes) ],\n                           \n                           NES = mrs$es$nes,\n                           \n                           p.value = mrs$es$p.value,\n                           \n                           FDR = p.adjust(mrs$es$p.value, method = 'fdr'))\n\nTF_activities = TF_activities[ order(TF_activities$p.value), ]\nTF_activities$cluster &lt;- list[i]\nTF_activities_all&lt;- rbind(TF_activities_all, TF_activities)\n}\n\n\n\nThe plot depicts the enrichment for all clusters in the HuMicA but only considers the significant TFs for the three homeostatic clusters is considered for representation. The statistically significant TFs were considered for an adj p value (FDR) &lt; 0.05.\n\nTF_activities_homeos &lt;- TF_activities_all[TF_activities_all$cluster %in% c(\"0\",\"4\",\"8\"),]\n\nTF_activities_homeos_sig &lt;- TF_activities_homeos[TF_activities_homeos$FDR &lt; 0.05,]\n\n#Plot TF enrichment results\nTF_activities_all &lt;- TF_activities_all%&gt;% \n  mutate(logFDR = -log(FDR))\n\ncommon_features &lt;- TF_activities_homeos_sig$Regulon %&gt;% unique()\n\nggplot(TF_activities_all %&gt;% dplyr::filter(Regulon %in% common_features), aes(as.factor(cluster), y= factor(Regulon, levels = common_features),color=NES,size =logFDR)) +\n  geom_point() +\n  scale_color_gradient2(low=\"#47663D\",mid = \"white\",high=\"#B86B00\")+\n  theme_pubr(border = 1)+ \n  coord_flip()+\n  theme(axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5))"
  }
]